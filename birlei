/**
 * ## birlei
 *
 * ### How to Import
 *
 *     use <birlei>
 *
 * ### Purpose
 *
 * This is the core of the library's algorithm set.  It evolved from having two
 * indices,
 * `begin_i` and `end_i` so that functions could be made to recursively iterate
 * over them.  However, it didn't contain a step, but there was already an
 * object that worked for list comprehension and it worked the same way as lists
 * would.
 *
 * However, to actually use a range or list recursively, they would have to be
 * indexable in a similar way, so the [ranges](#file-range) library was made.
 * `begin_i` would be used to count to `end_i` over the length of the object,
 * dereferencing each element as needed.
 *
 * Keeping this in the user facing API was done because just counting from N to
 * M is very common, and without dereferencing a list or range it's marginally
 * faster.
 */
use <range>
use <function>
use <indexable>
use <param_check>

/**
 * @typedef {(number|range|list)} Birl
 * - If `number`, start index to iterate over
 * - If `range`, indices to iterate over
 * - If `list`, indices to iterate over
 */

/**
 * @typedef {(number|undef)} EndI
 * - If related `birl` is a number, then this is the end index to iterate
 *   over.
 *   - If this value is less than the related birl's value, then nothing is
 *     iterated over.
 */

/**
 * @callback SpaceshipFn
 * Compares a derived comparison value against an internally stored value.
 *
 * Definitions:
 *
 * - probe: the argument passed to this callback by the algorithm.
 * - comparison value: the value derived from the probe that is actually
 *   compared to the stored value.
 *
 * Probe convention:
 *
 * - Without an [Algorithm Adaptor](#algorithm-adaptors), the probe is a number
 *   within the `birlei`.
 * - With an Algorithm Adaptor, the probe is the adaptor's output:
 *   - [`it_each`](#f-it_each): `slr_element`.
 *   - [`it_enum`](#f-it_enum): `[index, slr_element]`.
 *   - [`it_idxs`](#f-it_idxs): `index`.
 *
 * The callback is responsible for mapping probe → comparison value.  The
 * mapping is defined by the callback's closure over the searched structure (slr
 * or any other abstract structure) and/or by how it interprets adaptor outputs.
 *
 * @param {any} probe
 *   The probe value as defined above.
 *
 * @returns {number}
 *   - comparison value < stored value: return < 0
 *   - comparison value == stored value: return 0
 *   - comparison value > stored value: return > 0
 */

/**
 * @callback PredFn
 * Compares a derived comparison value against an internally stored value.
 *
 * Definitions:
 *
 * - probe: the argument passed to this callback by the algorithm.
 * - comparison value: the value derived from the probe that is actually
 *   compared to the stored value.
 *
 * Probe convention:
 *
 * - Without an [Algorithm Adaptor](#algorithm-adaptors), the probe is a number
 *   within the `birlei`.
 * - With an Algorithm Adaptor, the probe is the adaptor's output:
 *   - [`it_each`](#f-it_each): `slr_element`.
 *   - [`it_enum`](#f-it_enum): `[index, slr_element]`.
 *   - [`it_idxs`](#f-it_idxs): `index`.
 *
 * The callback is responsible for mapping probe → comparison value.  The
 * mapping is defined by the callback's closure over the searched structure (slr
 * or any other abstract structure) and/or by how it interprets adaptor outputs.
 *
 * @param {any} probe
 *   The probe value as defined above.
 *
 * @returns {bool}
 *   - comparison value matches stored value: return `true`
 *   - comparison value doesn't match stored value: return `false`
 */

/**
 * @callback ReductionFn
 *
 * Mutates the accumulator given a derived comparison value.
 *
 * Definitions:
 *
 * - probe: the argument passed to this callback by the algorithm.
 * - comparison value: the value derived from the probe that is actually
 *   compared to the stored value.
 *
 * Probe convention:
 *
 * - Without an [Algorithm Adaptor](#algorithm-adaptors), the probe is a number
 *   within the `birlei`.
 * - With an Algorithm Adaptor, the probe is the adaptor's output:
 *   - [`it_each`](#f-it_each): `slr_element`.
 *   - [`it_enum`](#f-it_enum): `[index, slr_element]`.
 *   - [`it_idxs`](#f-it_idxs): `index`.
 *
 * The callback is responsible for mapping probe → comparison value.  The
 * mapping is defined by the callback's closure over the searched structure (slr
 * or any other abstract structure) and/or by how it interprets adaptor outputs.
 *
 * > NOTE:
 * >
 * > `acc` **is the second parameter** which is different from most languages.
 * > This is to keep it consistent with the rest of the `PPMRRAIR` functions
 * > and this library in general.  You have been warned.
 *
 * @param {any} probe
 *   The probe value as defined above.
 * @param {any} accumulator
 *   The accumulator being mutated.
 *
 * @returns {any}
 *   The newly mutated accumulator value or the initial value if the `birlei`
 *   was empty.
 */

/**
 * @callback ReductionAirFn
 *
 * Mutates the accumulator given a derived comparison value.
 *
 * Definitions:
 *
 * - probe: the argument passed to this callback by the algorithm.
 * - comparison value: the value derived from the probe that is actually
 *   compared to the stored value.
 *
 * Probe convention:
 *
 * - Without an [Algorithm Adaptor](#algorithm-adaptors), the probe is a number
 *   within the `birlei`.
 * - With an Algorithm Adaptor, the probe is the adaptor's output:
 *   - [`it_each`](#f-it_each): `slr_element`.
 *   - [`it_enum`](#f-it_enum): `[index, slr_element]`.
 *   - [`it_idxs`](#f-it_idxs): `index`.
 *
 * The callback is responsible for mapping probe → comparison value.  The
 * mapping is defined by the callback's closure over the searched structure (slr
 * or any other abstract structure) and/or by how it interprets adaptor outputs.
 *
 * > NOTE:
 * >
 * > `acc` **is the second parameter** which is different from most languages.
 * > This is to keep it consistent with the rest of the `PPMRRAIR` functions
 * > and this library in general.  You have been warned.
 *
 * @param {any} probe
 *   The probe value as defined above.
 * @param {any} accumulator
 *   The accumulator being mutated.
 *
 * @returns {list[bool,any]}
 *   List containing if to continue Boolean and the newly mutated accumulator
 *   value.
 */

/**
 * @callback PredMapFn
 * Compares a derived comparison value against an internally stored value and
 * returns a value if:
 *
 * Definitions:
 *
 * - probe: the argument passed to this callback by the algorithm.
 * - comparison value: the value derived from the probe that is actually
 *   compared to the stored value.
 *
 * Probe convention:
 *
 * - Without an [Algorithm Adaptor](#algorithm-adaptors), the probe is a number
 *   within the `birlei`.
 * - With an Algorithm Adaptor, the probe is the adaptor's output:
 *   - [`it_each`](#f-it_each): `slr_element`.
 *   - [`it_enum`](#f-it_enum): `[index, slr_element]`.
 *   - [`it_idxs`](#f-it_idxs): `index`.
 *
 * The callback is responsible for mapping probe → comparison value.  The
 * mapping is defined by the callback's closure over the searched structure (slr
 * or any other abstract structure) and/or by how it interprets adaptor outputs.
 *
 * @param {any} probe
 *   The probe value as defined above.
 * @param {bool} [get_value=undef]
 *   States if to return the predicate result or the probed value.
 *
 * @returns {any}
 *   - if `get_value` is falsy, then
 *     - comparison value matches stored value: return `true`
 *     - comparison value doesn't match stored value: return `false`
 *   - else returns the probed value
 */

/**
 * @callback MapperFn
 * Maps a probed value to a list.
 *
 * Definitions:
 *
 * - probe: the argument passed to this callback by the algorithm.
 *
 * Probe convention:
 *
 * - Without an [Algorithm Adaptor](#algorithm-adaptors), the probe is a number
 *   within the `birlei`.
 * - With an Algorithm Adaptor, the probe is the adaptor's output:
 *   - [`it_each`](#f-it_each): `slr_element`.
 *   - [`it_enum`](#f-it_enum): `[index, slr_element]`.
 *   - [`it_idxs`](#f-it_idxs): `index`.
 *
 * The callback is responsible for mapping probe value.  The mapping is defined
 * by the callback's closure over the searched structure (slr or any other
 * abstract structure) and/or by how it interprets adaptor outputs.
 *
 * @param {any} probe
 *   The probe value as defined above.
 *
 * @returns {any}
 *   Value that was mapped given the probe.
 */

/**
 * @typedef {(SpaceshipFn|PredFn|ReductionFn|ReductionAirFn|PredMapFn|MapperFn)} PpmrrairFn
 *
 * The exact meaning depends on the type expected.  For more info, go to the
 * type you are interested in.
 */

/**
 * @callback MapBackFn
 *
 * When an algorithm is iterating, it iterates over a contiguous set of
 * integers.  The original set of values don't have to be contiguous.  This
 * function, remaps the contiguous integers back to the original set of values.
 *
 * @param {(number|undef)} i
 *   Index to remap or undef if no index to remap.
 *
 * @returns {(number|undef)}
 *   - If originating algo_fn is returning an index, this function will map it
 *     to the correct index.
 *   - If passed undef, returns undef.
 */

/** ### Functions */

/**
 * Helper which calls `algo_fn` but remaps signature `function(fn, birl, end_i)`
 * to signature `function(fn, begin_i, end_i, map_back_fn)`.
 *
 * @param {function(fn: PpmrrairFn, begin_i: number, end_i: number, map_back_fn: MapBackFn): any} algo_fn
 *   Function with `(fn, begin_i, end_i, map_back_fn)` signature to call, where:
 *
 *   - `fn`: `number`
 *     - ppmrrair function to call.
 *   - `begin_i`: `number`
 *     - Starting index to operate on.
 *   - `end_i`: `number`
 *     - Ending index to operate on.
 *   - `map_back_fn`: `function(i: number|undef): (number|undef)`
 *     - When the algorithm is returning a number from the `birlei`, the
 *       algorithm is to pass the index it found to this function, which will
 *       remap it back to the `birlei` value.
 *     - If this function is passed `undef`, it returns `undef` for
 *       convenience.
 * @param {PpmrrairFn} ppmrrair_fn
 *   - Takes index or element and possibly a second param and returns a value.
 * @param {Birl} birl
 * @param {EndI} end_i
 *
 * @returns {any}
 *   Result of `algo_fn()`.
 */
function birlei_to_begin_i_end_i(algo_fn, ppmrrair_fn, birl, end_i) =
  let ( _ = verify_fn(algo_fn) )
  let ( _ = verify_fn(ppmrrair_fn) )
  let ( _ = verify_birlei(birl, end_i) )
  is_num(birl)
  ? // (NUM, NUM)
    assert(is_num(end_i), str("end_i (", end_i, ") must be a number."))
    algo_fn(ppmrrair_fn, birl, end_i, function(i) i)
  : let ( pc = param_count(ppmrrair_fn) )
    is_list(birl)
    ? // LIST
      let (
        result = algo_fn(
          pc == 1
          ? function(i) ppmrrair_fn(birl[i])
          : function(i, o) ppmrrair_fn(birl[i], o),
          0, len(birl)-1, function(i) is_undef(i) ? undef : birl[i])
      )
      result
    : // RANGE
      let ( _ = verify_r(birl) )
      birl[1] == 1
      ? // If step is 1, no need to use range which reduces indirection.
        algo_fn(ppmrrair_fn, birl[0], birl[2], function(i) is_undef(i) ? undef : i)
      : let (
          rc = range_len(birl),
          end2_i = is_undef(rc) ? -1 : rc - 1,
          result = algo_fn(
            pc == 1
            ? function(i) ppmrrair_fn(el(birl, i))
            : function(i, o) ppmrrair_fn(el(birl, i), o),
            0, end2_i, function(i) is_undef(i) ? undef : el(birl, i))
        )
        result
;

/**
 * Helper to convert birlei parameters to an lr to traverse.
 *
 * @param {Birl} birl
 * @param {EndI} end_i
 *
 * @returns {(list|range)}
 *   Returns a list or range describing the indices to traverse.
 */
function birlei_to_indices(birl, end_i) =
  let ( _ = verify_birlei(birl, end_i) )
  is_num(birl)
  ? range(birl, end_i)
  : birl
;

// /**
//  * Validates if the range specified by `(birl, end_i)` are within the bounds of
//  * [`valid_min`, `valid_max`].  Asserts if not within range.
//  *
//  * @param {number} valid_min
//  *   Minimum value that birl/end_i can encode.
//  * @param {number} valid_max
//  *   Maximum value that birl/end_i can encode.
//  * @param {(number|range|list)} birl
//  *   - If number, start index to check
//  *   - If range, indices to check
//  *   - If list, indices to check
//  * @param {(number|undef)} end_i
//  *   - If `birl` is a number, end index to check.
//  *
//  * @returns {true}
//  *   if valid, returns true, else false, unless raise_assertion is true, then
//  *   assert on failure.
//  */
// function birlei_verify(valid_min, valid_max, birl, end_i, raise_assertion) =
//   let (
//     _min = is_num(birl)
//       ? birl
//       : is_list(birl)
//         ? min(birl)
//         : birl[1] > 0
//           ? range_el(birl, 0)
//           : range_el(birl, -1),
//     _max = is_num(birl)
//       ? end_i
//       : is_list(birl)
//         ? max(birl)
//         : birl[1] > 0
//           ? range_el(birl, -1)
//           : range_el(birl, 0)
//   )
//   valid_min <= _min && _max <= valid_max
//   ? true
//   : raise_assertion
//     ? assert(valid_min <= _min && _max <= valid_max,
//         str("birlei (", [ birl, end_i ], ") out of range (", [ valid_min,
//           valid_max ], ")"))
//     : false
// ;
