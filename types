/**
 * ## types
 * 
 * ### Purpose
 *
 * This library allows representing types as enumerated values, strings or
 * minimal strings for complex types.
 */
use <base_algos>
use <indexable>
use <any_all>
include <types_consts>

/** ### Tests */

/**
 * @typedef {number} type_enum
 *
 *   Number representing a type.  Use [type_enum_to_str](#type_enum_to_str) to
 *   get name of type.
 */
 
/**
 * States if a te (type_enum) represents an indexable type, either directly with
 * `sl[index]` or indirectly with `range_el(r, index)`.
 *
 * @param {type_enum} type_enum
 *   Enum for type (See [type_enum](#type_enum))
 *
 * @returns {bool}
 *   Returns `true` if indexable, `false` otherwise.
 */
function is_indexable_te(type_enum) =
  type_enum < UNKNOWN
;

/**
 * States if object is an integer (has no fractional part).
 *
 * @param {any} o
 *   Object to query.
 *
 * @returns {bool}
 *   Returns `true` if integer, `false` otherwise.
 */
function is_int(o) =
  is_num(o) && floor(o) == o
;

/**
 * States if object is a float (has a fractional part).
 *
 * @param {any} o
 *   Object to query.
 *
 * @returns {bool}
 *   Returns `true` if float, `false` otherwise.
 */
function is_float(o) =
  is_num(o) && floor(o) != o
;

/**
 * States if object is a NaN object.
 *
 * @param {any} n
 *   Object to query.
 *
 * @returns {bool}
 *   Returns `true` if NaN, `false` otherwise.
 */
function is_nan(n) =
  n != n
;

/** ### Type Introspection */

/**
 * @type {list[string]}
 *
 * The names of the types indexed by the type enums.
 */
_TYPE_NAMES = [
    "range"     //  0
  , "list"      //  1
  , "str"       //  2
  , "*UNKNOWN*" //  3
  , "slice"     //  4
  , "undef"     //  5
  , "bool"      //  6
  , "func"      //  7
  , "num"       //  8
  , "int"       //  9
  , "float"     // 10
  , "NaN"       // 11
];

/**
 * Function to get the type of an object as an enum.
 *
 * @param {any} o
 *   The object to get the type from.
 * @param {bool} distinguish_float_from_int
 *   Flag to indicate if to distinguish floats from integers rather than
 *   grouping them together as numbers.
 *
 * @returns {number}
 *   The number corresponding to the type enum.
 */
function type_enum(o, distinguish_float_from_int = false) =
  is_string(o)   ? STR    :
  is_list(o)     ? o[0] == "SLICE"
                   ? SLICE
                   : LIST :
  is_num(o[0])   ? RANGE  :
  is_undef(o)    ? UNDEF  :
  is_num(o)      ? distinguish_float_from_int
                 ? floor(o) == o
                   ? INT
                   : FLOAT
                 : NUM    :
  is_function(o) ? FUNC   :
  is_bool(o)     ? BOOL   :
  is_nan(o)      ? NAN    :
                   UNKNOWN;

/**
 * Convert the type enum to a string.
 *
 * @param {number} i
 *   Type enum to convert.
 *
 * @returns {string}
 *   The string corresponding to the type enum.  If type enum is not recognised,
 *   return "*INVALID TYPE*".
 */
function type_enum_to_str(i) =
  assert(is_num(i))
  0 <= i && i < len(_TYPE_NAMES)
  ? _TYPE_NAMES[i]
  : "*INVALID TYPE*"
;

/**
 * Gets a string representation of the type of `o`.
 *
 * @param {any} o
 *   Object to query.
 *
 * @returns {bool}
 *   Returns string representation of `o`'s type.
 */
function type(o, distinguish_float_from_int = false) =
  type_enum_to_str(type_enum(o, distinguish_float_from_int));
;

/**
 * Attempts to simplify the type structure of object o recursively.
 *
 * - If o is a list
 *   - if all elements in that list contain the same type structure,
 *     - simplify the list by only showing that structure once and append to it
 *       how many times it is repeated.
 *   - else if not the same, then recursively simplify each element.
 * - else it's some other type, so will just output the type of the object.
 *
 * @param {any} o
 *   Gets the simplified type structure of o.
 *
 * @returns {string}
 *   This string is a representation of the type structure of o.
 */
function type_structure(o) =
  let (
    gen_te_structure = // Generate detailed structure
      function(o)
        let (
          et = type_enum(o)
        )
        et == LIST
        ? // it_each(o, map())(function(e) gen_te_structure(e))
          [ for (e = o) gen_te_structure(e) ] // same as above but is most likely more performant.
        : et
    ,
    simplify = // Simplifies the detailed type structure
      function(type_structure)
        is_list(type_structure)
          ? let (
              len_gt = len(type_structure)
            )
            len_gt == 0
            ? [ " (0 elements) " ]
            : let (
                sub_tes = simplify(type_structure[0])
              )
              len_gt == 1
              ? concat( [ sub_tes ], [ " (1 element)" ] )
              : all(1, len_gt-1)(
                  function(i) type_structure[0] == type_structure[i]
                )
                ? concat(
                    [ sub_tes ],
                    [ str(" ... (", len_gt, " elements)") ]
                  )
                : // let (z =[ for (i = fwd_i(type_structure)) echo("i", i, type_structure[i], simplify(type_structure[i])) simplify(type_structure[i]) ] ) echo("z", z) z
                  it_each(type_structure, map())( function(e) simplify(e) )
          : type_structure
    ,
    indent = function(spaces, s = "")
      assert(is_num(spaces))
      assert(spaces >= 0)
      spaces == 0
      ? s
      : indent(spaces - 1, str(s, " "))
    ,
    result_to_str = // Convert the simplified structure to a string
      function(simplified_te_structure, depth = 0)
        is_list(simplified_te_structure)
        ? assert(len(simplified_te_structure) != 0,
            "All lists should have at least one element")
          let ( last = el(simplified_te_structure, -1) )
          is_string(last)
          ? // List end in string stating number of repeats
            str(
              indent(depth),
              "[ ",
              len(simplified_te_structure) > 1
              ? let (first = result_to_str(simplified_te_structure[0], depth+1))
                it_each(simplified_te_structure, reduce(first),
                    fwd_i(simplified_te_structure, 1, -2))(
                  function(e, acc)
                    str(acc, ", ", indent(depth+1), result_to_str(e))
                )
              : "",
              last,
              indent(depth),
              " ]"
            )
          : // List doesn't end in a string.
            let ( first = result_to_str(simplified_te_structure[0], depth+1) )
            str(
              "[ ",
              it_each(simplified_te_structure, reduce(first), 1)(
                function(e, acc) str(acc, ", ", indent(depth+1), result_to_str(e))),
              " ]"
            )
        : // not a list.  Must be a type enum.
          assert(is_num(simplified_te_structure),
            str("Must be a number, but found: ", simplified_te_structure))
          type_enum_to_str(simplified_te_structure)
    ,
    type_structure = gen_te_structure(o),
    result = simplify(type_structure)
  )
  // result
  result_to_str(result)
;

/**
 * Gives a string that outputs the type_structure and value of object passed in.
 *
 * @param {any} o
 *   The object to list information about.
 *
 * @returns {string}
 *   Give info for `o` as string.
 */
function type_value(o) =
  str("value(", type_structure(o), "): {", o, "}")
;

echo(concat("hello", [1]));
echo(concat(["hello"], [1]));
echo("type_structure 1", type_structure("hi"));
echo("type_structure 2", type_structure(["hi", 1]));
echo("type_structure 3", type_structure(["hi", []]));
echo("type_structure 4", type_structure(["hi", ""]));
