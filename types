use <base_algos>
use <list>

/** Enum for unknown type */
function UNKNOWN() =  0;
/** Enum for undef type */
function UNDEF()   =  1;
/** Enum for boolean type */
function BOOL()    =  2;
/** Enum for function type */
function FUNC()    =  3;
/** Enum for number type */
function NUM()     =  4;
/** Enum for integer type */
function INT()     =  5;
/** Enum for floating point type */
function FLOAT()   =  6;
/** Enum for NaN */
function NAN()     =  7;
/** Enum for range type */
function RANGE()   =  8;
/** Enum for string type */
function STR()     =  9;
/** Enum for list type */
function LIST()    = 10;

/**
 * The names of the types indexed by the type enums.
 */
function TYPE_NAMES() = [
    "*UNKNOWN*" //  0
  , "undef"     //  1
  , "bool"      //  2
  , "func"      //  3
  , "num"       //  4
  , "int"       //  5
  , "float"     //  6
  , "NaN"       //  7
  , "range"     //  8
  , "str"       //  9
  , "list"      // 10
];

/**
 * Function to get the type of an object as an enum.
 *
 * @param o (any)
 *   The object to get the type from.
 *
 * @returns (number)
 *   The number corresponding to the type enum.
 */
function type_enum(o, distinguish_float_from_int = false) =
  is_undef(o)    ? UNDEF()  :
  is_string(o)   ? STR()    :
  is_list(o)     ? LIST()   :
  is_num(o[0])   ? RANGE()  :
  is_num(o)      ? distinguish_float_from_int
                 ? floor(o) == o
                   ? INT()
                   : FLOAT()
                 : NUM()    :
  is_function(o) ? FUNC()   :
  is_bool(o)     ? BOOL()   :
  is_nan(o)      ? NAN()    :
                   UNKNOWN();

/**
 * States if a te (type_enum) represents an indexable type, either directly with
 * `sl[index]` or indirectly with `range_el(r, index)`.
 *
 * @param type_enum (number)
 *   Enum for type (see {@link type_enum})
 *
 * @returns (bool)
 *   Returns true if indexable, false otherwise.
 */
function is_indexable_te(type_enum) =
  type_enum >= RANGE()
;

/**
 * States if a te (type_enum) represents an directly indexable type with
 * `sl[index]`.
 *
 * @param type_enum (number)
 *   Enum for type (see {@link type_enum})
 *
 * @returns (bool)
 *   Returns true if directly indexable, false otherwise.
 */
function is_indexable_non_range_te(type_enum) =
  type_enum >= STR()
;

/**
 * States if object is an integer (has no fractional part).
 *
 * @param o (any)
 *   Object to query.
 *
 * @returns (bool)
 *   Returns true if integer, false otherwise.
 */
function is_int(o) =
  is_num(o) && floor(o) == o
;

/**
 * States if object is a float (has a fractional part).
 *
 * @param o (any)
 *   Object to query.
 *
 * @returns (bool)
 *   Returns true if float, false otherwise.
 */
function is_float(o) =
  is_num(o) && floor(o) != o
;

/**
 * States if object is a NaN object.
 *
 * @param o (any)
 *   Object to query.
 *
 * @returns (bool)
 *   Returns true if NaN, false otherwise.
 */
function is_nan(n) =
  n != n
;

/**
 * Convert the type enum to a string.
 *
 * @param (number)
 *   Type enum to convert.
 *
 * @returns (string)
 *   The string corresponding to the type enum.  If type enum is not recognised,
 *   return "*INVALID TYPE*".
 */
function type_enum_to_str(i) =
  assert(is_num(i))
  0 <= i && i < len(TYPE_NAMES())
  ? TYPE_NAMES()[i]
  : "*INVALID TYPE*"
;

/**
 * Gets a string representation of the type of `o`.
 *
 * @param o (any)
 *   Object to query.
 *
 * @returns (bool)
 *   Returns string representation of `o`'s type.
 */
function type(o, distinguish_float_from_int = false) =
  type_enum_to_str(type_enum(o, distinguish_float_from_int));
;

/**
 * Attempts to simplify the type structure of object o recursively.
 *
 * - If o is a list
 *   - if all elements in that list contain the same type structure,
 *     - simplify the list by only showing that structure once and append to it
 *       how many times it is repeated.
 *   - else if not the same, then recursively simplify each element.
 * - else it's some other type, so will just output the type of the object.
 *
 * @param o (any)
 *   Gets the simplified type structure of o.
 *
 * @returns (string)
 *   This string is a representation of the type structure of o.
 */
function type_structure(o) =
  let (
    gen_te_structure = // Generate detailed structure
      function(o)
        let (
          et = type_enum(o)
        )
        et == LIST()
        ? // in_list(o, function_map(), function(e) gen_te_structure(e))
          [ for (e = o) gen_te_structure(e) ] // same as above but is most likely more performant.
        : et
    ,
    simplify = // Simplifies the detailed type structure
      function(type_structure)
        is_list(type_structure)
          ? let (
              len_gt = len(type_structure)
            )
            len_gt == 0
            ? [ " (0 elements) " ]
            : let (
                sub_tes = simplify(type_structure[0])
              )
              len_gt == 1
              ? concat( [ sub_tes ], [ " (1 element)" ] )
              : all(function(i) type_structure[0] == type_structure[i], 1, len_gt-1)
                ? concat(
                    [ sub_tes ],
                    [ str(" ... (", len_gt, " elements)") ]
                  )
                : // let (z =[ for (i = it_fwd_i(type_structure)) echo("i", i, type_structure[i], simplify(type_structure[i])) simplify(type_structure[i]) ] ) echo("z", z) z
                  in_list(type_structure, function_map(), function(e) simplify(e))
          : type_structure
    ,
    indent = function(spaces, s = "")
      assert(is_num(spaces))
      assert(spaces >= 0)
      1 ? "" :
      spaces == 0
      ? s
      : indent(spaces - 1, str(s, " "))
    ,
    result_to_str = // Convert the simplified structure to a string
      function(simplified_te_structure, depth = 0)
        is_list(simplified_te_structure)
        ? assert(len(simplified_te_structure) != 0,
            "All lists should have at least one element")
          let ( last = el(simplified_te_structure, -1) )
          is_string(last)
          ? // List end in string stating number of repeats
            str(
              indent(depth),
              "[ ",
              len(simplified_te_structure) > 1
              ? let (first = result_to_str(simplified_te_structure[0], depth+1))
                in_list(simplified_te_structure, fn_reduce(first),
                  function(e, acc) str(acc, ", ", indent(depth+1), result_to_str(e, depth+1)),
                  1, el_idx(simplified_te_structure, -2))
              : "",
              last,
              indent(depth),
              " ]"
            )
          : // List doesn't end in a string.
            let ( first = result_to_str(simplified_te_structure[0], depth+1) )
            str(
              "[ ",
              in_list(simplified_te_structure, fn_reduce(first),
                function(e, acc) str(acc, ", ", indent(depth+1), result_to_str(e)),
                1),
              " ]"
            )
        : // not a list.  Must be a type enum.
          assert(is_num(simplified_te_structure),
            str("Must be a number, but found: ", simplified_te_structure))
          type_enum_to_str(simplified_te_structure)
    ,
    type_structure = gen_te_structure(o),
    result = simplify(type_structure)
  )
  // result
  result_to_str(result)
;

/**
 * Gives a string that outputs the type_structure and value of object passed in.
 *
 * @param o (any)
 *   The object to list information about.
 *
 * @returns (string)
 *   Give info for `o` as string.
 */
function type_value(o) =
  str("value(", type_structure(o), "): {", o, "}")
;

echo(concat("hello", [1]));
echo(concat(["hello"], [1]));
echo("type_structure 1", type_structure("hi"));
echo("type_structure 2", type_structure(["hi", 1]));
echo("type_structure 3", type_structure(["hi", []]));
echo("type_structure 4", type_structure(["hi", ""]));
