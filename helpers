use <base_algos>
use <range>
use <types>
use <list>
use <test>
use <transform>

/** Convert radians to degrees
 *
 * @param radians (number):
 *   radians to convert.
 *
 * @returns (number):
 *   Equivalent degrees.
 */
function r2d(radians) = radians * (180 / PI);

/** Convert degrees to radians
 *
 * @param degrees (number):
 *   degrees to convert.
 *
 * @returns (number):
 *   Equivalent radians.
 */
function d2r(degrees) = degrees * (PI / 180);

/**
 * Calculates the arc length between vectors A and B at radius R.
 *
 * @param A (list)
 *   First vector.
 * @param B (list)
 *   Second vector.
 * @param R (undef | number)
 *   Radius to use to measure the length along a sphere's great arc.
 *   - If undef then will use the magnitude of A. Asserts if magnitude of B is
 *     not the same.
 *   - If R=1, then the result is equivalent to the arc angle in radians.
 *   - If R=180/PI, then the result is equivalent to the arc angle in degrees.
 *
 * @returns (number)
 *   The length of the great arc between the two vectors for a sphere of radius
 *   R.
 */
function arc_len(A, B, R=undef) =
  (
    is_undef(R)
    ? assert(abs(norm(A)-norm(B)) < 1e8, str("If not specifying R, A (", norm(A), ") and B (", norm(B), ") must be the same magnitude."))
      norm(A)
    : R
  )
  * d2r(atan2(norm(cross(A, B)), A*B))
;

/**
 * Central angle (degrees) from arc length on a circle.
 * θ_deg = (arc_len / radius) * (180/π)
 *
 * @param arc_len (number)
 *   Arc length along the circle.
 * @param radius (number)
 *   Circle radius (must be non-zero).
 * @returns (number)
 *   Angle in degrees. Sign follows arc_len.
 */
function arc_len_angle(arc_len, radius) =
  assert(radius != 0, "arc_len_angle: radius must be non-zero")
  r2d(arc_len / radius)
;

////////////////////////////////////////////////////////////////////////////////

/**
 * Computes the intersection points of a line and a circle.
 *
 * The line is y = m*x + b and the circle is x^2 + y^2 = R^2.
 *
 * @param R (number):
 *   Radius of the circle.  Callers such as arc_len_for_shift pass R > 0.
 * @param m (number):
 *   Slope of the line (dy/dx).
 * @param b (number):
 *   Y-intercept of the line.
 *
 * @returns (list):
 *   [] if there is no real intersection, or [[x1, y1], [x2, y2]] where each
 *   [x, y] is a Cartesian intersection point.  For a tangent line both
 *   returned points are identical.
 */
function _circle_line_intersections(R, m, b) =
  let(
    A = 1 + m*m,
    D = A*R*R - b*b
  )
  D < 0 ? [] :
  let(
    s  = sqrt(D),
    x1 = (-m*b + s) / A,
    x2 = (-m*b - s) / A,
    y1 = m*x1 + b,
    y2 = m*x2 + b
  )
  [[x1,y1],[x2,y2]]
;

/**
 * Picks the "right-side" intersection point from up to two candidates.
 *
 * This is intended to operate on the list returned by
 * _circle_line_intersections().  It chooses a single point on the right
 * half-plane according to a deterministic ordering.
 *
 * @param ptlist (list):
 *   List of zero, one, or two points [[x1, y1], [x2, y2]].
 *
 * @returns (list|undef):
 *   The selected point [x, y] or undef if no point has x >= 0.  Among
 *   points with x >= 0 it selects the one with the largest x; if x ties,
 *   it selects the point with the smaller y (the lower point).
 */
function _pick_right(ptlist) =
  len(ptlist)==0 ? undef :
  let(
    p0 = ptlist[0],
    p1 = ptlist[1],
    c0 = p0[0] >= 0,
    c1 = p1[0] >= 0
  )
  (!c0 && !c1) ? undef :
  ( c0 && !c1) ? p0   :
  (!c0 &&  c1) ? p1   :
  // both x >= 0: choose larger x; tie-breaker: lower y
  (p0[0] > p1[0]) ? p0 :
  (p0[0] < p1[0]) ? p1 :
  (p0[1] <= p1[1]) ? p0 : p1
;

/**
 * Computes the polar angle of a point on the circle in degrees.
 *
 * @param pt (list):
 *   Point [x, y] in Cartesian coordinates.
 *
 * @returns (number):
 *   Angle in degrees measured from the +X axis using atan2(y, x), with the
 *   usual range (-180, 180].
 */
function _theta_deg(pt) = atan2(pt[1], pt[0]);

/**
 * Computes the smallest signed difference between two angles in degrees.
 *
 * @param a1 (number):
 *   First angle in degrees.
 * @param a2 (number):
 *   Second angle in degrees.
 *
 * @returns (number):
 *   Signed difference a2 - a1 wrapped into the range (-180, 180].  This is
 *   the minimal rotation in degrees that moves a1 onto a2.
 */
function _wrap_diff_deg(a1, a2) =
  let(d = a2 - a1)
  (d >  180)
  ? (d - 360)
  : (d < -180)
    ? (d + 360)
    : d
;

// ---------- Public API (Right-side tracking) ----------

/**
 * Given a circle R = sqrt(x^2 + y^2) and a line y = m*x + (b + a),
 * compute the arc-length difference Δs along the circle between the
 * intersection of the original line y = m*x + b and the shifted line
 * y = m*x + (b + a). Only the right-side (x >= 0) intersection is tracked.
 *
 * @param R (number)
 *   circle radius
 * @param m (number)
 *   slope (dy/dx)
 * @param a (number)
 *   vertical shift of the line relative to b
 * @param b (number)
 *   original y-intercept (default 0)
 *
 * @returns (number)
 *   Δs (nonnegative) or undef if the right-side intersection does not exist
 *   before or after the shift.
 */
function arc_len_for_shift(R, m, a, b = 0) =
  assert(R > 0, "R must be > 0.")
  let(
    pts0 = _circle_line_intersections(R, m, b),
    p0   = _pick_right(pts0),
    pts1 = _circle_line_intersections(R, m, b + a),
    p1   = _pick_right(pts1)
  )
  (p0 == undef || p1 == undef) ? undef :
  let(
    t0_deg  = _theta_deg(p0),
    t1_deg  = _theta_deg(p1),
    dth_deg = _wrap_diff_deg(t0_deg, t1_deg),
    dth_rad = d2r(abs(dth_deg))
  )
  R * dth_rad
;

/**
 * Given a circle R = sqrt(x^2 + y^2) and an original line y = m*x + b,
 * find the vertical shift values a that would produce a specified arc-length
 * difference Δs between the original intersection and the shifted line
 * y = m*x + (b + a), tracking only the right-side (x >= 0) intersection.
 *
 * @param R (number)
 *   circle radius
 * @param m (number)
 *   slope (dy/dx)
 * @param delta_s (number)
 *   desired arc length difference
 * @param b (number)
 *   original y-intercept (default 0)
 *
 * @returns [a_up_or_undef, a_down_or_undef]
 *   a_up ≥ 0, a_down ≤ 0.
 */
function shift_for_arc_len(R, m, delta_s, b = 0) =
  assert(R > 0, "R must be > 0.")
  let(
    // Must have a right-side intersection to begin with
    p0 = _pick_right(_circle_line_intersections(R, m, b))
  )
  (p0 == undef) ? [undef, undef] :
  let(
    K     = R * sqrt(1 + m*m),
    u     = b / K,
    // enforce intersection domain for original line (offensive check)
    _ok0  = assert(abs(u) <= 1, "Original line has no circle intersection (|b| > K)."),
    Delta = delta_s / R,           // radians
    cosD  = cos(r2d(Delta)),
    sinD  = sin(r2d(Delta)),
    rad   = 1 - u*u,
    // Algebraic candidates for the required vertical shift relative to the SAME original line
    a_plus  = K * ( u*(cosD - 1) +  sqrt(rad)*sinD ),
    a_minus = K * ( u*(cosD - 1) -  sqrt(rad)*sinD ),
    // Keep only those that preserve a valid RIGHT-SIDE intersection after the shift
    p_up_cand   = _pick_right(_circle_line_intersections(R, m, b + a_plus)),
    p_down_cand = _pick_right(_circle_line_intersections(R, m, b + a_minus)),
    a_up_raw    = (p_up_cand   == undef) ? undef : a_plus,
    a_down_raw  = (p_down_cand == undef) ? undef : a_minus,
    // Enforce sign convention: up >= 0, down <= 0
    a_up   = (a_up_raw   == undef) ? undef : (a_up_raw   >= 0 ? a_up_raw   : undef),
    a_down = (a_down_raw == undef) ? undef : (a_down_raw <= 0 ? a_down_raw : undef)
  )
  [a_up, a_down]
;

////////////////////////////////////////////////////////////////////////////////

/**
 * Clamps a value between [lo, hi].
 *
 * @param v (number)
 *   Value to clamp.
 * @param lo (number)
 *   Lowest value v should take.
 * @param hi (number)
 *   Highest value v should take.
 *
 * @returns (number)
 *   Value v that is clamped between [lo, hi].
 */
function clamp(v, lo, hi) = v < lo ? lo : v > hi ? hi : v;

/**
 * @param a (Point2D)
 *   Starting point of vector
 * @param b (Point2D)
 *   Ending point of vector
 *
 * @returns (Array[Point2D])
 *   result[VI_VECTOR()] = direction of ab
 *   result[VI_LENGTH()] = length of ab
 *   result[VI_DIR()   ] = unit ab vector
 *   result[VI_NORMAL()] = normal unit vector of ab
 */
function vector_info(a, b) =
  let(
    edge_vec = b - a,                                 // direction and magnitude of a to b
    edge_len = norm(edge_vec),                        // length of ab
    edge_dir = edge_vec / edge_len,                   // unit ab vector
    normal = [-edge_dir[1], edge_dir[0], edge_dir[2]] // normal unit vector of ab
  ) [ edge_vec, edge_len, edge_dir, normal ]
;

// ### CONSTANTS ###

/** Index of direction of ab */
function VI_VECTOR() = 0;
/** Index of length of ab */
function VI_LENGTH() = 1;
/** Index of unit ab vector */
function VI_DIR()    = 2;
/** Index of normal unit vector of ab */
function VI_NORMAL() = 3;

/**
 * Checks the equality of two items.  If v1 and v2 are lists of the same length,
 * then check the equality of each element.  If each are numbers, then check to
 * see if they are both equal to each other within an error of epsilon.  All
 * other types are done using the == operator.
 *
 * @param v1 (any)
 *   First item to compare against.
 * @param v2 (any)
 *   Second item to compare against.
 * @param epsilon (number)
 *   The max error tolerated for a number.
 *
 * @returns (bool)
 *   True if the objects are equal within tolerance.  False otherwise.
 */
function equal(v1, v2, epsilon = 1e-6) =
  is_num(v1) && is_num(v2)
    ? abs(v1 - v2) <= epsilon
    : is_list(v1) && is_list(v2)
      ? len(v1) == len(v2)
        ? // VAGUE BENCHMARKING
          // 1. slightly slower than 2.  Perhaps call overhead?
          all(function(i) equal(v1[i], v2[i], epsilon), 0, len(v1)-1)
          
          // 2. significantly slower than 3 (twice as slow).
          // is_undef(find(function(i) !equal(v1[i], v2[i], epsilon), 0, len(v1)-1))

          // 3. fastest, but has no epsilon testing.
          // v1 == v2 
        : false
      : v1 == v2
;

/** Hoists function into variable ns to be able to pass as a lambda */
function function_equal() =
  function(v1, v2, epsilon = 1e-6)
    equal(v1, v2, epsilon)
;

/**
 * If v is undefined, then return the default value d.
 *
 * @param v (any)
 *   The value to test if defined.
 * @param d (any)
 *   The result to give if v is undefined.
 *
 * @returns (any)
 *   If v is defined, then return v, else d.
 */
function default(v, d) =
  is_undef(v) ? d : v
;

/**
 * Used to mark code as incomplete.
 */
function INCOMPLETE(x=undef) =
  assert(false, "This function is incomplete")
;

////////////////////////////////////////////////////////////////////////////////

/**
 * Create an arrow.  Primarily used for debugging.
 *
 * @param l (number)
 *   Length of arrow.
 * @param t (number)
 *   Thickness of arrowhead shaft.
 * @param c (list | string | undef)
 *   Same as color() module's first parameter. [r, g, b], [r, g, b, a],
 *   "color_name", "#hex_value".  If not defined, no colour is applied.
 * @param c (number)
 *   Same as color() module's optional second parameter.  Alpha value between
 *   [0, 1].
 */
module arrow(l, t=1, c, a) {
  if (is_undef(c)) {
    cylinder(h = l*0.75, r = t); // shaft
    translate([0, 0, l*0.75])
      cylinder(h = l*0.25, r1 = t * 1.5, r2 = 0); // head
  } else {
    assert(is_num(l));
    color(c, a) {
      cylinder(h = l*0.75, r = t); // shaft
      translate([0, 0, l*0.75])
        cylinder(h = l*0.25, r1 = t * 1.5, r2 = 0); // head
    }
  }
}

module axis(l, t=1) {
  rotate([0, 90, 0])
    arrow(l, t, "red");
  rotate([-90, 0, 0])
    arrow(l, t, "green");
  arrow(l, t, "blue");
}
