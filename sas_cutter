// 11. [sas_cutter](#file-sas_cutter)
//     - Creates a skin which is used as a cutting tool help to align two separate
//       parts together.
/**
 * ## sas_cutter
 *
 * ### How to Import
 *
 *     use <sas_cutter>
 *
 * ### Purpose
 *
 * Self Aligning Seam (SAS) cutters.  Each cutter generates a `skin` that is
 * used as a negative mold - subtract it from an existing edge so that two
 * separate parts will align easily together when assembled.
 *
 * > WARNING:
 * >
 * > The APIs for these are still a bit unstable as I think I can make them
 * > cleaner.  Feels like there's just too many parameters.
 *
 * ### Variants
 *
 * - `sas_cutter` - sinusoidal cutface with bumps that fit into indentations.
 * - `sas2_cutter` - overlapping tabs instead of bump/indentation pairs.
 * - `scs_cutter` - Self Connecting Seam cutter (incomplete).
 */
use <helpers>
include <helpers_consts>
use <skin>
use <base_algos>

/**
 * Self aligning seam cutter aligned along edge a → b, with sinusoidal cutface.
 *
 * @param {Point2D} a
 *   Starting point.
 * @param {Point2D} b
 *   Ending point.
 * @param {number} y_thickness
 *   Thickness along y-axis of cutter from cutface to handle.
 * @param {number} z_thickness
 *   Height of cutting tool (z-axis).
 * @param {number} lat_wave_segs
 *   Number of segments to break up the wave into.
 * @param {number} lat_wave_cycles
 *   Number of complete wave_cycles to apply along cutting edge.
 * @param {number} wave_amp
 *   Amplitude of the wave on cutting edge (peak-to-peak).
 * @param {number} [long_wave_segs=4]
 *   Number of segments to break up the wave into.
 * @param {number} [long_wave_cycles=0.5]
 *   Number of complete wave_cycles to apply perpendicular to the cutting edge.
 * @param {number} [cutedge_long_overflow=1e-4]
 *   Lengthens the cutter by this amount expanding from the centre.
 * @param {number} [cutedge_lat_overflow=1]
 *   Widens the cutter by this amount (rounded to the next segment length)
 *   expanding from the centre.
 * @param {number} [xy_phase_offset=90]
 *   Number of degrees that the x and the y waves are offset from each other.
 *
 * @returns {skin}
 */
function sas_cutter(a, b, y_thickness, z_thickness,
  lat_wave_segs, lat_wave_cycles, wave_amp,
  long_wave_segs = 4, long_wave_cycles = 0.5,
  cutedge_long_overflow = 1e-4, cutedge_lat_overflow = 1, xy_phase_offset = 90)
=
  let (
    edge = vector_info(a, b),
    // Physical spans
    L = edge[VI_LENGTH],
    H = z_thickness,
    extra_segments = round(cutedge_lat_overflow / (edge[VI_LENGTH]/lat_wave_segs) + 0.5)
  )
  echo(
    "cutedge_lat_overflow:", cutedge_lat_overflow,
    "seg_len", L / lat_wave_segs, norm(edge[VI_VECTOR] / lat_wave_segs),
    "extra_segments:", extra_segments,
    "lat_wave_segs:", lat_wave_segs,
    "lat_percent: ", 1/lat_wave_segs
  )
  skin_new(
    long_wave_segs + 1 + 2,            // # pts per layer
    lat_wave_segs + extra_segments * 2 // # of layers
    , [

    for (i = [0 - extra_segments : lat_wave_segs + extra_segments ])
      let (
        long_percent = i / lat_wave_segs, // % of segment traversed along the cutter length (x axis)
        X = long_percent * norm(a-b),
        // start point along line ab
        pt = //echo("long_percent", long_percent)
          a + edge[VI_VECTOR] * long_percent,
        handle   = pt + edge[VI_NORMAL] * y_thickness
      )
      each
      //          x            y                                  z
      [
        [handle  [0], handle  [1], -cutedge_long_overflow                   ] // handle bottom
        ,
        [handle  [0], handle  [1],  cutedge_long_overflow + z_thickness     ] // handle top
        ,
        for (j = [long_wave_segs : -1 : 0])
          let (
            lat_percent = j / long_wave_segs, // % of segment traversed along the edge height (z axis)
            Y = lat_percent * z_thickness,
            // Degrees per unit length (OpenSCAD trig uses degrees)
            kx_deg_per_len = 360 * lat_wave_cycles / L,   // cycles across length L
            ky_deg_per_len = 360 *  long_wave_cycles / H,   // cycles across height H

            // If wave_amp is peak-to-peak, use wave_amp/2 for amplitude
            amp = i < 0 || i > lat_wave_segs ? 0 : (wave_amp/2) * sin(kx_deg_per_len * X) * cos(ky_deg_per_len * Y + xy_phase_offset),
            cutter = [ pt[0], amp, z_thickness * lat_percent ]
          )
          // echo(str("cutter[", i, ", ", j , "] = ", lat_percent, ", ",360 * lat_wave_cycles * (lat_percent+.25)))
          // echo(str("cutter[", i, ", ", j , "] = ", cutter))
          cutter
      ]

    ]
  )
;

function _ignored(x) = x;

/**
 * Self aligning seam cutter 2 aligned along edge a → b, with sinusoidal cutface.
 *
 * Similar to sas, but uses overlapping tabs instead of bumps that fit into
 * indentations.
 *
 * TODO: a and b parameters are misleading.  They are only used for the length.
 *       Need to fix.
 *
 * @param {Point2D} a
 *   Starting point.
 * @param {Point2D} b
 *   Ending point.
 * @param {number} y_thickness
 *   Thickness of cutter along y-axis from lowest part of cutface to handle.
 * @param {number} z_thickness
 *   Height of cutting tool (z-axis).
 * @param {number} lat_wall_percent
 *   When transitioning from the each half cycle to the next point, and a
 *   point to each half cycle, this is % of a 1/4 cycle traveled along the
 *   latitude direction.  A value of 0 is a results in a "square wave".  A
 *   value of 1 would result in a "sawtooth wave".
 *
 *   Example:
 *   
 *                     latitude travel   Square wave           Sawtooth wave
 *             ___     |↔|__              ___     ___
 *            /   \    |/   \            |   |   |   |           /\  /\
 *            |    \___/     \___/|      |   |___|   |___       |  \/  \/|
 *            |___________________|      |_______________|      |________|
 * @param {number} lat_wave_cycles
 *   number of complete wave_cycles to apply along cutting edge.
 * @param {number} wave_amp
 *   amplitude of the wave on cutting edge (peak-to-peak).
 * @param {number} [long_wave_segs=*ignored*]
 *   number of segments to break up the wave into.
 * @param {number} [long_wave_cycles=*ignored*]
 *   number of complete wave_cycles to apply perpendicular to the cutting edge.
 * @param {number} [cutedge_long_overflow=1e-4]
 *   Lengthens the cutter by this amount expanding from the centre.
 * @param {number} [cutedge_lat_overflow=1]
 *   Widens the cutter by this amount (rounded to the next segment length)
 *   expanding from the centre.
 * @param {number} [x_phase_offset=0]
 *   The starting phase of the a point.  Value must be ∈ [0, 360).
 * @param {string} [comment]
 *   Comment assigned to the returned `skin`.
 *
 * @returns {skin}
 */
function sas2_cutter(a, b, y_thickness, z_thickness,
  lat_wall_percent, lat_wave_cycles, wave_amp,
  long_wave_segs = _ignored(4), long_wave_cycles = _ignored(0.5),
  cutedge_long_overflow = 1e-4, cutedge_lat_overflow = 1, x_phase_offset = 0, comment)
=
  let (
    edge = vector_info(a, b),
    // Physical spans
    L = edge[VI_LENGTH],
    H = z_thickness,
    lat_wavelength = L / lat_wave_cycles,
    max_seg_len = lat_wavelength / 4,
    extra_segments = round(cutedge_lat_overflow / max_seg_len + 0.5),
    lwt = 90 * lat_wall_percent, // lat wave traversal
    x_map = [0,      lwt,  180-lwt, 180,  180+lwt,   360-lwt] / 360 * lat_wavelength,
    y_map = [0, wave_amp, wave_amp, 0,  -wave_amp, -wave_amp],
    // mod operator is symmetric around 0.  Need it to be the same through 0,
    // so have to move x left one cycle while keeping i >= 0.
    _ = echo("po", (x_phase_offset%360 - 360)/360),
    x_offset = (x_phase_offset%360 - 360)/360 * lat_wavelength,
    cutter_tool =
      function(i)
        let (
                 x  =  x_map[i % len(x_map)] + lat_wavelength * floor(i / len(x_map)) + x_offset,
          cutter_y  = -y_map[i % len(y_map)],  // cutter edge, opposite from handle edge.
          handle_y0 = wave_amp,              // where handle meets cutter
          handle_y1 = wave_amp + y_thickness // handle edge, opposite from cutter edge.
        )
        //         handle_y1         handle_y0         cutter_y
        //         v                 v                 v
        //         +--------                             < H + cutedge_long_overflow
        //     z   +-----------------+-----------------+ < H
        //     ↑   |                 |        :        |
        //  y ←+   +-----------------+-----------------+ < 0
        //         +--------                  ^          < 0 - cutedge_long_overflow
        //                                    0 or centre line of cutter
        [
            // was seeing the cutter not cutting a itty bitty piece between 0
            // line and handle_y0, so I moved handle_y0 to 0 so that the cut
            // flair would envelop the piece.
            [ x, cutter_y == 0 ? 0 : handle_y0, H ]
          , [ x, cutter_y , H ]
          , [ x, cutter_y , 0 ]
          , [ x, cutter_y == 0 ? 0 : handle_y0, 0 ]
          , [ x, handle_y1,   - cutedge_long_overflow ]
          , [ x, handle_y1, H + cutedge_long_overflow ]
        ],
    segs = max(1, cutedge_lat_overflow / max_seg_len),
    seg_len = cutedge_lat_overflow / segs,
    cutter_excess = function(start, end)
      function(i)
        let (
          x = start + seg_len * i,
          cutter_y = -wave_amp,
          handle_y0 = wave_amp,              // where handle meets cutter
          handle_y1 = wave_amp + y_thickness
        )
        [
          [ x, handle_y0, H ],
          [ x, cutter_y,  H ],
          [ x, cutter_y,  0 ],
          [ x, handle_y0, 0 ],
          [ x, handle_y1, 0 - cutedge_long_overflow ],
          [ x, handle_y1, H + cutedge_long_overflow ]
        ],
    cutter = [
      skin_extrude(0, segs, comment = str(comment, " pre-overflow"))(cutter_excess(-cutedge_lat_overflow,  0))
      ,
      skin_extrude(0, len(x_map) * (lat_wave_cycles + 2), comment = comment)(cutter_tool)
      ,
      skin_extrude(0, segs, comment = str(comment, " post-overflow"))(cutter_excess(L, L+cutedge_lat_overflow))
    ]
    // T =
    // // identity(3)
    // reorient([[0,0,0], [L, 0, 0]], [a, b])
  )
  //it_each(cutter, map())(function(e) skin_transform(e, T))
  // skin_transform(cutter, T)
  cutter
;

translate([0,0,1])
skin_to_polyhedron(sas2_cutter([0, 0, 0], [10, 0, 0], 1, 1, .5, 10, .25, undef, undef, .2, .2,   0));
skin_to_polyhedron(sas2_cutter([0, 0, 0], [10, 0, 0], 1, 1, .5, 10, .25, undef, undef, .2, .2, 180));

/**
 * Self connecting seam cutter aligned along edge a → b, with sinusoidal cutface.
 * INCOMPLETE!
 *
 * @param {Point2D} a
 *   starting point.
 * @param {Point2D} b
 *   ending point.
 * @param {number} y_thickness
 *   y_thickness of cutter from cutface to handle.
 * @param {number} z_thickness
 *   Height of cutting tool (z-axis).
 * @param {number} lat_wave_segs
 *   number of segments to break up the wave into.
 * @param {number} lat_wave_cycles
 *   number of complete wave_cycles to apply along cutting edge.
 * @param {number} wave_amp
 *   amplitude of the wave on cutting edge (peak-to-peak).
 * @param {number} [long_wave_segs=4]
 *   number of segments to break up the wave into.
 * @param {number} [long_wave_cycles=0.5]
 *   number of complete wave_cycles to apply perpendicular to the cutting edge.
 * @param {number} [cutedge_long_overflow=1e-4]
 *   Lengthens the cutter by this amount expanding from the centre.
 * @param {number} [cutedge_lat_overflow=1]
 *   Widens the cutter by this amount (rounded to the next segment length)
 *   expanding from the centre.
 * @param {number} [xy_phase_offset=90]
 *   Number of degrees that the x and the y waves are offset from each other.
 *
 * @returns {skin}
 */
function scs_cutter(a, b, y_thickness, z_thickness,
  lat_wave_segs, lat_wave_cycles, wave_amp,
  long_wave_segs = 4, long_wave_cycles = 0.5,
  cutedge_long_overflow = 1e-4, cutedge_lat_overflow = 1, xy_phase_offset = 90)
=
  let (
    edge = vector_info(a, b),
    // Physical spans
    L = edge[VI_LENGTH],
    H = z_thickness,
    extra_segments = round(cutedge_lat_overflow / (edge[VI_LENGTH]/lat_wave_segs) + 0.5)
  )
  [ [ echo(
        "cutedge_lat_overflow:", cutedge_lat_overflow,
        "seg_len", L / lat_wave_segs, norm(edge[VI_VECTOR] / lat_wave_segs),
        "extra_segments:", extra_segments,
        "lat_wave_segs:", lat_wave_segs,
        "lat_percent: ", 1/lat_wave_segs
      )
      long_wave_segs + 1 + 2,              // # pts per layer
      lat_wave_segs + extra_segments * 2 // # of layers
    ], [

    for (i = [0 - extra_segments : lat_wave_segs + extra_segments ])
      let (
        long_percent = i / lat_wave_segs, // % of segment traversed along the cutter length (x axis)
        X = long_percent * norm(a-b),
        // start point along line ab
        pt = //echo("long_percent", long_percent)
          a + edge[VI_VECTOR] * long_percent,
        handle   = pt + edge[VI_NORMAL] * y_thickness
      )
      each
      //          x            y                                  z
      concat(
        [[handle  [0], handle  [1], -cutedge_long_overflow                   ]] // handle bottom
        ,
        [[handle  [0], handle  [1],  cutedge_long_overflow + z_thickness     ]], // handle top
        [
          for (j = [long_wave_segs : -1 : 0])
            let (
              lat_percent = j / long_wave_segs, // % of segment traversed along the edge height (z axis)
              Y = lat_percent * z_thickness,
              // Degrees per unit length (OpenSCAD trig uses degrees)
              kx_deg_per_len = 360 * lat_wave_cycles / L,   // cycles across length L
              ky_deg_per_len = 360 *  long_wave_cycles / H,   // cycles across height H

              // If wave_amp is peak-to-peak, use wave_amp/2 for amplitude
              amp = i < 0 || i > lat_wave_segs ? 0 : (wave_amp/2) * sin(kx_deg_per_len * X) * cos(ky_deg_per_len * Y + xy_phase_offset),
              cutter = [ pt[0], amp, z_thickness * lat_percent ]
            )
            // echo(str("cutter[", i, ", ", j , "] = ", lat_percent, ", ",360 * lat_wave_cycles * (lat_percent+.25)))
            // echo(str("cutter[", i, ", ", j , "] = ", cutter))
            cutter
        ]
      )

  ]];
