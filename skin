/**
 * ## skin
 *
 * ### How to Import
 *
 *     use <skin>
 *
 * ### Purpose
 *
 * The built in extrude module isn't powerful or flexible enough so this library
 * was made.  It creates a skin by making layers of polygons with the same
 * number of vertices and then skins them by putting faces between layers.
 *
 * ### Functions and Modules
 */
use <base_algos>
use <indexable>
use <helpers>
use <types>
include <types_consts>
use <range>
use <string>
use <color>
use <birlei>
use <param_check>
use <any_all>
/**
 * ### Design
 *
 * This requires keeping track of a bunch of data, which was put into a list.
 * These constants are used for indexing the [skin](#t-skin) object.
 *
 * ### `skin` Slot Related Constants
 */

/**
 * @typedef {MemberIndex} SkinEnum
 *
 * Enum used to dereference a [`skin`](#t-skin) type.
 */

/**
 * @type {ObjTypeId}
 *
 * Type identifier header for skin objects.
 */
_SKIN_ID           = "SKIN";

/**
 * @type {SkinEnum}
 *
 * Slot index for the number of points in a layer.
 */
_SKIN_PTS_IN_LAYER = 1;

/**
 * @type {SkinEnum}
 *
 * Slot index for the number of point layers minus 1.
 */
_SKIN_LAYERS       = 2;

/**
 * @type {SkinEnum}
 *
 * Slot index for the list of points.
 */
_SKIN_PTS          = 3;

/**
 * @type {SkinEnum}
 *
 * Slot index for the debug axes.
 */
_SKIN_DEBUG_AXES   = 4;

/**
 * @type {SkinEnum}
 *
 * Slot index for the comment string.
 */
_SKIN_COMMENT      = 5;

/**
 * @type {SkinEnum}
 *
 * Slot index for the operation (`[op, apply_to_next_count]`).
 */
_SKIN_OPERATION    = 6;

/**
 * @type {SkinEnum}
 *
 * Slot index for the wall diagonal info.
 */
_SKIN_WALL_DIAG    = 7;

/**
 * @type {SkinEnum}
 *
 * Slot index for the closed status
 */
_SKIN_CLOSED       = 8;

/**
 * @typedef {list} skin
 * @deref {SkinEnum}
 *
 * Represents a skin object.
 *
 * @slot {number} _SKIN_PTS_IN_LAYER
 *   Number of points in a layer.
 * @slot {number} _SKIN_LAYERS
 *   Number of layers-1.
 * @slot {list[Point3D,...]} _SKIN_PTS
 *   A list of points representing the skin object.  This is a flattened list of
 *   points in layer order.  Points are in clockwise order when looking towards
 *   the next layer.
 * @slot {...} _SKIN_DEBUG_AXES
 *   A set of points that gets transformed with the skin points.
 *
 *   > NOTE:
 *   >
 *   > Rendering is still under development.  **Untested**.
 * @slot {string} _SKIN_COMMENT
 *   A string to give meaning as to what this object represents.
 * @slot {...} _SKIN_OPERATION
 *   This is to allow operations between adjacent skin objects in a list.
 *
 *   > NOTE:
 *   >
 *   > Rendering is still under development.  **Untested**.
 * @slot {list[bool,...]} _SKIN_WALL_DIAG
 *   When skinning the side walls of the skin, there are two ways to skin a 4
 *   point polygon.  This allows controlling that by specifying the direction.
 *   The first polygon is rendered by what slot 0 states.  The second, by what
 *   slot 1 states.  This continues till the list slots are exhausted, at which
 *   point, it starts at slot 0 again.
 * @slot {bool} _SKIN_CLOSED
 *   If a skin is closed, it means that the last layer will join to the first
 *   layer and no end caps are generated.
 */

/**
 * Converts a skin object to a human readable string.
 *
 * @param {skin} obj
 *   This is the skin object to view.
 * @param {bool} only_first_and_last_layers
 *   Show only the first and last layers if true, otherwise all layers.
 * @param {number} precision
 *   The number of decimal places to show the layers.
 *
 * @returns {string}
 *   The string representation of the skin object.
 */
function skin_to_string(obj, only_first_and_last_layers = true, precision = 4) =
  let (
    names = [
      "ID", "PTS_IN_LAYER", "LAYERS", "PTS", "DEBUG_AXIS", "COMMENT",
      "OPERATION", "WALL_DIAG", "CLOSED"
    ],
    fmt_el_fn = function(i,e,indent)
      str(names[i], ": ",
        i == _SKIN_PTS
        ? pt_list_to_string(
          obj[_SKIN_PTS], obj[_SKIN_PTS_IN_LAYER], obj[_SKIN_LAYERS]+1,
            indent, only_first_and_last_layers, precision)
        : e)
  )
  echo("skin_to_string", type_structure(obj), obj)
  list_to_string(obj, 1, fmt_el_fn)
;

/**
 * Computes the index of a point in a layered point array.  This is like a 2D
 * coordinate map, where `pt_i` is the x-axis (limited by modulo `pts_in_layer`
 * so that it wraps) and `layer_i` is the y-axis.
 *
 * This allows to more easily visualise what points are being referenced,
 * relative to different layers.
 *
 * Assumes that points are stored consecutively per layer, and layers are
 * stacked consecutively in memory.
 *
 * @param {number} pts_in_layer
 *   Number of points in each layer.
 * @param {number} pt_i
 *   Index of the point on a layer (0-based).  If > pts_in_layer, then wraps
 *   back to 0.
 * @param {number} layer_i
 *   Index of the layer (0-based).
 *
 * @returns {number}
 *   The linear index of the specified point.
 */
function layer_pt(pts_in_layer, pt_i, layer_i)
  = (pt_i % pts_in_layer) + pts_in_layer * layer_i
;

/**
 * Computes a list of layer indices for multiple points in a layered point
 * array.
 *
 * This allows to more easily visualise what points are being referenced,
 * relative to different layers.
 *
 * Assumes points are stored consecutively per layer, with each layer laid out
 * sequentially.
 *
 * @param {number} pts_in_layer
 *   Number of points per layer.
 * @param {list[list[number, number]]} pt_offset_and_layer_list
 *   List of (point index, layer index) pairs.
 *
 * @returns {list[number,...]}
 *   A list of linear layer_i corresponding to the given points.
 */
function layer_pts(pts_in_layer, pt_offset_and_layer_list)
  = [
      for (pt_offset_and_layer = pt_offset_and_layer_list)
        layer_pt(pts_in_layer, pt_offset_and_layer[0], pt_offset_and_layer[1])
    ];

/**
 * @typedef {list} Face
 *
 * @slot {number} 0
 *   This is the first index to the point in the referenced point list.
 * @slot {number} 1
 *   This is the second index to the point in the referenced point list.
 * @slot {number} 2
 *   This is the third index to the point in the referenced point list.
 */

/**
 * Helper to generate side wall faces between consecutive layers.
 *
 * Assumes the points are arranged in a flat list, with each layer's points
 * stored contiguously, and layers stored in sequence. Points within each
 * layer must be ordered **clockwise when looking into the object**.
 *
 * Each wall segment is formed from two triangles connecting corresponding
 * points between adjacent layers.  Each triangle is a [`Face`](#t-Face).
 *
 * @param {number} pts_in_layer
 *   Number of points per layer.
 * @param {number} layers
 *   Number of vertical wall segments to generate (requires one more point
 *   layer).
 * @param {list[bool,...]} [wall_diagonal=[0,1]]
 *   This is used to allow changing the diagonal of neighbouring square polygons
 *   on a layer.
 *
 *   E.g.
 *
 *   - `[1]` will have all diagonals go one way.
 *   - `[1,0]` will alternate.
 *   - `[0,1]` will alternate the opposite way to `[1,0]`.
 *   - `[0,0,1]` will have it go one way for 2 consecutive 4 point face, and
 *     then the other way, and then repeat.
 * @param {bool} close
 *   If true, then the last layer connects to the first layer.
 *
 * @returns {list[Face]}
 *   A list of triangle layer_i forming the side walls.
 */
function layer_side_faces(pts_in_layer, layers = 1, wall_diagonal = [0, 1], close)
  = assert(is_list(wall_diagonal))
    [ for (layer = [0: layers-1])
        each _layer_side_faces(pts_in_layer, wall_diagonal, layer, layer+1),
      if (close)
        each _layer_side_faces(pts_in_layer, wall_diagonal, layers, 0)
    ]
;

function _layer_side_faces(pts_in_layer, wall_diagonal, layer0, layer1) =
  [
    for (i = [0:pts_in_layer-1]) // i is the point index in the layer0
      each let(
        which_diag_index = (i + pts_in_layer * layer0) % len(wall_diagonal)
      )
      wall_diagonal[which_diag_index]
      ? [
        layer_pts(pts_in_layer, [[i, layer0], [i,   layer1], [i+1, layer1]]),
        layer_pts(pts_in_layer, [[i, layer0], [i+1, layer1], [i+1, layer0]])
      ]
      : [
        layer_pts(pts_in_layer, [[i, layer1], [i+1, layer1], [i+1, layer0]]),
        layer_pts(pts_in_layer, [[i, layer1], [i+1, layer0], [i  , layer0]])
      ]
  ]
;

/**
 * @type {function}
 *
 * Given a set of points and an index, returns a face if `pts[pt_is[i..i+2]]`
 * are convex, or undef if concave or colinear.
 *
 * This is for clockwise polygons when looking towards -z.
 *
 * @param {list[Point2D,...]} pts
 *   A list of 2D points
 * @param {number} pt_i0
 *   Index into the `pts` list.
 * @param {number} pt_i1
 *   Index into the `pts` list.
 * @param {number} pt_i2
 *   Index into the `pts` list.
 * @param {number} eps
 *   Biggest abs value to consider as 0.
 *
 * @returns {(Face|undef)}
 *   Face if convex, or undef if concave or colinear.
 */
_ear_cw = function(pts, pt_i0, pt_i1, pt_i2, eps = 1e-6)
  let ( _ = verify_vpi(pts, pt_i0) )
  let ( _ = verify_vpi(pts, pt_i1) )
  let ( _ = verify_vpi(pts, pt_i2) )
  let ( _ = verify_vpos(eps) )
  let(
    pt0 = pts[pt_i0],
    pt1 = pts[pt_i1],
    pt2 = pts[pt_i2],
    a = pt1 - pt0,
    b = pt2 - pt1,
    cross_z = a[0] * b[1] - a[1] * b[0]
  )
  // echo(str("_ear_cw: cross_z: ", cross_z))
  abs(cross_z) <= eps ? undef                 // COLINEAR
  : cross_z < 0       ? [pt_i2, pt_i1, pt_i0] // CONVEX
                      : undef                 // CONCAVE
;

/**
 * @type {function}
 *
 * Given a set of points and an index, returns a face if `pts[pt_is[i..i+2]]`
 * are convex, or undef if concave or colinear.
 *
 * This is for counter-clockwise polygons when looking towards -z.
 *
 * @param {list[Point2D,...]} pts
 *   A list of 2D points
 * @param {number} pt_i0
 *   Index into the `pts` list.
 * @param {number} pt_i1
 *   Index into the `pts` list.
 * @param {number} pt_i2
 *   Index into the `pts` list.
 * @param {number} eps
 *   Biggest abs value to consider as 0.
 *
 * @returns {(Face|undef)}
 *   Face if convex, or undef if concave or colinear.
 */
_ear_ccw = function(pts, pt_i0, pt_i1, pt_i2, eps = 1e-6)
  let ( _ = verify_vpi(pts, pt_i0) )
  let ( _ = verify_vpi(pts, pt_i1) )
  let ( _ = verify_vpi(pts, pt_i2) )
  let ( _ = verify_vpos(eps) )
  let(
    pt0 = pts[pt_i0],
    pt1 = pts[pt_i1],
    pt2 = pts[pt_i2],
    a = pt1 - pt0,
    b = pt2 - pt1,
    cross_z = a[0] * b[1] - a[1] * b[0]
  )
  // echo(str("_ear_ccw: cross_z: ", cross_z))
  abs(cross_z) <= eps ? undef                 // COLINEAR
  : cross_z > 0       ? [pt_i0, pt_i1, pt_i2] // CONVEX
                      : undef                 // CONCAVE
;

/**
 * Determines if `pt` is in triangle `(pt0, pt1, pt2)`. `_*` parameters are
 * cached values.
 */
function _pt_in_triangle(pt, pt0, pt1, pt2, _v0, _v1, _v2, _cross_1020, eps = 1e-6) =
  let (
    p0 = pt  - pt0,
    p1 = pt  - pt1,
    p2 = pt  - pt2,
    s0 = cross(_v0, p0),
    s1 = cross(_v1, p1),
    s2 = cross(_v2, p2)
  )
  _cross_1020 > 0 && s0 >= -eps && s1 >= -eps && s2 >= -eps ||
  _cross_1020 < 0 && s0 <=  eps && s1 <=  eps && s2 <=  eps
;

/**
 * Checks if any point indexed by pt_is that is not `pt_i{0, 1, 2}` is inclusively
 * bounded by the triangle `pts[pt_is[pt_i{0, 1, 2}]]`.
 */
function _any_point_in_ear(pts, pt_is, pt_i0, pt_i1, pt_i2, eps = 1e-6) =
  let (
    pts_i0 = pt_is[pt_i0],
    pts_i1 = pt_is[pt_i1],
    pts_i2 = pt_is[pt_i2],
    pt0 = pts[pts_i0],
    pt1 = pts[pts_i1],
    pt2 = pts[pts_i2],
    v0 = pt1 - pt0,
    v1 = pt2 - pt1,
    v2 = pt0 - pt2,
    cross_1020 = cross(v0, -v2)
  )
  any(pt_is)(function(i)
    i == pts_i0 || i == pts_i1 || i == pts_i2
    ? false
    : _pt_in_triangle(pts[i], pt0, pt1, pt2, v0, v1, v2, cross_1020, eps)
  )
;

/**
 * Caps the end of a face by making all ears into faces until none left.
 *
 * Parameters starting with _ will not be set by the external caller.
 *
 * @param {list[Point3D,...]} pts
 *   Points that `pt_is` references.
 * @param {list[number,...]} pt_is
 *   Point indices to dereference `pts` with.
 * @param {(function(pts, pt_i0, pt_i1, pt_i2, eps = 1e-6): (list[number]|undef))} create_ear_fn
 *   Callback that when given the set of point indices, return a new face or
 *   undef if not an ear.
 * @param {number} _i
 *   Where to start traversing polygon for ear clipping.
 * @param {list[Face,...]} _faces
 *   Faces.
 * @param {bool} _removed_at_least_one_ear
 *   States if at least one ear has been removed after one complete cycle of cap
 *   points.
 *
 * @returns {list[Face,...]}
 *   Faces
 */
function _cap_ears(pts, pt_is, create_ear_fn, _i = 0, _faces = [], _removed_at_least_one_ear = false) =
  assert(                   len(pt_is) >= 3,          "Invalid number of vertices.")
  // echo("pt_is: ", pt_is)
  let (
    pt_i0 =                _i    ,
    pt_i1 = next_in(pt_is, _i, 1),
    pt_i2 = next_in(pt_is, _i, 2),
    ear    = create_ear_fn(pts, pt_is[pt_i0], pt_is[pt_i1], pt_is[pt_i2])
  )
  len(pt_is) == 3
  ? // last ear
    assert(is_list(ear), str("Last set of points are not convex. ", ear))
    push(_faces, [ear])
  : is_list(ear) && !_any_point_in_ear(pts, pt_is, pt_i0, pt_i1, pt_i2)
    ? pt_i1
      ? _cap_ears(pts, remove(pt_is, pt_i1, pt_i1), create_ear_fn,      _i , push(_faces, [ear]), true)
      : _cap_ears(pts, remove(pt_is, pt_i1, pt_i1), create_ear_fn, -1 + _i , push(_faces, [ear]), false)
    : // didn't find ear, go to next index
      let (
        _ = Assert(
          pt_i1 || _removed_at_least_one_ear,
          function()
            str("Didn't remove ear after complete cycle of cap points.  ",
              let (
                mapped_pts = it_each(pts, map(), pt_is)(function(pt) pt)
              )
              mapped_pts
            )
        )
      )
      _cap_ears  (pts,        pt_is               , create_ear_fn,   pt_i1,       _faces        , pt_i1 && _removed_at_least_one_ear)
;

/**
 * Project all points to an axis by removing `dim_i` and possibly swapping
 * coordinates.  This is done to simplify calculations.
 *
 * @param {list[Point3D,...]} pts
 *   Points to have projected.
 * @param {number} dim_i
 *   Axis to have project along (have set to 0).  0 = x, 1 = y, 2 = z.
 *
 * @returns {list[Point2D,...]}
 *   Returns points with the specified dimension removed.
 */
function _proj_pts(pts, dim_i) =
  // echo(str("Removing axis ", dim_i, " from pts ", pts))
  dim_i == 1
  ? [
      for (pt = pts) [ pt.z, pt.x ]
    ]
  : dim_i == 0
    ? [
        for (pt = pts) [ pt.y, pt.z ]
      ]
    : [
        for (pt = pts) [ pt.x, pt.y ]
      ]
;

/**
 * Determine which projection give the largest normal vector.
 *
 * @param {list[Point3D,...]} pts
 *   A list of points.  Must have at least 3 points.
 * @param {number} dim_i
 *   Dimension index currently checking.
 * @param {number} _n
 *   Current best normal found so far.
 * @param {number} _n_len
 *   Length of the current best normal found so far.
 * @param {number} _dim_i
 *   Current best projection axis so far.
 *
 * @returns {list[number, Point3D]}
 *   The best projection axis with it's corresponding best normal.
 */
function _proj_to_what_norm(pts, dim_i = 0, _n = 0, _n_len = 0, _dim_i = -1) =
  assert(len(pts) >= 3)
  dim_i == 3
  ? [ _dim_i, _n ]
  : let (
      _pts = _proj_pts(pts, dim_i),
      normals = [
        for (i = fwd_i(pts))
          let (
            pt0 = _pts[             i    ],
            pt1 = _pts[next_in(pts, i, 1)],
            pt2 = _pts[next_in(pts, i, 2)],
            p0 = pt0,
            e1 = pt1 - p0,
            e2 = pt2 - p0,
            n = cross(e1, e2)
          )
          // echo(str("(", i, ", ", dim_i, ", ", n, ") ", [pt0, pt1, pt2]))
          n
      ],
      n = it_each(normals, reduce(normals[0]), 1)(
        function(n, acc)
          abs(n) > abs(acc) ? n : acc
      ),
      n_len = abs(n)
    )
    _n_len > n_len
    ? _proj_to_what_norm(pts, dim_i+1, _n, _n_len, _dim_i)
    : _proj_to_what_norm(pts, dim_i+1,  n,  n_len,  dim_i)
;

/**
 * Caps a layer of points.
 *
 * @param {list[Point3D,...]} pts
 *   List of points in layer.
 * @param {list[number,...]} pt_is
 *   List of indices used to dereference `pts`.
 *
 * @returns {list[Face,...]}
 *   List of faces.
 */
function _cap_layer(pts, pt_is) =
  // echo(str("_cap_layer(", pts, ", ", pt_is, ")"))
  let (
    // removing duplicate consecutive points from pt_is
    pt_is = remove_adjacent_dups(pt_is, true)(
      function(a, b) pts[a] == pts[b]
    )
  )
  len(pt_is) < 3
  ? []
  : let(
      proj_info = _proj_to_what_norm(pts),
      proj_axis = proj_info[0],
      cw = proj_info[1] < 0,
      proj_pts = _proj_pts(pts, proj_axis)
    )
    // echo(str("pt_is: ", pt_is))
    // echo(str("Removed axis ", proj_info[0]))
    _cap_ears(proj_pts, pt_is, cw ? _ear_cw : _ear_ccw)
;

/**
 * Generates triangulated faces to cap the first and last point layers.
 *
 * Assumes `pts3d` is a flat list of points arranged in contiguous layers,
 * each containing `pts_in_layer` points. There must be `layers + 1` total
 * point layers. The polygon formed by each cap must be planar and ordered
 * clockwise when looking from the start layer towards the next layer.  Each
 * layer of points are all coplanar to the other points in that layer.
 *
 * This algorithm uses ear clipping to allow for non-convex polygons to be
 * capped.
 *
 * @param {number} pts_in_layer
 *   Number of points in a layer.
 * @param {list[Point3D,...]} pts3d
 *   Points for all layers.
 * @param {number} layers
 *   Number of layers - 1.
 *
 * @returns {list[Face,...]}
 *   Generated faces.
 */
function _cap_layers(pts_in_layer, pts3d, layers) =
  let (
    pt_is = [ each range(0, pts_in_layer-1) ],
    last_layer_pt = layers*pts_in_layer,

    front_pts = els(pts3d, 0, pts_in_layer-1),
    front_faces = _cap_layer(front_pts, pt_is),

    back_pts = els(pts3d, last_layer_pt, last_layer_pt + pts_in_layer-1),
    back_faces = it_each(_cap_layer(back_pts, pt_is), map())(
      function(e) [e[2]+last_layer_pt, e[1]+last_layer_pt, e[0]+last_layer_pt]
    )
  )
  [
    each front_faces,
    each back_faces
  ]
;

function filter_out_degenerate_triangles(pts3d, triangles) =
  it_each(triangles, filter())(
    function(tri, v)
      v ? tri :
      let (
        p0 = pts3d[tri[0]], p1 = pts3d[tri[1]], p2 = pts3d[tri[2]]
        , v1 = p0 - p1, v2 = p2 - p1
        // Not a degenerate triangle if all points are different and
        // two vectors are not colinear.  If any 2 or 3 points are same in
        // triangle, then cross product of vectors will act as if colinear.
        // cross(v1, v2) != [0,0,0]
        // !equal(cross(v1, v2), [0,0,0])
        // p0 != p1 && p1 != p2 && p2 != p0
        , result =
          assert(is_list(v1) && len(v1) == 3, type_value(v1))
          assert(is_list(v2) && len(v2) == 3, type_value(v2))
          !equal(cross(v1, v2), [0,0,0])
      )
      result
      // ? result
      // : echo("degenerate found: ", [p0, p1, p2]) result
  )
;

/**
 * Checks to see if object is a skin object
 */
function is_skin(obj) = is_list(obj) && obj[0] == _SKIN_ID;

/**
 * Create a new skin object.
 *
 * @param {number} pt_count_per_layer
 *   number of points per layer (must be â‰¥ 3)
 * @param {number} layers
 *   Number of wall segments (requires `layers + 1` total point layers).
 * @param {list[Point3D,...]} pts3d
 *   The full list of points arranged in stacked layers.
 * @param {string} comment
 *   Usually a string, this is just a comment for reading and debugging purposes.
 * @param {string} operation
 *   This is used by skin_to_polyhedron() when passing a list of skins.
 *   If a skin has an operation attached, then that skin will have
 *   the operation specified applied to the next element in the list which can
 *   be an object or list of objects.
 * @param {list[bool,...]} wall_diagonal
 *   This is used to allow changing the diagonal of neighbouring square polygons
 *   on a layer.
 *
 *   E.g.
 *
 *   - `[1]` will have all diagonals go one way.
 *   - `[1,0]` will alternate.
 *   - `[0,1]` will alternate the opposite way to `[1,0]`.
 *   - `[0,0,1]` will have it go one way for 2 consecutive 4 point face, and
 *     then the other way, and then repeat.
 * @param {list[list[Point3D,...],...]} debug_axes
 *   This is a list of point groups.  When rendering, arrows will be drawn from
 *   the first point to each succeeding point in list.  When debugging, call
 *   skin_show_debug_axis().
 *
 *   > WARNING:
 *   >
 *   > INCOMPLETE and UNTESTED.
 *
 * @returns {skin}
 */
function skin_new(pt_count_per_layer, layers, pts3d, comment, operation, wall_diagonal, debug_axes, closed) =
  [ _SKIN_ID, pt_count_per_layer, layers, pts3d, debug_axes, comment, operation, wall_diagonal, closed ]
;

/**
 * @callback SkinExtrude
 *
 * @param {function(i: number) list_of_points} pts_fn
 *   Function that returns a list of points for layer i.  It's fine to have
 *   duplicate points in list as degenerate triangles will be filtered when
 *   calling skin_to_polyhedron.
 *
 *   > NOTE:
 *   >
 *   > Points **MUST** wind in clockwise order when looking into object from
 *   > starting layer towards next layer.
 *   >
 *   > Non-coplanar points on a layer may result in **UB**. Especially on end caps.
 *
 * @returns {skin}
 *   The skin object.
 */

/**
 * @callchain skin_extrude(birl, end_i, comment, operation, wall_diagonal, debug_axes) (pts_fn) : skin
 *
 * Generates an extruded point list from a number range, range or list of
 * indices.
 *
 * @param {(number|range|list)} birl
 *   - If number, start index to check
 *   - If range, indices to check
 *   - If list, indices to check
 * @param {(number|undef)} end_i
 *   - If birl is a number, then end index to check.  end_i
 *     could be less than birl if there's nothing to iterate
 *     over.
 * @param {string} comment
 *   Usually a string, this is just a comment for reading and debugging purposes.
 * @param {string} operation
 *   This is used by skin_to_polyhedron() when passing a list of skins.
 *   If a skin has an operation attached, then that skin will have
 *   the operation specified applied to the next element in the list which can
 *   be an object or list of objects.
 * @param {list[bool,...]} wall_diagonal
 *   This is used to allow changing the diagonal of neighbouring square polygons
 *   on a layer.
 *
 *   E.g.
 *
 *   - `[1]` will have all diagonals go one way.
 *   - `[1,0]` will alternate.
 *   - `[0,1]` will alternate the opposite way to `[1,0]`.
 *   - `[0,0,1]` will have it go one way for 2 consecutive 4 point face, and
 *     then the other way, and then repeat.
 * @param {list[list[Point3D,...],...]} debug_axes
 *   This is a list of point groups.  When rendering, arrows will be drawn from
 *   the first point to each succeeding point in list.  When debugging, call
 *   skin_show_debug_axis().
 *
 *   > WARNING:
 *   >
 *   > INCOMPLETE and UNTESTED.
 *
 * @returns {SkinExtrude}
 *   Lambda that takes a function that returns one layer of points.
 */
function skin_extrude(birl, end_i, comment, operation, wall_diagonal, debug_axes, closed) =
    is_undef(birl)
    ? function(birl, end_i)
        skin_extrude(birl, end_i, comment, operation, wall_diagonal, debug_axes, closed)
    : function(pts_fn)
        let ( _ = verify_birlei(birl, end_i) )
        let (
          layer_is = birlei_to_indices(birl, end_i),
          layer_0 = pts_fn(el(layer_is, 0)),
          pts_in_layer = len(layer_0),
          layer_count = slr_len(layer_is)
        )
        echo("birlei = ", birl, end_i, layer_is)
        echo("layer_count", layer_count)
        let ( layer_is = els(layer_is, 1, slr_len(layer_is)-1) )
        echo("layer_is", layer_is)
        assert(layer_count > 1, "Need 2 or more layers to make a volume.")
        skin_new(pts_in_layer, layer_count - 1,
          [
            each layer_0,
            // Which is better?  each before or after for?
            // each for (i = layer_is)
            //   pts_fn(i)
            for (i = layer_is)
              each pts_fn(i)
          ], comment, operation, wall_diagonal, debug_axes, closed
        )
;

/**
 * Generates face layer_i to skin a layered structure, including:
 *
 * - bottom cap (layer 0)
 * - top cap (layer = layers)
 * - side wall faces between adjacent layers
 *
 * Assumes that points are stored in a flat array, with `pts_in_layer`
 * points per layer, and layers stored consecutively. Points within each
 * layer must be ordered clockwise when looking into the object.
 *
 * @param {skin} skin
 *   The skin object generating the faces from.
 *
 * @returns {list[Face]}
 *   A list of triangle face definitions.
 */
function skin_create_faces(skin) =
  assert(is_skin(skin))
  let (
    wall_diagonal = default(skin[_SKIN_WALL_DIAG], [0, 1]),
    pts_in_layer = skin[_SKIN_PTS_IN_LAYER],
    layers = skin[_SKIN_LAYERS],
    pts3d = skin[_SKIN_PTS],
    close = skin[_SKIN_CLOSED]
  )
  [
    if (!close)
      each _cap_layers(pts_in_layer,
        //echo("pts3d skin: ", pts3d)
        pts3d, layers)
    ,
    each filter_out_degenerate_triangles(
      pts3d,
      layer_side_faces(pts_in_layer, layers, wall_diagonal, close))
  ]
;

/**
 * Performs a transformation on the points stored in the skin object.
 *
 * @param {skin} obj_or_objs
 *   The skin object where the points are coming from to transform.
 *   TODO: Update doc to state `list[skin]`
 * @param {(Matrix3x3|Matrix4x4|function(pt: Point3D): Point3D)} matrix_or_fn
 *   The matrix or function to do the transformation with.  If the
 *   transformation is homogenous, then will convert the points to a homogeneous
 *   basis, perform the transformation and then remove the basis.
 *
 * @returns {skin}
 *   A new skin object with the points transformed.
 */
function skin_transform(obj_or_objs, matrix_or_fn) =
  is_skin(obj_or_objs)
  ? let (
      pts = obj_or_objs[_SKIN_PTS],
      dbg_pts = obj_or_objs[_SKIN_DEBUG_AXES],
      _ = assert(is_list(pts), str("pts (", pts, ") is not a list\n", obj_or_objs))
    )
    replace(obj_or_objs, _SKIN_PTS, _SKIN_DEBUG_AXES, [
      transform(pts, matrix_or_fn),
      is_undef(dbg_pts) ? undef : transform(dbg_pts, matrix_or_fn)
    ])
  : [ for (obj = obj_or_objs) skin_transform(obj, matrix_or_fn) ]
;

/**
 * Takes the skin object and make it into a polyhedron.  If obj is a list, will
 * assume all are skin objects and attempt to skin them all.
 *
 * @param {(skin|list[skin,...])} obj_or_objs
 *   The skin object or list of skin objects to make into a polyhedron.
 */
module skin_to_polyhedron(obj_or_objs) {
  // base case
  if (is_skin(obj_or_objs)) {
    obj = obj_or_objs;
    pts = obj[_SKIN_PTS];
    faces = skin_create_faces(obj);
    polyhedron(pts, faces);
  } else {
    assert(is_list(obj_or_objs),
      str(
        "If obj_or_objs is not a skin, then it must be a list of skins.",
        "\n", obj_or_objs));
    objs = obj_or_objs;

    // Collect all indices that don't have an operation or is the 0th index.
    // Prevents the need to recurse just to iterate over list of skins.
    is = filter(0, len(objs)-1)(function(i)
        // filter out any index that does have an operation in the previous index.
        i == 0 || !is_skin(objs[i-1]) || objs[i-1][_SKIN_OPERATION] == undef);

    for (i = is) {
      obj = objs[i];
      if (is_skin(obj)) {
        op = obj[_SKIN_OPERATION];
        pts = obj[_SKIN_PTS];
        faces = skin_create_faces(obj);
        if (is_undef(op)) {
            polyhedron(pts, faces);
        } else if (op == "difference") {
          difference() {
            polyhedron(pts, faces);
            skin_to_polyhedron(objs[i+1]);
          }
        } else if (op == "union") {
          union() {
            polyhedron(pts, faces);
            skin_to_polyhedron(objs[i+1]);
          }
        } else if (op == "intersection") {
          intersection() {
            polyhedron(pts, faces);
            skin_to_polyhedron(objs[i+1]);
          }
        } else {
          assert(false, str("Unrecognised operator \"", op, "\"."));
        }
      } else {
        skin_to_polyhedron(obj);
      }
    }
  }
}

/**
 * Adds a number of interpolated layers between layers based how many
 * add_layers_fn(i) returns.
 *
 * @param {skin} obj
 *   Object to add to.
 * @param {function(i: number): number} add_layers_fn
 *   Callback that will return the first index of a layer, expecting that the
 *   point it refers to or its brethren on that layer to be compared to the
 *   points on the very next layer.
 *
 *   It is guaranteed that there is a next layer of points to compare with.
 *
 *   `i` is the first index of the layer to be analyzed and will return the
 *   number of additional layers to add between the current layer and the next.
 *   Negative numbers are treated as 0.
 *
 *   E.g.
 *
 *   - 0 or less means add no additional layers.
 *   - 1 means add another layer that is half way in between the current and
 *     next layer.
 *   - 2 means add 2 layers, 1/3 and 2/3 between.
 *   - etc...
 *
 * @returns {skin}
 *   Updated skin.
 */
function skin_add_layer_if(obj, add_layers_fn) =
  let (
    pts = obj[_SKIN_PTS],
    pts_in_layer = obj[_SKIN_PTS_IN_LAYER],

    new_pts =
      reduce(
        tail_multi(pts, pts_in_layer),
        range(pts_in_layer, pts_in_layer, len(pts) - pts_in_layer))
      (
        function(i, acc)
          let (
            prev_i = i - pts_in_layer,
            num_of_layers_to_add = add_layers_fn(prev_i),
            layer_pts = els(pts, prev_i, i - 1)
          )
          num_of_layers_to_add > 0
          ? [
              each acc,
              each layer_pts,
              // concat doesn't have the ability to take a list of a list of
              // points and make it into a list of points, without creating a
              // function to do so.  This is just easier (and possibly faster).
              each each interpolated_values(
                layer_pts, els(pts, i, i+pts_in_layer-1), num_of_layers_to_add)
            ]
          : concat(
              acc,
              layer_pts
            )
      )
    ,
    //  _ = len(new_pts) != len(pts)
    //     ? echo(str("Added ", (len(new_pts) - len(pts))/pts_in_layer, " layers",
    //       obj[_SKIN_COMMENT] == undef ? "" : str(" to ", obj[_SKIN_COMMENT])))
    //     : undef,

    result = replace(obj, _SKIN_LAYERS, _SKIN_PTS, [ len(new_pts)/pts_in_layer-1, new_pts ]),
    added_layer_count = result[_SKIN_LAYERS] - obj[_SKIN_LAYERS]
  )
  assert(added_layer_count >= 0, str("Lost ", -added_layer_count, " layers."))
  // echo("layers", added_layer_count)
  // echo(skin_verify(result, true))
  result
;

/**
 * TODO: Look into this. Not sure what I was attempting here.
 */
function skin_add_point_in_layer(obj, add_pts_after_pt_numbers) =
  let (
    pts = obj[_SKIN_PTS],
    pts_in_layer = obj[_SKIN_PTS_IN_LAYER],
    pt_ranges = [ [0], each add_pts_after_pt_numbers ]
  )
  // iterate over each layer
  reduce([], range(0, pts_in_layer, len(pts)-pts_in_layer))(
      function(i0, acc)
        // iterate each point in layer
        reduce(acc, range(1, len(pt_ranges)-1))(
          function(pt_i, acc2)
            let (
              p0_i = i + pt_ranges[pt_i-1][0],
              p1_i = i + pt_ranges[pt_i  ][0], p1 = pts[p1_i],
              p2_i = i + pt_ranges[pt_i  ][0], p2 = pts[p2_i],
              pt_count_to_insert = pt_ranges[pt_i][1]
            )
            concat(
              acc2,
              els(pts, p0_i, p1_i),
              interpolated_values(p1, p2, pt_count_to_insert)
            )
        )
    )
;

/**
 * @typedef {list} DebugStyle
 *
 * Style for a debug vector.
 *
 * @slot {Color} 0
 * @slot {number} 1
 *   Alpha value between `[0, 1]`.
 *
 *   > TODO:
 *   >
 *   > Need to verify if undef is allowed, otherwise this will always take
 *   > precedence, even if alpha is specified in the ColorLst or ColorStr
 *   > style specifications.
 * @slot {number} 2
 *   Thickness that is passed to [`arrow()`](#m-arrow) module.
 */

/**
 * UNTESTED!
 * Shows the debug axes to verify where you think things should be.
 *
 * @param {skin} obj
 *   Object to show debug axes for.
 * @param {list[DebugStyle]} styles
 *   Contains a list of styles that are reused when the number of points in a
 *   debug group exceeds the number of styles.
 *
 *   If a style doesn't contain a colour, alpha or thickness (set as undef),
 *   will go backwards to find one that does and uses that.
 */
module skin_show_debug_axes(obj, styles = [["red", 1, .1], ["green"], ["blue"]])
{
  assert(is_skin(obj));
  dbg_pt_grps = obj[_SKIN_DEBUG_AXES];
  assert(dbg_pt_grps != undef, "No debug axes to show.");
  for (pt_grp = dbg_pt_grps) {
    ref_pt = pt_grp[0]; // starting point
    for (pt_i = fwd_i(pt_grp, 1)) { // iterate over ending points
      v = pt_grp[pt_i] - ref_pt;
      angle = arc_len([0, 0, 1], v, 180/PI);
      normal = cross([0, 0, 1], v);
      length = norm(v);
      T = translate(axis_obj[0]) * homogenise_transform(rotate(angle, normal));

      init = is_undef(styles) ? undef : styles[ pt_i % len(styles) ];
      if (is_undef(init)) {

        pred = function(a)
          any(function(i) a[i] == undef, 0, 2);

        data = pred(init)
          ? it_each(styles, reduce_air(init))(
              function(e, acc)
                [ pred(acc), [ for (i = [0:2]) default(acc[i], e) ] ],
              range(pt_i % len(styles), -1, 0))[1]
          : init;

        color_value = data[0];
        alpha     = data[1];
        thickness = default(data[2], length * 0.1);

        if (is_undef(color_value)) {
          multmatrix(T)
          axis(length, thickness);
        } else {
          color(color_value, alpha)
            multmatrix(T)
            axis(length, thickness);
        }
      } else {
        thickness = length * 0.1;
        multmatrix(T)
          axis(length, thickness);
      }
    }
  }
}

/**
 * Interpolates value between v0 and v1.
 *
 * > TODO:
 * >
 * > This function should be ***deprecated*** and should be replaced with
 * > [`interpolated_values()`](#f-interpolated_values).
 */
function interpolate(v0, v1, v) =
  (v - v0[0]) / (v1[0] - v0[0]) * (v1[1] - v0[1]) + v0[1]
;

/**
 * INCOMPLETE!
 * Truncates the beginning, end or both of the extrusion.
 *
 * @param {skin} obj
 *   Object to remove values before in points.  Value extracted from points MUST
 *   BE monotonically nondecreasing over the points list.
 * @param {function(pt: Point3D): extracted_value} extract_order_value_fn
 *   This take in a point and returns some value.  This is to allow selection of
 *   a particular axis or length for a given point to compare against value.
 * @param {number} [begin=extract_order_value_fn(el(obj[_SKIN_PTS],  0))]
 *   The value to compare against the extracted value from a point.
 * @param {number} [end=extract_order_value_fn(el(obj[_SKIN_PTS], -1))]
 *   The value to compare against the extracted value from a point.
 *
 * @returns {skin}
 *   Updated skin object with all of the points before value removed.  If
 *   extracted value is not EXACTLY value, then will linearly interpolated to
 *   cut off EXACTLY at value.
 */
function skin_limit(obj, extract_order_value_fn, begin, end) =
  // [1, 3, 5], begin = undef, end = 5 => begin_i = 0, end_i = 2 => no interpolation required
  // [1, 3, 5], begin = undef, end = 4 => begin_i = 0, end_i = 1 => end interpolation required
  // assert(begin <= end)
  let (
    pts = INCOMPLETE(obj[_SKIN_PTS]),
    last_i = idx(pts, -1),
    begin_i = is_undef(begin)
      ? 0
      : default(
          it_each(pts, find_lower())(
            function(pt) extract_order_value_fn(pt) - begin),
          0),
    end_i = is_undef(end)
      ? last_i
      : default(
          it_each(pts, find_upper())(
            function(pt) extract_order_value_fn(pt) - end),
          last_i),
    result =
      (begin_i == 0)
      ? (end_i == last_i)
        ? // nothing needs to be cut
          obj
        : // only ending needs to be cut
          let ( ept0 = pts[end_i-1], eev0 = extract_order_value_fn(ept0) )
          eev0 == end
          ? // interpolation not needed
            [
              for (i = [0 : end_i-1]) pts[i]
            ]
          : // interpolating
            let ( ept1 = pts[end_i  ], eev1 = extract_order_value_fn(ept1) )
            [
              for (i = [0 : end_i]) pts[i]
              ,
              interpolate([eev0, ept0], [eev1, ept1], end)
            ]
      : (is_undef(end_i) || end_i == 0)
        ? // only beginning need to be cut
          let ( bpt0 = pts[begin_i-1], bev0 = extract_order_value_fn(bpt0) )
          bev0 == begin
          ? // interpolation not needed
            [
              for (i = [begin_i : end_i]) pts[i]
            ]
          :
            let ( bpt1 = pts[begin_i  ], bev1 = extract_order_value_fn(bpt1) )
            [
              interpolate([bev0, bpt0], [bev1, bpt1], end)
              ,
              for (i = [0 : begin_i]) pts[i]
            ]
        : // both beginning and ending need to be cut
          let ( ept0 = pts[end_i-1], eev0 = extract_order_value_fn(ept0) )
          let ( bpt0 = pts[begin_i-1], bev0 = extract_order_value_fn(bpt0) )
          eev0 == end
            ? // no interpolation required
              bev0 == begin
              ?
              [
                for (i = [0 : end_i-1]) pts[i]
              ]
              : INCOMPLETE()
            : INCOMPLETE()
          ? INCOMPLETE()
          :
            let ( ept1 = pts[end_i  ], eev1 = extract_order_value_fn(ept1) )
            [
              for (i = [0 : end_i]) pts[i]
              ,
              interpolate([eev0, ept0], [eev1, ept1], end)
            ]
  )
  result
;

/**
 * For debugging, returns a string reporting the stats of a skin object.
 *
 * Asserts if the object's number of points doesn't correspond to the equation:
 *
 *   `(layers + 1) * pts_in_layer`
 *
 * @param {skin} obj
 *   Object to verify.
 * @param {bool} disp_all_pts
 *   - If false, only returns the first and last points in the list.
 *   - If true, returns all points, with each layer of points on a separate line.
 *
 * @returns {string}
 *   A prettified/simplified view of points in the object.
 */
function skin_verify(obj, disp_all_pts = false) =
  let (
    pts_in_layer = obj[_SKIN_PTS_IN_LAYER],
    layers = obj[_SKIN_LAYERS],
    pts3d = obj[_SKIN_PTS],
    result = len(pts3d) == pts_in_layer * (layers + 1),
    output = str("pts_in_layer: ", pts_in_layer, ", layers: ", layers, " gives: ", pts_in_layer * (layers+1), " pts."),
    str_obj = skin_to_string(obj, !disp_all_pts)
  )
  assert(result, str(output, "  Actual pts: ", len(pts3d), "  obj: ", str_obj))
  str_obj
;

/**
 * EXPERIMENTAL:
 *
 * Returns a function that can be used with skin_add_layer_if() to ensure that
 * the distance between layers don't exceed some length.
 *
 * @param {skin} obj
 * @param {number} max_diff
 *   Maximum distance before adding another layer to reduce the distance below
 *   max_diff.
 * @param {function(p0: Point3D, p1: Point3D): number} [diff_fn=function(p0, p1) p1.x - p0.x]
 *   Callback that gives the distance between layers, where `p0` is the first
 *   point of the current layer and `p1` is the first point of the next layer.
 *   Will return a value that states the distance between layers.
 *
 * @returns {function(i: number): number}
 *   Function that can be used with skin_add_layer_if() and returns the number
 *   of layers to add.
 */
function skin_max_layer_distance_fn(obj, max_diff, diff_fn = function(p0, p1) p1.x - p0.x) =
  let (
    pts = obj[_SKIN_PTS],
    pts_in_layer = obj[_SKIN_PTS_IN_LAYER]
  )
  function(i)
    let (
      diff = diff_fn(pts[i], pts[i + pts_in_layer])
    )
    floor(diff / max_diff) - 1
;

/**
 * TODO: Look into this. Not sure what I was attempting here.
 */
function skin_max_pt_distance_fn(obj, max_diff) =
  let (
    pts = obj[_SKIN_PTS],
    pts_in_layer = obj[_SKIN_PTS_IN_LAYER]
  )
  function(i)
    let (
      diff = max(
        it_each(
            els(pts, i+pts_in_layer, i+pts_in_layer*2-1)
          - els(pts, i             , i+pts_in_layer  -1),
          function_map())(function(pt) norm(pt)))
    )
    floor(diff / max_diff) - 1
;

// Simple extrusion along the x axis.
//
// Note: Extrusions can go in any direction by making the extrusion axis
//       dependent on i.
module skin_example1() {
  rectangular_prism_fn = function(i)
  [
    [ i, 0, 0 ],
    [ i, 1, 0 ],
    [ i, 1, 1 ],
    [ i, 0, 1 ]
  ];

  test_skin =
    skin_extrude(0, 3)(rectangular_prism_fn)
  ;
  echo("test_skin: ", skin_to_string(test_skin));
  skin_to_polyhedron(test_skin);
}

// Making two separate extrusions.
module skin_example2() {
  rectangular_prism_fn = function(i)
  [
    [ i, 0, 0 ],
    [ i, 1, 0 ],
    [ i, 1, 1 ],
    [ i, 0, 1 ]
  ];
  triangular_prism_fn = function(i)
  [
    [ i, 0, 0 ],
    [ i, 1, 0 ],
    [ i, 0, 1 ]
  ];

  test_skin = [
    skin_extrude(0, 3)(rectangular_prism_fn),
    skin_extrude(-3, 0)(triangular_prism_fn)
  ];
  echo("test_skin: ", skin_to_string(test_skin));
  skin_to_polyhedron(test_skin);
}

// Joining 2 extrusions of different layer point size by duplicating a point to
// keep the layer point size the same.  Faces which are degenerate triangles are
// filtered, so this is ok.
module skin_example3() {
  rectangular_prism_fn = function(i)
  [
    [ i, 0, 0 ],
    [ i, 1, 0 ],
    [ i, 1, 1 ],
    [ i, 0, 1 ]
  ];
  triangular_prism_fn = function(i)
  [
    [ i, 0, 0 ],
    [ i, 1, 0 ],
    [ i, 1, 0 ],
    [ i, 0, 1 ]
  ];
  hybrid_fn = function(i)
    i < 0 ? triangular_prism_fn(i) : rectangular_prism_fn(i)
  ;
  test_skin =
    skin_extrude(-3, 3)(hybrid_fn)
  ;
  echo("test_skin: ", skin_to_string(test_skin, false));
  skin_to_polyhedron(
    let (
      pts = test_skin[_SKIN_PTS],
      pts_in_layer = test_skin[_SKIN_PTS_IN_LAYER]
    )
    // test_skin
    skin_add_layer_if(test_skin, skin_max_layer_distance_fn(test_skin, 0.333)
      // function(i)
      //   let (
      //     diff = pts[i + pts_in_layer].x - pts[i].x,
      //     max_diff = 0.5
      //   )
      //   floor(diff / max_diff) - 1
    )
  );
}

skin_example3();
