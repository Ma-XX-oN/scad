/**
 * ## spline
 *
 * ### How to Import
 *
 *     use <spline>
 *
 * ### Purpose
 *
 * Provides spline curves and sampled polyline representations for use with
 * path-based extrusions.  A [spline](#t-spline) defines a smooth curve through
 * control points.  An [spoly](#t-spoly) is the adaptively-sampled polyline
 * representation, with control point indices preserved for synchronizing
 * rail and guide paths.
 *
 * ### Functions and Modules
 */
use <helpers>
use <transform>
use <indexable>
use <string>
use <color>
include <spline_consts>

/**
 * ### Design
 *
 * Two object types are defined:
 *
 * - **spline** - the mathematical curve definition (control points, type,
 *   tension, open/closed).
 * - **spoly** - the sampled polyline with cached arc lengths, tangents,
 *   and an index map back to the original control points.
 */

/**
 * @typedef {list} spline
 * @deref {SplineEnum}
 *
 * Represents a spline curve through control points.
 *
 * @slot {list[Point3D,...]} SPLINE_PTS
 *   The control points defining the curve.  For Catmull-Rom, these are the
 *   interpolation points.  For cubic Bezier, the layout is
 *   `[P0, H0out, H1in, P1, H1out, H2in, P2, ...]` where anchor points are
 *   at indices `0, 3, 6, ...` and handles are between them.
 * @slot {bool} SPLINE_CLOSED
 *   Whether the spline forms a closed loop.
 * @slot {number} _SPLINE_TYPE
 *   Spline type enum: `SPLINE_T_CATMULL_ROM` or `SPLINE_T_BEZIER`.
 * @slot {number} _SPLINE_TENSION
 *   Tension parameter for Catmull-Rom (default 0.5).  Ignored for Bezier.
 */

/**
 * @typedef {list} spoly
 * @deref {SpolyEnum}
 *
 * Represents an adaptively-sampled polyline derived from a spline, with
 * control point correspondence preserved.
 *
 * @slot {list[Point3D,...]} SPOLY_PTS
 *   The sampled polyline points.
 * @slot {list[number,...]} SPOLY_CTRL_IS
 *   Indices into `SPOLY_PTS` for the original spline control points.
 * @slot {list[number,...]} _SPOLY_ARC_LENS
 *   Cumulative arc length at each polyline point.
 * @slot {list[Vector3D,...]} _SPOLY_TANGENTS
 *   Unit tangent vector at each polyline point.
 * @slot {bool} SPOLY_CLOSED
 *   Whether this polyline represents a closed loop.
 */

/**
 * ### SPLINE Functions
 */

/**
 * Type check for spline objects.
 *
 * @param {any} obj
 *   The value to test.
 * @returns {bool}
 *   `true` if `obj` is a spline.
 */
function is_spline(obj) = is_list(obj) && obj[0] == _SPLINE_ID;

/**
 * Verify that a value is a spline object.
 *
 * @param {spline} s
 *   Value to check.
 */
function verify_spline(s) =
  assert(is_spline(s),
         str("Expected spline object.  Got: ", s));

/**
 * Create a new spline object.
 *
 * @param {list[Point3D,...]} pts
 *   Control points (3D).  Layout depends on the spline type:
 *   - **Catmull-Rom** - Each point is an interpolation point that the
 *     curve passes through.
 *   - **Cubic Bezier** - Points alternate between anchors and handles:
 *     `[P0, H0out, H1in, P1, H1out, H2in, P2, ...]`.  Anchors are at
 *     indices `0, 3, 6, ...` and handles sit between them.  Requires
 *     `3n + 1` points for `n` segments.
 * @param {bool} [closed=false]
 *   Whether the spline is a closed loop.
 * @param {SplineTypeEnum} type
 *   Spline type enum.  Default `SPLINE_T_CATMULL_ROM`.
 * @param {number} [tension=0.5]
 *   Tension for Catmull-Rom.
 * @returns {spline}
 *   A new spline object.
 */
function spline_new(pts, closed = false, type = SPLINE_T_CATMULL_ROM, tension = 0.5) =
  [ _SPLINE_ID, pts, closed, type, tension ];

/**
 * Number of segments in a spline.
 *
 * @param {spline} s
 *   A spline object.
 * @returns {number}
 *   The number of curve segments.
 */
function spline_segment_count(s) =
  let(n = len(s[SPLINE_PTS]))
  s[_SPLINE_TYPE] == SPLINE_T_BEZIER
    ? (s[SPLINE_CLOSED] ? n / 3 : (n - 1) / 3)
    : (s[SPLINE_CLOSED] ? n : n - 1);

/**
 * Convert a Catmull-Rom spline to an equivalent cubic Bezier spline.
 *
 * Each Catmull-Rom segment between P1 and P2 (with neighbours P0, P3)
 * maps to a cubic Bezier with control points:
 * - B0 = P1
 * - B1 = P1 + τ·(P2 − P0) / 3
 * - B2 = P2 − τ·(P3 − P1) / 3
 * - B3 = P2
 *
 * @param {spline} s
 *   A Catmull-Rom spline object.
 * @returns {spline}
 *   An equivalent cubic Bezier spline.
 */
function spline_cr_to_bezier(s) =
  assert(s[_SPLINE_TYPE] == SPLINE_T_CATMULL_ROM,
         "spline_cr_to_bezier: expected Catmull-Rom spline")
  let(
    pts       = s[SPLINE_PTS],
    n         = len(pts),
    closed    = s[SPLINE_CLOSED],
    tau       = s[_SPLINE_TENSION],
    seg_count = spline_segment_count(s),

    bezier_pts = [
      for (seg = [0 : seg_count - 1])
        let(
          i1 = closed ? (seg % n)           : seg,
          i0 = closed ? ((seg - 1 + n) % n) : max(0, seg - 1),
          i2 = closed ? ((seg + 1) % n)     : min(n - 1, seg + 1),
          i3 = closed ? ((seg + 2) % n)     : min(n - 1, seg + 2),
          p0 = pts[i0], p1 = pts[i1],
          p2 = pts[i2], p3 = pts[i3],
          t1 = tau * (p2 - p0),
          t2 = tau * (p3 - p1)
        )
        each [p1, p1 + t1/3, p2 - t2/3],
      if (!closed) pts[n - 1]
    ]
  )
  spline_new(bezier_pts, closed = closed, type = SPLINE_T_BEZIER);

/**
 * Convert a cubic Bezier spline to an approximate Catmull-Rom spline.
 *
 * The conversion is inherently lossy because Catmull-Rom splines have fewer
 * degrees of freedom.  This function iteratively inserts control points
 * sampled from the Bezier curve until the maximum deviation falls below
 * `tolerance` or the point count reaches `max_pts`.
 *
 * @param {spline} s
 *   A cubic Bezier spline object.
 * @param {number} [tolerance=0.01]
 *   Maximum allowed deviation from the Bezier curve.
 * @param {number} [max_pts=undef]
 *   Maximum number of control points in the result.  `undef` means
 *   unlimited.
 * @returns {list}
 *   `[cr_spline, achieved_tolerance]` - the Catmull-Rom approximation and
 *   the maximum deviation measured.  If `achieved_tolerance <= tolerance`,
 *   the fit met the target; otherwise the point budget was exhausted.
 */
function spline_bezier_to_cr(s, tolerance = 0.01, max_pts = undef) =
  assert(s[_SPLINE_TYPE] == SPLINE_T_BEZIER,
         "spline_bezier_to_cr: expected Bezier spline")
  let(
    pts     = s[SPLINE_PTS],
    n       = len(pts),
    closed  = s[SPLINE_CLOSED],
    anchors = [for (i = [0 : 3 : n - 1]) pts[i]],
    b_segs  = spline_segment_count(s),
    n_samp  = max(b_segs * 20, 40),
    // Pre-compute Bezier reference spoly at high accuracy.
    b_sp    = spline_to_spoly(s, tolerance / 10)
  )
  _bcr_iter(b_sp, anchors, closed, tolerance, max_pts, n_samp, 50);

/**
 * Iterative refinement loop for Bezier-to-CR conversion.
 *
 * Builds a CR spline from `cr_pts`, converts both it and the reference
 * Bezier spoly to arc-length parameterised polylines, measures the
 * maximum deviation, and - if above `tol` - inserts the worst Bezier
 * point into `cr_pts` and recurses.
 *
 * @param {spoly} b_sp
 *   Pre-computed Bezier reference spoly.
 * @param {list[Point3D,...]} cr_pts
 *   Current Catmull-Rom control points.
 * @param {bool} closed
 *   Whether the spline is a closed loop.
 * @param {number} tol
 *   Target tolerance.
 * @param {(number|undef)} max_pts
 *   Maximum number of control points, or `undef` for unlimited.
 * @param {number} n_samp
 *   Number of arc-length samples for deviation measurement.
 * @param {number} depth
 *   Remaining recursion depth.
 * @returns {list}
 *   `[cr_spline, max_deviation]`.
 */
function _bcr_iter(b_sp, cr_pts, closed, tol, max_pts, n_samp, depth) =
  let(
    cr   = spline_new(cr_pts, closed = closed, type = SPLINE_T_CATMULL_ROM),
    c_sp = spline_to_spoly(cr, tol / 10),
    dev  = _bcr_max_dev(b_sp, c_sp, n_samp),
    max_d    = dev[0],
    worst_pt = dev[1]
  )
  (max_d <= tol || depth <= 0 ||
   (max_pts != undef && len(cr_pts) >= max_pts))
    ? [cr, max_d]
    : let(
        ins_i   = _bcr_insert_i(cr_pts, worst_pt, closed),
        new_pts = insert(cr_pts, ins_i, [worst_pt])
      )
      _bcr_iter(b_sp, new_pts, closed, tol, max_pts, n_samp, depth - 1);

/**
 * Find the maximum deviation between two spolys, compared at matching
 * arc-length fractions.
 *
 * Samples both spolys at `n_samp` evenly-spaced arc-length fractions and
 * returns the largest point-to-point distance found.
 *
 * @param {spoly} b_sp
 *   Bezier reference spoly.
 * @param {spoly} c_sp
 *   Catmull-Rom candidate spoly.
 * @param {number} n_samp
 *   Number of sample fractions (excludes endpoints).
 * @returns {list}
 *   `[max_deviation, worst_bezier_point]`.
 */
function _bcr_max_dev(b_sp, c_sp, n_samp) =
  let(
    b_pts  = b_sp[SPOLY_PTS],
    b_arcs = b_sp[_SPOLY_ARC_LENS],
    b_n    = len(b_pts),
    b_total = b_arcs[b_n - 1],
    c_pts  = c_sp[SPOLY_PTS],
    c_arcs = c_sp[_SPOLY_ARC_LENS],
    c_n    = len(c_pts),
    c_total = c_arcs[c_n - 1]
  )
  _bcr_max_dev_acc(b_pts, b_arcs, b_n, b_total,
                   c_pts, c_arcs, c_n, c_total,
                   n_samp, 1, 0, [0, 0, 0]);

/**
 * Recursive accumulator for `_bcr_max_dev`.
 *
 * @param {list[Point3D,...]} b_pts
 *   Bezier spoly points.
 * @param {list[number,...]} b_arcs
 *   Bezier cumulative arc lengths.
 * @param {number} b_n
 *   Length of `b_pts`.
 * @param {number} b_total
 *   Total Bezier arc length.
 * @param {list[Point3D,...]} c_pts
 *   CR spoly points.
 * @param {list[number,...]} c_arcs
 *   CR cumulative arc lengths.
 * @param {number} c_n
 *   Length of `c_pts`.
 * @param {number} c_total
 *   Total CR arc length.
 * @param {number} n_samp
 *   Total number of samples.
 * @param {number} i
 *   Current sample index.
 * @param {number} best_d
 *   Largest deviation found so far.
 * @param {Point3D} best_pt
 *   Bezier point at the largest deviation.
 * @returns {list}
 *   `[max_deviation, worst_bezier_point]`.
 */
function _bcr_max_dev_acc(b_pts, b_arcs, b_n, b_total,
                          c_pts, c_arcs, c_n, c_total,
                          n_samp, i, best_d, best_pt) =
  i >= n_samp
    ? [best_d, best_pt]
    : let(
        frac = i / n_samp,
        b_pt = _spoly_lerp_at_arc_len(b_pts, b_arcs, 0, b_n - 1,
                                       frac * b_total),
        c_pt = _spoly_lerp_at_arc_len(c_pts, c_arcs, 0, c_n - 1,
                                       frac * c_total),
        d       = norm(b_pt - c_pt),
        better  = d > best_d
      )
      _bcr_max_dev_acc(b_pts, b_arcs, b_n, b_total,
                       c_pts, c_arcs, c_n, c_total,
                       n_samp, i + 1,
        better ? d    : best_d,
        better ? b_pt : best_pt);

/**
 * Shortest distance from a point to a line segment.
 *
 * Projects `p` onto the line through `a`–`b`, clamps the parameter to
 * [0, 1], and returns the Euclidean distance to the projection.
 *
 * @param {Point3D} p
 *   Query point.
 * @param {Point3D} a
 *   Segment start.
 * @param {Point3D} b
 *   Segment end.
 * @returns {number}
 *   Distance from `p` to the nearest point on segment `a`–`b`.
 */
function _bcr_pt_seg_dist(p, a, b) =
  let(
    ab  = b - a,
    ap  = p - a,
    ab2 = ab * ab,
    t   = ab2 > 0 ? max(0, min(1, (ap * ab) / ab2)) : 0
  )
  norm(p - (a + t * ab));

/**
 * Find the insertion index for a new point in the control polygon.
 *
 * Finds the control-polygon segment nearest to `p` and returns the
 * list index at which `p` should be inserted (i.e. after the segment
 * start vertex).
 *
 * @param {list[Point3D,...]} pts
 *   Control polygon vertices.
 * @param {Point3D} p
 *   Point to insert.
 * @param {bool} closed
 *   Whether the polygon wraps around.
 * @returns {number}
 *   Insertion index into `pts`.
 */
function _bcr_insert_i(pts, p, closed) =
  let(
    n      = len(pts),
    n_segs = closed ? n : n - 1
  )
  _bcr_insert_i_acc(pts, p, n, n_segs, 0, 0, 1e10) + 1;

/**
 * Recursive accumulator for `_bcr_insert_i`.
 *
 * @param {list[Point3D,...]} pts
 *   Control polygon vertices.
 * @param {Point3D} p
 *   Point to insert.
 * @param {number} n
 *   Length of `pts`.
 * @param {number} n_segs
 *   Number of polygon segments.
 * @param {number} i
 *   Current segment index.
 * @param {number} best_i
 *   Index of the nearest segment found so far.
 * @param {number} best_d
 *   Distance of the nearest segment found so far.
 * @returns {number}
 *   Index of the nearest segment.
 */
function _bcr_insert_i_acc(pts, p, n, n_segs, i, best_i, best_d) =
  i >= n_segs
    ? best_i
    : let(
        d      = _bcr_pt_seg_dist(p, pts[i], pts[(i + 1) % n]),
        better = d < best_d
      )
      _bcr_insert_i_acc(pts, p, n, n_segs, i + 1,
        better ? i : best_i,
        better ? d : best_d);

/**
 * Evaluate a spline at parameter `t` in the given segment.
 *
 * For Catmull-Rom splines, each segment spans between consecutive control
 * points.  For cubic Bezier splines, control points are laid out as
 * `[P0, H0, H1, P1, H2, H3, P2, ...]` where each segment uses 4 points:
 * segment `i` uses indices `[3*i, 3*i+1, 3*i+2, 3*i+3]`.
 *
 * @param {spline} s
 *   A spline object.
 * @param {number} seg
 *   Segment index (0-based).
 * @param {number} t
 *   Parameter in [0, 1].
 * @returns {Point3D}
 *   The point on the curve.
 */
function spline_point_at(s, seg, t) =
  s[_SPLINE_TYPE] == SPLINE_T_BEZIER
    ? _spline_bezier_point(s, seg, t)
    : _spline_catmull_rom_point(s, seg, t);

/**
 * Evaluate a point on a Catmull-Rom spline segment.
 *
 * Uses the standard cubic polynomial with tension parameter `τ`.
 *
 * @param {spline} s
 *   A Catmull-Rom spline object.
 * @param {number} seg
 *   Segment index (0-based).
 * @param {number} t
 *   Parameter in [0, 1].
 * @returns {Point3D}
 *   The point on the curve.
 */
function _spline_catmull_rom_point(s, seg, t) =
  let(
    pts    = s[SPLINE_PTS],
    n      = len(pts),
    closed = s[SPLINE_CLOSED],
    tau    = s[_SPLINE_TENSION],
    i1 = closed ? (seg % n)       : seg,
    i0 = closed ? ((seg - 1 + n) % n) : max(0, seg - 1),
    i2 = closed ? ((seg + 1) % n) : min(n - 1, seg + 1),
    i3 = closed ? ((seg + 2) % n) : min(n - 1, seg + 2),
    p0 = pts[i0],
    p1 = pts[i1],
    p2 = pts[i2],
    p3 = pts[i3],
    t2 = t * t,
    t3 = t2 * t
  )
  let(ts = 2 * tau)
  [
    for (d = [0:2])
      ts * (
        p1[d]
        + (-p0[d] + p2[d]) * 0.5 * t
        + (p0[d] - 2.5*p1[d] + 2*p2[d] - 0.5*p3[d]) * t2
        + (-0.5*p0[d] + 1.5*p1[d] - 1.5*p2[d] + 0.5*p3[d]) * t3
      ) / ts
  ];

/**
 * Evaluate a point on a cubic Bezier spline segment.
 *
 * B(t) = (1-t)³·P0 + 3·(1-t)²·t·P1 + 3·(1-t)·t²·P2 + t³·P3
 *
 * @param {spline} s
 *   A cubic Bezier spline object.
 * @param {number} seg
 *   Segment index (0-based).
 * @param {number} t
 *   Parameter in [0, 1].
 * @returns {Point3D}
 *   The point on the curve.
 */
function _spline_bezier_point(s, seg, t) =
  let(
    pts = s[SPLINE_PTS],
    n   = len(pts),
    closed = s[SPLINE_CLOSED],
    base = 3 * seg,
    i0 = closed ? (base % n)       : base,
    i1 = closed ? ((base + 1) % n) : base + 1,
    i2 = closed ? ((base + 2) % n) : base + 2,
    i3 = closed ? ((base + 3) % n) : base + 3,
    p0 = pts[i0],
    p1 = pts[i1],
    p2 = pts[i2],
    p3 = pts[i3],
    u  = 1 - t,
    u2 = u * u,
    u3 = u2 * u,
    t2 = t * t,
    t3 = t2 * t
  )
  u3 * p0 + 3 * u2 * t * p1 + 3 * u * t2 * p2 + t3 * p3;

/**
 * Evaluate the tangent (derivative) of a spline at parameter `t`.
 *
 * @param {spline} s
 *   A spline object.
 * @param {number} seg
 *   Segment index (0-based).
 * @param {number} t
 *   Parameter in [0, 1].
 * @returns {Vector3D}
 *   The (unnormalized) tangent vector.
 */
function spline_tangent_at(s, seg, t) =
  s[_SPLINE_TYPE] == SPLINE_T_BEZIER
    ? _spline_bezier_tangent(s, seg, t)
    : _spline_catmull_rom_tangent(s, seg, t);

/**
 * Evaluate the tangent of a Catmull-Rom spline segment.
 *
 * Returns the first derivative of the cubic polynomial at parameter `t`.
 *
 * @param {spline} s
 *   A Catmull-Rom spline object.
 * @param {number} seg
 *   Segment index (0-based).
 * @param {number} t
 *   Parameter in [0, 1].
 * @returns {Vector3D}
 *   The (unnormalised) tangent vector.
 */
function _spline_catmull_rom_tangent(s, seg, t) =
  let(
    pts    = s[SPLINE_PTS],
    n      = len(pts),
    closed = s[SPLINE_CLOSED],
    tau    = s[_SPLINE_TENSION],
    i1 = closed ? (seg % n)       : seg,
    i0 = closed ? ((seg - 1 + n) % n) : max(0, seg - 1),
    i2 = closed ? ((seg + 1) % n) : min(n - 1, seg + 1),
    i3 = closed ? ((seg + 2) % n) : min(n - 1, seg + 2),
    p0 = pts[i0],
    p1 = pts[i1],
    p2 = pts[i2],
    p3 = pts[i3],
    t2 = t * t
  )
  [
    for (d = [0:2])
      0.5 * (
        (-p0[d] + p2[d])
        + 2 * (p0[d] - 2.5*p1[d] + 2*p2[d] - 0.5*p3[d]) * t
        + 3 * (-0.5*p0[d] + 1.5*p1[d] - 1.5*p2[d] + 0.5*p3[d]) * t2
      )
  ];

/**
 * Evaluate the tangent of a cubic Bezier spline segment.
 *
 * B'(t) = 3·(1-t)²·(P1-P0) + 6·(1-t)·t·(P2-P1) + 3·t²·(P3-P2)
 *
 * @param {spline} s
 *   A cubic Bezier spline object.
 * @param {number} seg
 *   Segment index (0-based).
 * @param {number} t
 *   Parameter in [0, 1].
 * @returns {Vector3D}
 *   The (unnormalised) tangent vector.
 */
function _spline_bezier_tangent(s, seg, t) =
  let(
    pts = s[SPLINE_PTS],
    n   = len(pts),
    closed = s[SPLINE_CLOSED],
    base = 3 * seg,
    i0 = closed ? (base % n)       : base,
    i1 = closed ? ((base + 1) % n) : base + 1,
    i2 = closed ? ((base + 2) % n) : base + 2,
    i3 = closed ? ((base + 3) % n) : base + 3,
    p0 = pts[i0],
    p1 = pts[i1],
    p2 = pts[i2],
    p3 = pts[i3],
    u  = 1 - t
  )
  3 * u * u * (p1 - p0) + 6 * u * t * (p2 - p1) + 3 * t * t * (p3 - p2);

/**
 * ### Adaptive Sampling
 */

/**
 * Recursively subdivide a spline segment until the midpoint deviation from
 * the chord is within tolerance.
 *
 * @param {spline} s
 *   The spline.
 * @param {number} seg
 *   Segment index.
 * @param {number} t0
 *   Start parameter.
 * @param {Point3D} p0
 *   Point at t0.
 * @param {number} t1
 *   End parameter.
 * @param {Point3D} p1
 *   Point at t1.
 * @param {number} tol
 *   Maximum allowed deviation.
 * @param {number} depth
 *   Recursion depth limit.
 * @returns {list[Point3D,...]}
 *   Interior points (not including p0 or p1).
 */
function _spline_subdivide(s, seg, t0, p0, t1, p1, tol, depth) =
  let(
    tmid = (t0 + t1) / 2,
    pmid = spline_point_at(s, seg, tmid),
    // midpoint of chord
    chord_mid = (p0 + p1) / 2,
    dev = norm(pmid - chord_mid)
  )
  (dev <= tol || depth <= 0)
    ? []
    : let(
        left  = _spline_subdivide(s, seg, t0, p0, tmid, pmid, tol, depth - 1),
        right = _spline_subdivide(s, seg, tmid, pmid, t1, p1, tol, depth - 1)
      )
      concat(left, [pmid], right);

/**
 * Sample a single segment adaptively.
 *
 * @param {spline} s
 *   The spline.
 * @param {number} seg
 *   Segment index.
 * @param {number} tol
 *   Tolerance.
 * @returns {list[Point3D,...]}
 *   Points for this segment, starting with the segment start point.
 *   The segment end point is NOT included (it will be the start of the next
 *   segment, or appended for the last segment).
 */
function _spline_sample_segment(s, seg, tol) =
  let(
    p0 = spline_point_at(s, seg, 0),
    p1 = spline_point_at(s, seg, 1),
    interior = _spline_subdivide(s, seg, 0, p0, 1, p1, tol, 10)
  )
  concat([p0], interior);

/**
 * Convert a spline to a sampled polyline (spoly).
 *
 * @param {spline} s
 *   The spline to sample.
 * @param {number} tolerance
 *   Maximum deviation from the true curve.  Default `0.01`.
 * @returns {spoly}
 *   The sampled polyline with control point indices, arc lengths, and tangents.
 */
function spline_to_spoly(s, tolerance = 0.01) =
  let(
    seg_count = spline_segment_count(s),
    closed    = s[SPLINE_CLOSED],

    // Collect points and track control point indices.
    // Each segment contributes its start point + interior points.
    // The final endpoint is appended after the loop.
    _seg_results = [for (seg = [0 : seg_count - 1]) _spline_sample_segment(s, seg, tolerance)],

    // Build flat point list and control indices.
    _build = _spoly_build_pts(_seg_results, seg_count, closed, s),

    pts     = _build[0],
    ctrl_is = _build[1],

    // Compute cumulative arc lengths.
    arc_lens = _spoly_compute_arc_lens(pts),

    // Compute unit tangents from adjacent points.
    tangents = _spoly_compute_tangents(pts, closed)
  )
  [ _SPOLY_ID, pts, ctrl_is, arc_lens, tangents, closed ];

/**
 * Build the flat point list and control point index list from per-segment
 * sample results.
 *
 * @param {list} seg_results
 *   Per-segment sample point lists.
 * @param {number} seg_count
 *   Number of segments.
 * @param {bool} closed
 *   Whether the spline is closed.
 * @param {spline} s
 *   The spline (for evaluating the final endpoint).
 * @returns {list}
 *   `[pts, ctrl_is]`
 */
function _spoly_build_pts(seg_results, seg_count, closed, s) =
  let(
    // Flatten: for each segment, accumulate points and record the index of
    // the first point (which is the control point) in ctrl_is.
    _acc = _spoly_flatten_segs(seg_results, 0, seg_count),
    flat_pts = _acc[0],
    ctrl_is  = _acc[1],

    // Append final endpoint.
    last_pt = spline_point_at(s, seg_count - 1, 1),
    pts     = concat(flat_pts, [last_pt]),

    // For closed splines, the last control point index is the last point.
    // For open splines, same - the final point is the last control point.
    final_ctrl_is = concat(ctrl_is, [len(pts) - 1])
  )
  [pts, final_ctrl_is];

/**
 * Flatten per-segment results into a single point list, tracking control
 * point indices.
 *
 * @param {list} seg_results
 *   Per-segment sample point lists.
 * @param {number} offset
 *   Current index offset into the flat list.
 * @param {number} seg_count
 *   Total number of segments.
 * @returns {list}
 *   `[flat_pts, ctrl_is]`
 */
function _spoly_flatten_segs(seg_results, offset, seg_count) =
  let(
    // Use a recursive accumulator.
    _result = _spoly_flatten_segs_acc(seg_results, 0, seg_count, 0, [], [])
  )
  [_result[0], _result[1]];

function _spoly_flatten_segs_acc(seg_results, seg_i, seg_count, offset, pts_acc, ctrl_acc) =
  seg_i >= seg_count
    ? [pts_acc, ctrl_acc]
    : let(
        seg_pts = seg_results[seg_i],
        new_pts = concat(pts_acc, seg_pts),
        new_ctrl = concat(ctrl_acc, [offset]),
        new_offset = offset + len(seg_pts)
      )
      _spoly_flatten_segs_acc(seg_results, seg_i + 1, seg_count, new_offset, new_pts, new_ctrl);

/**
 * Compute cumulative arc lengths for a polyline.
 *
 * @param {list[Point3D,...]} pts
 *   The polyline points.
 * @returns {list[number,...]}
 *   Cumulative arc length at each point (first is 0).
 */
function _spoly_compute_arc_lens(pts) =
  let(n = len(pts))
  _spoly_arc_lens_acc(pts, 1, n, [0]);

function _spoly_arc_lens_acc(pts, i, n, acc) =
  i >= n
    ? acc
    : let(
        d = norm(pts[i] - pts[i - 1]),
        new_acc = concat(acc, [acc[i - 1] + d])
      )
      _spoly_arc_lens_acc(pts, i + 1, n, new_acc);

/**
 * Compute unit tangent vectors for a polyline.
 *
 * @param {list[Point3D,...]} pts
 *   The polyline points.
 * @param {bool} closed
 *   Whether the polyline is closed.
 * @returns {list[Vector3D,...]}
 *   Unit tangent at each point.
 */
function _spoly_compute_tangents(pts, closed) =
  let(n = len(pts))
  [
    for (i = [0 : n - 1])
      let(
        prev = closed ? pts[(i - 1 + n) % n] : (i > 0 ? pts[i - 1] : pts[i]),
        next = closed ? pts[(i + 1) % n]     : (i < n - 1 ? pts[i + 1] : pts[i]),
        diff = next - prev,
        l    = norm(diff)
      )
      l > 0 ? diff / l : [0, 0, 1]
  ];

/**
 * ### SPOLY Functions
 */

/**
 * Type check for spoly objects.
 *
 * @param {any} obj
 *   The value to test.
 * @returns {bool}
 *   `true` if `obj` is a spoly.
 */
function is_spoly(obj) = is_list(obj) && obj[0] == _SPOLY_ID;

/**
 * Create a new spoly object directly.
 *
 * @param {list[Point3D,...]} pts
 *   Polyline points.
 * @param {list[number,...]} ctrl_is
 *   Indices into `pts` for original control points.
 * @param {list[number,...]} arc_lens
 *   Cumulative arc length at each point.
 * @param {list[Vector3D,...]} tangents
 *   Unit tangent at each point.
 * @param {bool} closed
 *   Whether this is a closed loop.
 * @returns {spoly}
 *   A new spoly object.
 */
function spoly_new(pts, ctrl_is, arc_lens, tangents, closed = false) =
  [ _SPOLY_ID, pts, ctrl_is, arc_lens, tangents, closed ];

/**
 * Query a point on an spoly at a given control point index plus a percentage
 * toward the next control point.
 *
 * @param {spoly} sp
 *   An spoly object.
 * @param {number} ctrl_idx
 *   Index into the control point list (0-based).
 * @param {number} pct
 *   Percentage [0, 1] along the segment from `ctrl_idx` to `ctrl_idx + 1`.
 * @returns {Point3D}
 *   The interpolated point.
 */
function spoly_point_at(sp, ctrl_idx, pct) =
  let(
    pts      = sp[SPOLY_PTS],
    ctrl_is  = sp[SPOLY_CTRL_IS],
    arc_lens = sp[_SPOLY_ARC_LENS],
    i_start  = ctrl_is[ctrl_idx],
    i_end    = ctrl_is[ctrl_idx + 1],
    al_start = arc_lens[i_start],
    al_end   = arc_lens[i_end],
    target_al = al_start + pct * (al_end - al_start)
  )
  _spoly_lerp_at_arc_len(pts, arc_lens, i_start, i_end, target_al);

/**
 * Query a tangent on an spoly at a given control point index plus a percentage
 * toward the next control point.
 *
 * @param {spoly} sp
 *   An spoly object.
 * @param {number} ctrl_idx
 *   Index into the control point list (0-based).
 * @param {number} pct
 *   Percentage [0, 1] along the segment.
 * @returns {Vector3D}
 *   The interpolated unit tangent.
 */
function spoly_tangent_at(sp, ctrl_idx, pct) =
  let(
    pts      = sp[SPOLY_PTS],
    tangents = sp[_SPOLY_TANGENTS],
    ctrl_is  = sp[SPOLY_CTRL_IS],
    arc_lens = sp[_SPOLY_ARC_LENS],
    i_start  = ctrl_is[ctrl_idx],
    i_end    = ctrl_is[ctrl_idx + 1],
    al_start = arc_lens[i_start],
    al_end   = arc_lens[i_end],
    target_al = al_start + pct * (al_end - al_start),
    // Find the segment containing target_al.
    seg_i = _spoly_find_segment(arc_lens, i_start, i_end, target_al),
    frac  = (arc_lens[seg_i + 1] - arc_lens[seg_i]) > 0
            ? (target_al - arc_lens[seg_i]) / (arc_lens[seg_i + 1] - arc_lens[seg_i])
            : 0,
    t0 = tangents[seg_i],
    t1 = tangents[seg_i + 1],
    interp = t0 + frac * (t1 - t0),
    l = norm(interp)
  )
  l > 0 ? interp / l : [0, 0, 1];

/**
 * Find the polyline segment index containing a target arc length, searching
 * within the range [i_start, i_end].
 *
 * @param {list[number,...]} arc_lens
 *   Cumulative arc lengths.
 * @param {number} i_start
 *   Start index of search range.
 * @param {number} i_end
 *   End index of search range.
 * @param {number} target
 *   Target arc length.
 * @returns {number}
 *   Index `i` such that `arc_lens[i] <= target < arc_lens[i+1]`.
 */
function _spoly_find_segment(arc_lens, i_start, i_end, target) =
  _spoly_find_seg_acc(arc_lens, i_start, i_end, target);

function _spoly_find_seg_acc(arc_lens, lo, hi, target) =
  lo >= hi - 1
    ? lo
    : let(mid = floor((lo + hi) / 2))
      arc_lens[mid] <= target
        ? _spoly_find_seg_acc(arc_lens, mid, hi, target)
        : _spoly_find_seg_acc(arc_lens, lo, mid, target);

/**
 * Linearly interpolate a point along the polyline at a target arc length.
 *
 * @param {list[Point3D,...]} pts
 *   Polyline points.
 * @param {list[number,...]} arc_lens
 *   Cumulative arc lengths.
 * @param {number} i_start
 *   Start index for search.
 * @param {number} i_end
 *   End index for search.
 * @param {number} target_al
 *   Target arc length.
 * @returns {Point3D}
 *   Interpolated point.
 */
function _spoly_lerp_at_arc_len(pts, arc_lens, i_start, i_end, target_al) =
  let(
    seg_i = _spoly_find_segment(arc_lens, i_start, i_end, target_al),
    seg_len = arc_lens[seg_i + 1] - arc_lens[seg_i],
    frac = seg_len > 0 ? (target_al - arc_lens[seg_i]) / seg_len : 0
  )
  pts[seg_i] + frac * (pts[seg_i + 1] - pts[seg_i]);

/**
 * Split an spoly into two at a given control point index and percentage.
 *
 * @param {spoly} sp
 *   An spoly object.
 * @param {number} ctrl_idx
 *   Index into the control point list.
 * @param {number} pct
 *   Percentage [0, 1] along the segment from `ctrl_idx` to `ctrl_idx + 1`.
 * @returns {list[spoly, spoly]}
 *   A list of two spoly objects: `[before, after]`.
 */
function spoly_split(sp, ctrl_idx, pct) =
  let(
    pts      = sp[SPOLY_PTS],
    ctrl_is  = sp[SPOLY_CTRL_IS],
    arc_lens = sp[_SPOLY_ARC_LENS],
    tangents = sp[_SPOLY_TANGENTS],
    closed   = sp[SPOLY_CLOSED],

    i_start  = ctrl_is[ctrl_idx],
    i_end    = ctrl_is[ctrl_idx + 1],
    al_start = arc_lens[i_start],
    al_end   = arc_lens[i_end],
    target_al = al_start + pct * (al_end - al_start),

    // Find the exact split segment and interpolated point.
    seg_i    = _spoly_find_segment(arc_lens, i_start, i_end, target_al),
    seg_len  = arc_lens[seg_i + 1] - arc_lens[seg_i],
    frac     = seg_len > 0 ? (target_al - arc_lens[seg_i]) / seg_len : 0,
    split_pt = pts[seg_i] + frac * (pts[seg_i + 1] - pts[seg_i]),
    split_tan = let(
      t = tangents[seg_i] + frac * (tangents[seg_i + 1] - tangents[seg_i]),
      l = norm(t)
    ) l > 0 ? t / l : [0, 0, 1],

    // First half: points[0..seg_i] + split_pt
    pts_a = concat(
      [for (i = [0 : seg_i]) pts[i]],
      [split_pt]
    ),
    // Control indices for first half: ctrl_is[0..ctrl_idx] plus the split point.
    ctrl_is_a = concat(
      [for (i = [0 : ctrl_idx]) ctrl_is[i]],
      [len(pts_a) - 1]
    ),
    arc_lens_a = _spoly_compute_arc_lens(pts_a),
    tangents_a = concat(
      [for (i = [0 : seg_i]) tangents[i]],
      [split_tan]
    ),

    // Second half: split_pt + points[seg_i+1..end]
    pts_b = concat(
      [split_pt],
      [for (i = [seg_i + 1 : len(pts) - 1]) pts[i]]
    ),
    // Control indices for second half: 0 (split point), then offset remaining ctrl_is.
    // Remaining control points are ctrl_idx+1 onwards.
    offset_b = seg_i + 1,
    ctrl_is_b = concat(
      [0],
      [for (i = [ctrl_idx + 1 : len(ctrl_is) - 1]) ctrl_is[i] - offset_b + 1]
    ),
    arc_lens_b = _spoly_compute_arc_lens(pts_b),
    tangents_b = concat(
      [split_tan],
      [for (i = [seg_i + 1 : len(pts) - 1]) tangents[i]]
    )
  )
  [
    [ _SPOLY_ID, pts_a, ctrl_is_a, arc_lens_a, tangents_a, false ],
    [ _SPOLY_ID, pts_b, ctrl_is_b, arc_lens_b, tangents_b, false ]
  ];

/**
 * ### String Conversion
 */

/**
 * Convert a spline to a debug string.
 *
 * @param {spline} s
 *   A spline object.
 * @returns {string}
 *   A human-readable representation.
 */
function spline_to_string(s) =
  assert(is_spline(s))
  s[_SPLINE_TYPE] == SPLINE_T_CATMULL_ROM 
  ? str(
      "SPLINE[type=catmull-rom",
      ", tension=", s[_SPLINE_TENSION],
      ", closed=", s[SPLINE_CLOSED],
      ", pts(", len(s[SPLINE_PTS]), ")=", s[SPLINE_PTS],
      "]"
    )
  : str(
      "SPLINE[type=bezier",
      ", closed=", s[SPLINE_CLOSED],
      ", pts(", len(s[SPLINE_PTS]), ")=", list_to_string(s[SPLINE_PTS],
         row_length=3, indent=""),
      "]"
    );

/**
 * Convert an spoly to a debug string.
 *
 * @param {spoly} sp
 *   An spoly object.
 * @returns {string}
 *   A human-readable representation.
 */
function spoly_to_string(sp) =
  assert(is_spoly(sp))
  str(
    "SPOLY[closed=", sp[SPOLY_CLOSED],
    ", pts(", len(sp[SPOLY_PTS]), ")",
    ", ctrl_is=", sp[SPOLY_CTRL_IS],
    ", total_len=", sp[_SPOLY_ARC_LENS][len(sp[_SPOLY_ARC_LENS]) - 1],
    "]"
  );

/**
 * Render a section of a polyline as coloured chevron cones.
 *
 * If `c` is a `SpPalette` object, section colouring is applied
 * (start/stop/start_stop/cont).  Otherwise `c` is treated as a plain
 * colour passed directly to `color()`.
 *
 * @param {list[Point3D,...]} pts
 *   Point list to index into.
 * @param {number} d
 *   Diameter of the cone base.
 * @param {(SpPalette|Color)} c
 *   Colour palette or plain colour.
 * @param {number} begin_i
 *   Start index into `pts` (first point of first segment).
 * @param {number} end_i
 *   End index into `pts` (last point, inclusive).
 */
module _sp_debug_poly(pts, d, c, begin_i, end_i, alpha) {
  _is_sp = is_list(c) && c[0] == _SP_ID;
  n_segs = end_i - begin_i;
  for (i = [begin_i : end_i - 1]) {
    pt0 = pts[i];
    pt1 = pts[i + 1];
    vlen = norm(pt1 - pt0);
    ft = frame_transform([[0, 0, 0], [0, 0, 1]], [pt0, pt1]);
    sc = _is_sp
      ? (n_segs == 1        ? c[SP_START_STOP]
        : i == begin_i      ? c[SP_START]
        : i == end_i - 1    ? c[SP_STOP]
        :                     c[SP_CONT])
      : c;
    color(color_alpha(sc, alpha), alpha)
      multmatrix(ft)
        rotate(180 * i)
        cylinder(vlen, d/2, 0, $fn=3);
  }
}



/**
 * Debug visualisation of a spoly as a chain of coloured chevron cones.
 *
 * Each segment between consecutive points is rendered as a triangular cone
 * pointing in the path direction.  Colours indicate position within each
 * control-point section: start, stop, both, or continuation.
 *
 * @param {spoly} spoly
 *   The spoly to visualise.
 * @param {number} [d=0.1]
 *   Diameter of the cone base.
 * @param {SpPalette} [c=SP_SPECTRUM]
 *   Colour palette.
 */
module spoly_debug(spoly, d=0.1, c=SP_SPECTRUM) {
  ctrl = spoly[SPOLY_CTRL_IS];
  for (seg = fwd_i(ctrl, 0, -1))
    _sp_debug_poly(spoly[SPOLY_PTS], d, c, ctrl[seg], ctrl[seg + 1]);
}

/**
 * Debug visualisation of a spline showing control points, control polygon,
 * handles (Bezier only), and optionally the sampled spoly.
 *
 * Control points are rendered as arrows oriented along the tangent.
 * The control polygon connects adjacent control points (anchors for Bezier).
 * For Bezier splines, handle lines connect anchors to their handles.
 *
 * @param {spline} s
 *   The spline to visualise.
 * @param {number} [tolerance=0.01]
 *   Sampling tolerance for the spoly conversion.
 * @param {number} [d=0.1]
 *   Base diameter for chevron cones and arrow thickness.
 * @param {SpPalette} [c=SP_SPECTRUM]
 *   Colour palette.
 * @param {bool} [show_spline=true]
 *   Show control points, polygon, and handles.
 * @param {bool} [show_spoly=true]
 *   Show the sampled spoly.
 */
module spline_debug(s, tolerance=0.01, d=0.1, c=SP_SPECTRUM,
                    show_spline=true, show_spoly=true) {
  if (show_spoly) {
    sp = spline_to_spoly(s, tolerance);
    spoly_debug(sp, d, c);
  }

  if (show_spline) {
    pts = s[SPLINE_PTS];
    n = len(pts);
    is_bezier = s[_SPLINE_TYPE] == SPLINE_T_BEZIER;
    seg_count = spline_segment_count(s);

    // Control-point arrows
    for (seg = [0 : seg_count - 1]) {
      pt  = spline_point_at(s, seg, 0);
      tan = spline_tangent_at(s, seg, 0);
      ft  = frame_transform([[0, 0, 0], [0, 0, 1]], [pt, pt + tan]);
      multmatrix(ft)
        rotate([90,0,0])
        arrow(d * 5, d, true, c[SP_CTRL_PT], $fn=3);
    }

    // Last control point (only for open splines; closed wraps to first).
    if (!s[SPLINE_CLOSED]) {
      last_pt  = spline_point_at(s, seg_count - 1, 1);
      last_tan = spline_tangent_at(s, seg_count - 1, 1);
      ft_last  = frame_transform(
        [[0, 0, 0], [0, 0, 1]], [last_pt, last_pt + last_tan]);
      multmatrix(ft_last)
        rotate([90,0,0])
        arrow(d * 5, d, true, c[SP_CTRL_PT], $fn=3);
    }

    // Bezier handle lines.
    if (is_bezier) {
      for (seg = [0 : seg_count - 1]) {
        base = 3 * seg;
        // Anchor -> out-handle.
        _sp_debug_poly(pts, d/2, c[SP_HANDLE], base, base + 1);
        // In-handle -> next anchor.
        _sp_debug_poly(pts, d/2, c[SP_HANDLE], base + 2, base + 3);
      }
    }

    // Control polyline.
    if (is_bezier) {
      // Connect anchor points (indices 0, 3, 6, ...).
      anchors = [for (i = [0 : 3 : n - 1]) pts[i]];
      closed_anchors = s[SPLINE_CLOSED]
        ? concat(anchors, [anchors[0]])
        : anchors;
      _sp_debug_poly(closed_anchors, d/2, c[SP_CTRL_POLY],
                     0, len(closed_anchors) - 1, .3);
    } else {
      // Catmull-Rom: connect all control points.
      closed_pts = s[SPLINE_CLOSED]
        ? concat(pts, [pts[0]])
        : pts;
      _sp_debug_poly(closed_pts, d/2, c[SP_CTRL_POLY],
                     0, len(closed_pts) - 1, .3);
    }
  }
}

/**
 * ### Examples
 */

/**
 * @example
 *
 * Basic Catmull-Rom spline through 5 points, converted to a polyline and
 * rendered as a series of spheres.
 */
module spline_example1() {
  pts = [
    [0, 0, 0],
    [10, 5, 0],
    [20, 0, 5],
    [30, 10, 5],
    [40, 0, 0]
  ];

  s = spline_new(pts);
  sp = spline_to_spoly(s, tolerance = 0.1);

  echo(spline_to_string(s));
  echo(spoly_to_string(sp));

  // Draw polyline points.
  poly_pts = sp[SPOLY_PTS];
  for (i = [0 : len(poly_pts) - 2])
    hull() {
      translate(poly_pts[i]) sphere(0.3, $fn = 8);
      translate(poly_pts[i + 1]) sphere(0.3, $fn = 8);
    }

  // Highlight control points.
  ctrl_is = sp[SPOLY_CTRL_IS];
  for (i = ctrl_is)
    translate(poly_pts[i]) color("red") sphere(0.8, $fn = 16);
}

/**
 * @example
 *
 * Cubic Bezier spline with 2 segments (7 points: 3 anchors + 4 handles),
 * converted to a polyline.  Anchor control points are highlighted in red.
 */
module spline_example2() {
  pts = [
    [0, 0, 0],       // P0 anchor
    [5, 10, 0],      // H0out handle
    [15, 10, 0],     // H1in handle
    [20, 0, 0],      // P1 anchor
    [25, -10, 0],    // H1out handle
    [35, -10, 0],    // H2in handle
    [40, 0, 0]       // P2 anchor
  ];

  s = spline_new(pts, type = SPLINE_T_BEZIER);
  sp = spline_to_spoly(s, tolerance = 0.1);

  echo(spline_to_string(s));
  echo(spoly_to_string(sp));

  // Draw polyline.
  poly_pts = sp[SPOLY_PTS];
  for (i = [0 : len(poly_pts) - 2])
    hull() {
      translate(poly_pts[i]) sphere(0.3, $fn = 8);
      translate(poly_pts[i + 1]) sphere(0.3, $fn = 8);
    }

  // Highlight anchor control points.
  ctrl_is = sp[SPOLY_CTRL_IS];
  for (i = ctrl_is)
    translate(poly_pts[i]) color("red") sphere(0.8, $fn = 16);
}
