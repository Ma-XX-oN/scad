/**
 * ## string
 *
 * ### How to Import
 *
 *     use <string>
 *     include <string_consts> // Constants for show_sign parameter.
 *
 * ### Purpose
 *
 * OpenSCAD doesn't have any string formatting, which can make reading debug
 * output challenging.  This library is to help with that.
 */
use <base_algos>
use <test>
use <types>
include <types_consts>
use <indexable>
use <range>
use <helpers>
include <string_consts>

/**
 * Makes `s` wider to fit into width characters by padding the string on the
 * right with the `pad_char` character.  If same or wider than width, then do
 * nothing.
 *
 * @param {string} s
 *   String to align.
 * @param {int} width
 *   Minimum width to make `s`.
 * @param {string} pad_char
 *   The character to pad `s` with.
 *
 * @returns {string}
 *   The padded string.
 */
function align_left(s, width, pad_char = " ") =
  str(s, repeat(pad_char, width - len(s)))
;

/**
 * Makes `s` wider to fit into width characters by padding the string on the
 * left with the `pad_char` character.  If same or wider than width, then do
 * nothing.
 *
 * @param {string} s
 *   String to align.
 * @param {int} width
 *   Minimum width to make `s`.
 * @param {string} pad_char
 *   The character to pad `s` with.
 *
 * @returns {string}
 *   The padded string.
 */
function align_right(s, width, pad_char = " ") =
  str(repeat(pad_char, width - len(s)), s)
;

/**
 * Repeats a string `c`, `i` times.
 *
 * @param {string} c
 *   The string to repeat.
 * @param {int} i
 *   The number of times to repeat.
 * @param {string} r
 *   The accumulated repeated string.
 *
 * @returns {string}
 *   The final repeated string.
 */
function repeat(c, i, r = "") =
  i > 0
  ? repeat(c, i-1, str(c, r))
  : r
;

/**
 * Outputs the sign character for value `v` based on `show_sign` enum.
 *
 * @param {number} v
 *   Value to get +ve/-ve sign value from.
 * @param {integer} show_sign
 *    A value that is taken from SHOW_SIGN_*() consts.
 *
 * @returns {string}
 *    Character of `-`, ``, `+` or ` ` (space) depending of sign of `v`.
 */
function _sign_str(v, show_sign) =
  v < 0 ? "-" : [ "", "+", " " ][show_sign]
;

/**
 * Converts a floating point number to a string with formatting.
 *
 * TODO: Make function also do scientific formatting.
 *
 * @param {number} v
 *   Number to convert to string.
 * @param {bool} left_justified
 *   States if number is left or right justified.
 * @param {number} show_sign
 *   SHOW_SIGN_NEG - States if to only show a negative sign.
 *   SHOW_SIGN_POS_NEG - states if to show positive/negative signs.
 *   SHOW_SIGN_SPC_NEG - States if to show space for positive sign or negative sign.
 * @param {string} pad_char
 *   The character to use for padding a right justified value.
 * @param {number} min_width
 *   The minimum width of the string.
 * @param {number} precision
 *   The number of decimal places to use.
 *
 * @returns {string}
 *   Formatted number.
 */
function float_to_string(v, left_justified=true, show_sign=SHOW_SIGN_NEG, pad_char=" ", min_width=1, precision=6) =
  assert(is_num(v) || v != v, str("v (", type_value(v), ") must be a number."))
  // echo(str("f2s v: ", v, " min_width: ", min_width))
  let (
    zero = ord("0"),
    inf = 1/0,
    s = v ==  inf ? str(_sign_str(v, show_sign), v)
      : v == -inf ? str(v)
      : v != v    ? "NaN"
      : str(
        _sign_str(v, show_sign),
        reduce_air([
            "",                         // init string
            round(abs(v)*10^precision), // init value to convert
            precision                   // init number of digits to output
          ], 0, precision + 100 // Overkill. Number will never need 100+ chars.
        )(
          function(i, acc)
            // echo("I", i, acc)
            let (
              s = acc[0],              // accumulated string so far
              v = acc[1],              // value to convert
              decimals_left = acc[2],  // how many digits left to show
              remainder = v % 10,
              new_v = floor(v / 10)
            )
            // echo(remainder, new_v, zero)
            // echo(str("dl: ", decimals_left, " r: ", remainder, " nv: ", new_v, " != 0 == ", abs(new_v) > 1e-6))
            [
              decimals_left > 0 || new_v,
              [
                str( chr(zero + remainder),
                     precision && i == precision ? "." : "", s ), // new acc string
                new_v,                                            // new value (removed 1s digit)
                decimals_left-1                                   // number of digits left
              ]
            ]
        )[1][0]
      )
  )
  assert(is_num(min_width), min_width)
  len(s) < min_width
    ? left_justified
      ? align_left (s, min_width, pad_char)
      : align_right(s, min_width, pad_char)
    : s
;

inf = 1/0;
nan = inf - inf;
test_eq("+1.300000", float_to_string(1.3,  show_sign = SHOW_SIGN_POS_NEG));
test_eq("+1.3000  ", float_to_string(1.3,  show_sign = SHOW_SIGN_POS_NEG, precision=4, min_width=9));
test_eq("  +1.3000", float_to_string(1.3,  show_sign = SHOW_SIGN_POS_NEG, left_justified=false, precision=4, min_width=9));
test_eq(" 0.000000", float_to_string(0,    show_sign = SHOW_SIGN_SPC_NEG));
test_eq("+inf",      float_to_string(inf,  show_sign = SHOW_SIGN_POS_NEG));
test_eq("-inf",      float_to_string(-inf, show_sign = SHOW_SIGN_POS_NEG));
test_eq("NaN   ",    float_to_string(nan,  show_sign = SHOW_SIGN_POS_NEG, min_width=6));
test_eq("   NaN",    float_to_string(nan,  show_sign = SHOW_SIGN_POS_NEG, min_width=6, left_justified=false));

/**
 * Converts an object to a string so that if the object contains a string, all
 * escapable characters are escaped.
 *
 * If `fmt_fn` doesn't recognise `obj` and `obj` is a string, puts double quotes
 * around it.  If `obj` is list, put `[]` around each element which is formatted
 * with `obj_to_string`.  Otherwise, use `fmt_fn()` or use `str()` to convert to
 * a string.
 *
 * @param {any} obj
 *   Object to print.
 * @param {(function(obj): (string|undef))} [fmt_fn=function(obj) undef]
 *   Formatting callback to convert obj to string if obj is recognised or undef
 *   if not.
 *   - obj (any) - Obj to attempt to convert.
 *
 *   @returns {(string|undef)}
 *     If recognised, the converted object as string, else undef.
 * @param {list[string,string]} [esc_chars=["\\\"\r\n\t", "\\\"rnt"]]
 *   A list of 2 strings, where esc_chars[0] is the characters to escape and
 *   esc_chars[1] is the character to have `\\` prefixed to when escaping.  This
 *   allows for only escaping certain characters if desired.
 * @param {bool} quote_strings
 *   If obj is a string, put double quotes around it. (Default: `true`)
 * @param {bool} [csv_esc_d_quote=false]
 *   When true, if the double quote is in the esc_chars then a double quote (")
 *   will be replaced by a double double quote ("").  This is for the csv IETF
 *   RFC 4180: https://datatracker.ietf.org/doc/html/rfc4180
 *
 * @returns {string}
 *   String rep of object.
 */
function obj_to_string(obj, fmt_fn = function(obj) undef
    , esc_chars = ["\\\"\r\n\t", "\\\"rnt"], quote_strings = true, csv_esc_d_quote = false) =
  assert(len(esc_chars) == 2 && len(esc_chars[0]) == len(esc_chars[1]),
         "esc_chars should be a list of two strings of the same length")
  let (fmt_obj = fmt_fn(obj))
  fmt_obj != undef
  ? fmt_obj
  : is_string(obj)
    ? let (
        found_i = it_each(obj, find())(function(e) search(e, esc_chars[0])),
        s = // Only create a new string if there are characters to escape in it.
          found_i != undef
          ? it_each(obj, reduce(""))(function(e, a)
              let (found_is = search(e, esc_chars[0]))
              found_is
              ? csv_esc_d_quote && e == "\""
                ? str(a, "\"\"")
                : str(a, "\\", esc_chars[1][found_is[0]])
              : str(a, e)
            )
          : obj
      )
      quote_strings
      ? str("\"", s, "\"")
      : s
    : is_list(obj)
    ? len(obj) == 0
      ? "[]"
      : str(
          // reduce(str("[", obj_to_string(obj[0], fmt_fn, esc_chars, quote_strings, csv_esc_d_quote)), fwd_i(obj, 1))(
          //   function(i, acc) str(acc, ", ", obj_to_string(obj[i], fmt_fn, esc_chars, quote_strings, csv_esc_d_quote))
          // ), "]"
          it_each(obj, reduce(str("[", obj_to_string(obj[0], fmt_fn, esc_chars, quote_strings, csv_esc_d_quote))), 1)(
            function(e, acc) str(acc, ", ", obj_to_string(e, fmt_fn, esc_chars, quote_strings, csv_esc_d_quote))
          ), "]"
        )
    : str(obj)
;

echo("This should show three lines with these chars not escaped: \"\r\n\t\\\".");
echo(["This should show one line with these chars escaped: \"\r\n\t\\\"."]);
echo(obj_to_string(["This should show one line with these chars escaped: \"\r\n\t\\\"."]));

echo(str("o2s: ", obj_to_string("hello")));
echo(str("o2s: ", obj_to_string("he\"llo")));
echo(str("o2s: ", obj_to_string("he\"llo", esc_chars=["",""])));
echo(str("o2s: ", obj_to_string("he\nllo")));
echo(str("o2s: ", obj_to_string(1)));
echo(str("o2s: ", obj_to_string(["hello",1])));
echo(str("o2s: ", obj_to_string(["he\"llo",1])));
echo(str("o2s: ", obj_to_string(["he\nllo",1])));
echo(str("o2s: ", obj_to_string(["hello"])));

/**
 * Converts a 2D array to a csv string.  If an element contains a double quote,
 * comma or newline, enclose it in double quotes and escape any double quotes.
 *
 * @param {list[list[any]]} a
 *   A 2D list of any object types to convert to a CSV.
 * @param {(function(e): string|undef)} fmt_fn
 *   Uses this to convert a field into a string if a string is returned.
 * @param {bool} [RFC_4180=true]
 *   - If true, a double quote (") will be replaced by a double double quote
 *     ("") within a string.  Line feeds not preceded with carriage returns will
 *     have the line feeds added.  This is to conform to IETF RFC 4180:
 *     https://datatracker.ietf.org/doc/html/rfc4180
 *   - If false, double quotes and backslashes will be backslash escaped and
 *     line endings are left as is and new ones added will be "\n".
 *
 * @returns {string}
 *   Returns a string of the 2D list `a` as a CSV string.
 */
function to_csv(a, fmt_fn = function(e) undef, RFC_4180 = true) =
  assert(is_list(a), str("First level of a (", a, ") must be a list"))
  let (
    EOL = RFC_4180 ? "\r\n" : "\n",
    esc_quotes = RFC_4180 ? [ "\"", "\"" ] : [ "\"\\", "\"\\" ],
    to_field = function(f)
      // convert field into string if not a string
      let (f = is_string(f) ? f : obj_to_string(f, fmt_fn, esc_quotes, csv_esc_d_quote = RFC_4180))
      // quote string if contains a double quote, comma or newline
      let (f =
        is_undef(it_each("\",\n", find())( function(e) search(e, f) ))
        ? f
        : obj_to_string(f, fmt_fn, esc_quotes, csv_esc_d_quote = RFC_4180)
      )
      RFC_4180
      ? is_undef(it_idxs(f, find(), 1)( function(i)
          f[i] == "\n" && f[i-1] != "\r"
        ))
        ? f
        : it_idxs(f, reduce(f[0]), 1)( function(i, acc)
            f[i] == "\n" && f[i-1] != "\r"
            ? str ( acc, EOL )
            : str ( acc, f[i] )
          )
      : f
    ,
    to_csv_row = function(r)
      assert(is_list(r), str("Second level of a (", r, ") must be a list"))
      len(r) == 0
      ? EOL
      : str(
          it_each(r, reduce(to_field(r[0])), 1)(
            function(e, acc) str(acc, ",", to_field(e))
          ), EOL
        )
  )
  len(a) == 0
  ? ""
  : it_each(a, reduce(""))(
    function(e, acc) str(acc, to_csv_row(e))
  )
;
echo(to_csv([["hello", "th,ere", "ou\nt", "th\"ere"]]));

/**
 * Takes a 1D list and outputs it as a string with only row_length elements on
 * each row.
 *
 * E.g.  If row_length were 3 then we'd get something like this:
 *
 *     [
 *        a, b, c,
 *        d, e, f
 *     ]
 *
 *
 * If the row_length doesn't evenly divide into the length of the list, it will
 * be padded with undef at the end.
 *
 * @param {list} list
 *   A list to prettify.
 * @param {number} [row_length=0]
 *   The number of elements to show per line. 0 means list is printed as one row.
 * @param {function(i: number, e: any, indent: str): str} [fmt_el_fn=fmt_list_fn()]
 *   Format element callback.  Where `i` is the index of the element, `e` is the
 *   element at `i` and `indent` is the characters to put at the beginning of
 *   the line.  Returns a string representation of the element.
 * @param {string} [indent=""]
 *   The character to put at the beginning of each line.
 * @param {bool} [indent_first_line=false]
 *   States if to indent the first line.
 * @param {string} [new_indent="  "]
 *   The indent string to add when adding a new indent level.
 * @param {bool} [only_first_and_last=false]
 *   States if to output only first and last row (true) or all rows (false).
 *
 * @returns {string}
 *   Prettified list.
 */
function list_to_string(list, row_length = 0, fmt_el_fn = fmt_list_fn(),
  indent = "", indent_first_line = false, new_indent = "  ", only_first_and_last = false
) =
  len(list) == 0
  ? "[]"
  : let (
      output_row_fn = function(i, acc, row_length = row_length, new_indent = new_indent)
        reduce(
          str(acc, indent, new_indent, fmt_el_fn(i, list[i], indent)),
          i+1, i+row_length-1)
        (
          function(i, acc)
            // echo(str("list: ", list, " i: ", i, " acc: ", acc))
            str(acc, ", ", fmt_el_fn(i, list[i], indent))
        )
    )
    row_length == 0
    ?
      let (result = output_row_fn(0, "", len(list), ""))
      str(
        "[",
        result,
        "]"
      )
    :
    only_first_and_last
    ? str(
        indent_first_line ? indent : "",
        output_row_fn(0, "[\n"),
        len(list) > row_length
        ? str(
            // echo(str("len(list) > row_length * 2 = ", len(list), " > ", row_length, " * ", 2))
            len(list) > row_length * 2
            ? str(",\n", indent, new_indent, "...\n")
            : ",\n",
            output_row_fn((ceil(len(list)/row_length)-1)*row_length, "")
          )
        : "",
        "\n",
        indent,
        "]"
      )
    : str(
        indent_first_line ? indent : "",
        reduce(
          output_row_fn(0, "[\n"),
          range(row_length, row_length, len(list)-1))
        (
          function(i, acc)
            output_row_fn(i, str(acc, ",\n"))
        ),
        "\n",
        indent,
        "]"
      )
;

/**
 * Used to pass resulting lambda to list_to_string to format any numbers that
 * are found with a precision and sign formatting.  Everything else is rendered
 * by str().
 *
 * @param {number} precision
 *   Number of decimal places to show.
 * @param {number} show_sign
 *   SHOW_SIGN_NEG - States if to only show a negative sign.
 *   SHOW_SIGN_POS_NEG - states if to show positive/negative signs.
 *   SHOW_SIGN_SPC_NEG - States if to show space for positive sign or negative sign.
 *
 * @returns {function(i: number, e: any, indent: string) : string}
 *   Returns the lambda to render an element.
 */
function fmt_list_fn(precision=6, show_sign=SHOW_SIGN_SPC_NEG) =
  function(i, e, indent)
    is_list(e)
    ? list_to_string(e, len(e), fmt_list_fn(precision, show_sign), str(indent, "  "))
    : is_num(e)
      ? float_to_string(e, precision=precision, show_sign=show_sign)
      : str(e)
;

/**
 * Passed to `list_to_string`, this will format elements as if they are a list
 * of coordinates, placing coordinates of one row over another aligning over the
 * decimal point.
 *
 * @param {number} precision
 *   The number of decimal places to output.
 * @param {number} show_sign
 *   `SHOW_SIGN_NEG` - States if to only show a negative sign.
 *   `SHOW_SIGN_POS_NEG` - states if to show positive/negative signs.
 *   `SHOW_SIGN_SPC_NEG` - States if to show space for positive sign or negative sign.
 * @param {list[number,...]} [min_widths]
 *   If specified, will output coord with minimum width of each specified by
 *   corresponding value in this list.
 *
 * @returns {function(i: number, e: any, indent: string) : string}
 *   Returns the lambda to render an element.
 *
 *   If an element is not a list, will output `*UNEXPECTED* ` followed by what
 *   the element was.
 */
function fmt_pt_list_fn(precision=6, show_sign=SHOW_SIGN_SPC_NEG, min_widths_for_pts = undef) =
  function(i, e, indent)
    is_list(e)
    ? let(
        min_widths_for_pt =
          min_widths_for_pts
          ? min_widths_for_pts[i % len(min_widths_for_pts)]
          : undef
      )
      // echo(str("fmt_pt_list_fn min_widths_for_pts: ", min_widths_for_pts, " i: ", i, " min_widths_for_pt: ", min_widths_for_pt))
      list_to_string(e, 0, fmt_pt_fn(precision, show_sign,  min_widths_for_pt))
    : str("*UNEXPECTED* ", e)
;

/**
 * Passed to `list_to_string`, this will format element as if it's a coordinate.
 *
 * @param {number} precision
 *   The number of decimal places to output.
 * @param {number} show_sign
 *   SHOW_SIGN_NEG - States if to only show a negative sign.
 *   SHOW_SIGN_POS_NEG - states if to show positive/negative signs.
 *   SHOW_SIGN_SPC_NEG - States if to show space for positive sign or negative sign.
 * @param {list[number,...]} [min_widths_for_dims]
 *   If specified, will output coord with minimum width of each specified by
 *   corresponding value in this list.
 *
 * @returns {function(i: number, e: any, indent: string) : string}
 *   Returns the lambda to render an element.
 *
 *   If an element is not a number, will output `*UNEXPECTED* ` followed by what
 *   the element was.
 */
function fmt_pt_fn(precision=6, show_sign=SHOW_SIGN_SPC_NEG, min_widths_for_dims = undef) =
  function(i, e, indent)
    is_num(e)
    ?
      // echo("fmt_pt_fn min_widths_for_dims: ", min_widths_for_dims, " i: ", i)
      float_to_string(e, precision=precision, left_justified=false,
        show_sign=show_sign, min_width = default(min_widths_for_dims[i], 1))
    : str("*UNEXPECTED* ", e)
;

/**
 * Formats a list of points aligning cols over rows.
 *
 * @param {list[Point,...]} pts
 *   A list of coordinates.
 * @param {number} cols
 *   Number of columns
 * @param {unused} rows
 * @param {string} [indent=""]
 *   The character to put at the beginning of each line.
 * @param {bool} [only_first_and_last=false]
 *   States if to output only first and last row (true) or all rows (false).
 * @param {number} [precision=4]
 *   The number of decimal places to output.
 *
 * @returns {string}
 *   String with the aligned points.
 */
function pt_list_to_string(pts, cols, rows, indent = "", only_first_and_last = false, precision = 4) =
  let (
    min_widths = map(0, cols-1)(function(col)
      // echo(str("col: ", col))
      map(0, len(pts[col])-1)(function(dim_i)
        // echo(str("dim: ", dim_i))
        it_each(pts, reduce(0), range(col, cols, len(pts)-1))(function(pt, acc)
          // echo(str("pt: ", pt, " acc: ", acc, " precision: ", precision))
          let (
            // num of digits and `.`.
            v = round(abs(pt[dim_i]) * 10^precision),
            width = 1 + (v ? floor(log(v)) : precision) + (precision > 0 ? 1 : 0)
          )
          // echo(str("v: ", v, " width: ", width))
          max(acc, width + 1) // + 1 for sign
        )
      )
    )
  )
  // echo(str("min_widths: ", min_widths))
  list_to_string(pts, cols,
    fmt_pt_list_fn(precision, min_widths_for_pts=min_widths),
    str(indent, "  "), only_first_and_last = only_first_and_last)
;
echo("pt_list_to_string", pt_list_to_string([[1, 10, 4], [1,5,0]], 2, 3, ""));
echo("pt_list_to_string", pt_list_to_string([[1, 10, 4], [1,5,0], [1,5,0], [1, 10, 4]], 2, 3, ""));

let(a = [1, 2, [3, 4, 5, 6, 7], 8])
echo(
  list_to_string(a, 1,
    function(i, e, indent)
      is_list(e)
      ? list_to_string(e, 2, indent = str(indent, "  "))
      : e
  )
);

let(a = [1,2,3,2,3,4])
echo(
  list_to_string(a, 2, only_first_and_last=1)
);
