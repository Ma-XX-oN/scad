use <list>
use <types>
use <range>
use <test>
use <birlei>
use <function>

/**
 * Negate a lambda's return value
 *
 * @param not_fn (function (p) : any)
 *   The function to invert the boolean's (or equivalent truthy/falsy) value.
 *
 * @returns (function (p) : bool)
 *   Return the lambda that will invert a lambda's truth value.
 */
function not(not_fn) =
  // echo("NOT: ", not_fn)
  assert(is_function(not_fn))
  function(p) !not_fn(p)
;

/**
 * @overload find_lower(spaceship_fn, begin_i, end_i) : (number | undef)
 * @overload find_lower(spaceship_fn, range_is) : (number | undef)
 * @overload find_lower(spaceship_fn, list_is) : (number | undef)
 *
 * Like C++ lower_bound: returns the first index i for which spaceship_fn(i) >=
 * 0.
 *
 * NOTE: The specified range or list of indices must be such that
 *       spaceship_fn(i) is monotonically nondecreasing over the searched
 *       indices; otherwise results are undefined.
 *
 * @param spaceship_fn (function(i) : number)
 *   This is a trinary predicate where if the element i is less than the
 *   searched value, then it would return a value < 0.  If the element i is
 *   equal to the searched value, then it should be equal to 0.  Otherwise it
 *   should be > 0.
 * @param birl (number | range | list)
 *   - If number, start index to check
 *   - If range, indices to check
 *   - If list, indices to check
 * @param begin_i (number)
 *   - Start index to check.
 * @param end_i (number | undef)
 *   - If birl is a number, end index to check.  If end_i < birl then
 *     spaceship_fn is never called, making this function return undef.
 * @param range_is (range)
 *   - Range of indices to check.
 * @param list_is (list)
 *   - List of indices to check.
 *
 * @returns (number | undef)
 *   First index where spaceship_fn(i) >= 0.  If none are found, returns undef.
 *
 *   NOTE: The reason for returning undef rather than end_i+1, is because birl
 *         could be a noncontiguous range or list of indices.
 */
function find_lower(spaceship_fn, birl, end_i) =
  let (
    _find_binary = function(_spaceship_fn, begin_i, end_i)
      begin_i == end_i
        ? begin_i
        : let (
            mid_i = floor((begin_i + end_i) / 2),
            result = _spaceship_fn(mid_i)
          )
          result >= 0
            ? _find_binary(_spaceship_fn, begin_i,   mid_i)  // first-true lies at/before mid_i
            : _find_binary(_spaceship_fn, mid_i + 1, end_i)  // still false at mid_i -> go right

  )
  birlei_to_begin_i_end_i(
    function(_spaceship_fn, begin_i, end_i, map_back_fn)
      end_i < begin_i || _spaceship_fn(end_i) < 0
      ? undef
      : map_back_fn(_find_binary(_spaceship_fn, begin_i, end_i)),
    spaceship_fn, birl, end_i)
;

/** Hoists function into variable ns to be able to pass as a lambda */
function function_find_lower() =
  function(spaceship_fn, birl, end_i)
    find_lower(spaceship_fn, birl, end_i)
;

/**
 * @overload fn_find_lower(begin_i, end_i) : (function(ppmrrair_fn) : (number | undef))
 * @overload fn_find_lower(range_is) : (function(ppmrrair_fn) : (number | undef))
 * @overload fn_find_lower(list_is) : (function(ppmrrair_fn) : (number | undef))
 * @overload fn_find_lower() : (function(ppmrrair_fn, birl, end_i) : (number | undef))
 *
 * Give a compatible function signature that can be used in in_list or allows
 * the spaceship_fn to be placed after the birl/end_i parameters for clarity.
 *
 * @param init (any)
 *   This is the initial value that will be passed to reduce.
 * @param birl (number | range | list | undef)
 *   - If undef, then returns function(spaceship_fn, birl, end_i) : any,
 *     otherwise returns function(spaceship_fn) : any.  This allows for
 *     placing the range at the top of the function call to make code easier to
 *     read.
 *   - If number, start index to check
 *   - If range, indices to check
 *   - If list, indices to check
 * @param end_i (number | undef)
 *   - If birl is a number, end index to check.  If end_i < birl then
 *     spaceship_fn is never called, making this function return init.
 *
 * @returns (function(spaceship_fn, birl, end_i) : any |
 *           function(spaceship_fn) : any)
 *   Function to pass to in_list, or to allow placing the PPMRAIR function
 *   after the birl/end_i for easier reading.
 */
function fn_find_lower(birl=undef, end_i=undef) =
  birl == undef
  ? function(spaceship_fn, birl, end_i) find_lower(spaceship_fn, birl, end_i)
  : function(spaceship_fn)              find_lower(spaceship_fn, birl, end_i)
;

let (v = 0) test_eq(v, echo(str("Searching for ", v)) in_list([0,1,2,3,4], function_find_lower(), function(e) e-v));
let (v = 1) test_eq(v, echo(str("Searching for ", v)) in_list([0,1,2,3,4], function_find_lower(), function(e) e-v));
let (v = 2) test_eq(v, echo(str("Searching for ", v)) in_list([0,1,2,3,4], function_find_lower(), function(e) e-v));
let (v = 3) test_eq(v, echo(str("Searching for ", v)) in_list([0,1,2,3,4], function_find_lower(), function(e) e-v));
let (v = 4) test_eq(v, echo(str("Searching for ", v)) in_list([0,1,2,3,4], function_find_lower(), function(e) e-v));
let (v = 5) test_eq(undef, echo(str("Searching for ", v)) in_list([0,1,2,3,4], function_find_lower(), function(e) e-v));
let (v = 7) test_eq(v, echo(str("Searching for ", v)) in_list([0,1,2,3,4,5,6,7], function_find_lower(), function(e) e-v));
let (v = 2) test_eq(2, echo(str("Searching for ", v)) in_list([0,1,2,2,4], function_find_lower(), function(e) e-v));
let (v = 2) test_eq(2, echo(str("Searching for ", v)) in_list([0,1,2,2,2], function_find_lower(), function(e) e-v));
let (v = 2) test_eq(1, echo(str("Searching for ", v)) in_list([0,2,2,2,2], function_find_lower(), function(e) e-v));
let (v = 3) test_eq(undef, echo(str("Searching for ", v)) in_list([0,2,2,2,2], function_find_lower(), function(e) e-v));

/**
 * @overload find_upper(spaceship_fn, begin_i, end_i) : (number | undef)
 * @overload find_upper(spaceship_fn, range_is) : (number | undef)
 * @overload find_upper(spaceship_fn, list_is) : (number | undef)
 *
 * Like C++ upper_bound: returns the first index i for which spaceship_fn(i) >
 * 0.
 *
 * NOTE: The specified range or list of indices must be such that
 *       spaceship_fn(i) is monotonically nondecreasing over the searched
 *       indices; otherwise results are undefined.
 *
 * @param spaceship_fn (function(i) : number)
 *   This is a trinary predicate where if the element i is less than the
 *   searched value, then it would return a value < 0.  If the element i is
 *   equal to the searched value, then it should be equal to 0.  Otherwise it
 *   should be > 0.
 * @param birl (number | range | list)
 *   - If number, start index to check
 *   - If range, indices to check
 *   - If list, indices to check
 * @param begin_i (number)
 *   - Start index to check.
 * @param end_i (number | undef)
 *   - If birl is a number, end index to check.  If end_i < birl then
 *     spaceship_fn is never called, making this function return undef.
 * @param range_is (range)
 *   - Range of indices to check.
 * @param list_is (list)
 *   - List of indices to check.
 *
 * @returns (number | undef)
 *   First index where spaceship_fn(i) > 0.  If none are found, returns undef.
 *
 *   NOTE: The reason for returning undef rather than end_i+1, is because birl
 *         could be a noncontiguous range or list of indices.
 */
function find_upper(spaceship_fn, birl, end_i) =
  let (
    _find_binary = function(_spaceship_fn, begin_i, end_i)
      begin_i == end_i
        ? begin_i
        : let (
            mid_i = floor((begin_i + end_i) / 2),
            result = _spaceship_fn(mid_i)
          )
          (result > 0
            ? _find_binary(_spaceship_fn, begin_i,   mid_i)  // first-true (>0) at/before mid_i
            : _find_binary(_spaceship_fn, mid_i + 1, end_i)  // still <= 0 at mid_i -> go right
          )
  )
  birlei_to_begin_i_end_i(
    function(_spaceship_fn, begin_i, end_i, map_back_fn)
      end_i < begin_i || _spaceship_fn(end_i) <= 0
      ? undef
      : map_back_fn(_find_binary(_spaceship_fn, begin_i, end_i)),
    spaceship_fn, birl, end_i)
;

/** Hoists function into variable ns to be able to pass as a lambda */
function function_find_upper() =
  function(spaceship_fn, birl, end_i)
    find_upper(spaceship_fn, birl, end_i)
;

/**
 * @overload fn_find_upper(begin_i, end_i) : (function(ppmrrair_fn) : (number | undef))
 * @overload fn_find_upper(range_is) : (function(ppmrrair_fn) : (number | undef))
 * @overload fn_find_upper(list_is) : (function(ppmrrair_fn) : (number | undef))
 * @overload fn_find_upper() : (function(ppmrrair_fn, birl, end_i) : (number | undef))
 *
 * Give a compatible function signature that can be used in in_list or allows
 * the spaceship_fn to be placed after the birl/end_i parameters for clarity.
 *
 * @param init (any)
 *   This is the initial value that will be passed to reduce.
 * @param birl (number | range | list | undef)
 *   - If undef, then returns function(spaceship_fn, birl, end_i) : any,
 *     otherwise returns function(spaceship_fn) : any.  This allows for
 *     placing the range at the top of the function call to make code easier to
 *     read.
 *   - If number, start index to check
 *   - If range, indices to check
 *   - If list, indices to check
 * @param end_i (number | undef)
 *   - If birl is a number, end index to check.  If end_i < birl then
 *     spaceship_fn is never called, making this function return init.
 *
 * @returns (function(spaceship_fn, birl, end_i) : any |
 *           function(spaceship_fn) : any)
 *   Function to pass to in_list, or to allow placing the PPMRAIR function
 *   after the birl/end_i for easier reading.
 */
function fn_find_upper(birl=undef, end_i=undef) =
  birl == undef
  ? function(spaceship_fn, birl, end_i) find_upper(spaceship_fn, birl, end_i)
  : function(spaceship_fn)              find_upper(spaceship_fn, birl, end_i)
;

let (v = 0) test_eq(v+1, echo(str("Searching for ", v)) in_list([0,1,2,3,4], function_find_upper(), function(e) e-v));
let (v = 1) test_eq(v+1, echo(str("Searching for ", v)) in_list([0,1,2,3,4], function_find_upper(), function(e) e-v));
let (v = 2) test_eq(v+1, echo(str("Searching for ", v)) in_list([0,1,2,3,4], function_find_upper(), function(e) e-v));
let (v = 3) test_eq(v+1, echo(str("Searching for ", v)) in_list([0,1,2,3,4], function_find_upper(), function(e) e-v));
let (v = 4) test_eq(undef, echo(str("Searching for ", v)) in_list([0,1,2,3,4], function_find_upper(), function(e) e-v));
let (v = 7) test_eq(undef, echo(str("Searching for ", v)) in_list([0,1,2,3,4,5,6,7], function_find_upper(), function(e) e-v));
let (v = 5) test_eq(undef, echo(str("Searching for ", v)) in_list([0,1,2,3,4], function_find_upper(), function(e) e-v));
let (v = 2) test_eq(4, echo(str("Searching for ", v)) in_list([0,1,2,2,4], function_find_upper(), function(e) e-v));
let (v = 2) test_eq(undef, echo(str("Searching for ", v)) in_list([0,1,2,2,2], function_find_upper(), function(e) e-v));
let (v = 2) test_eq(undef, echo(str("Searching for ", v)) in_list([0,2,2,2,2], function_find_upper(), function(e) e-v));

/**
 * @overload find(pred_fn, begin_i, end_i) : (number | undef)
 * @overload find(pred_fn, range_is) : (number | undef)
 * @overload find(pred_fn, list_is) : (number | undef)
 *
 * Returns the first index that results in pred_fn(i) returning a truthy
 * result.
 *
 * @param pred_fn (function(i) : bool)
 *   Where i is an index, if returns a truthy value, will stop searching and
 *   return i.
 * @param birl (number | range | list)
 *   - If number, start index to check
 *   - If range, indices to check
 *   - If list, indices to check
 * @param begin_i (number)
 *   - Start index to check.
 * @param end_i (number | undef)
 *   - If birl is a number, end index to check.  If end_i < birl then
 *     pred_fn is never called, making this function return undef.
 * @param range_is (range)
 *   - Range of indices to check.
 * @param list_is (list)
 *   - List of indices to check.
 *
 * @returns (number | undef)
 *   If a call to pred_fn(i) returns truthy, will return i.  Otherwise
 *   will return undef.
 */
function find(pred_fn, birl, end_i) =
  let (
    _find_linear = function(_pred_fn, begin_i, end_i)
      begin_i <= end_i
      ? // echo("find_helper linear: ", begin_i, _pred_fn)
        _pred_fn(begin_i)
        ? begin_i
        : _find_linear(_pred_fn, begin_i + 1, end_i)
      : undef
  )
  birlei_to_begin_i_end_i(
    function(_pred_fn, begin_i, end_i, map_back_fn)
      end_i < begin_i
      ? undef
      : map_back_fn(_find_linear(_pred_fn, begin_i, end_i)),
    pred_fn, birl, end_i)
;

/** Hoists function into variable ns to be able to pass as a lambda */
function function_find() =
  function(pred_fn, birl, end_i)
    find(pred_fn, birl, end_i)
;

/**
 * @overload fn_find(begin_i, end_i) : (function(ppmrrair_fn) : (number | undef))
 * @overload fn_find(range_is) : (function(ppmrrair_fn) : (number | undef))
 * @overload fn_find(list_is) : (function(ppmrrair_fn) : (number | undef))
 * @overload fn_find() : (function(ppmrrair_fn, birl, end_i) : (number | undef))
 *
 * Give a compatible function signature that can be used in in_list or allows
 * the pred_fn to be placed after the birl/end_i parameters for clarity.
 *
 * @param init (any)
 *   This is the initial value that will be passed to reduce.
 * @param birl (number | range | list | undef)
 *   - If undef, then returns function(pred_fn, birl, end_i) : any,
 *     otherwise returns function(pred_fn) : any.  This allows for placing
 *     the range at the top of the function call to make code easier to read.
 *   - If number, start index to check
 *   - If range, indices to check
 *   - If list, indices to check
 * @param end_i (number | undef)
 *   - If birl is a number, end index to check.  If end_i < birl then
 *     pred_fn is never called, making this function return init.
 *
 * @returns (function(pred_fn, birl, end_i) : any |
 *           function(pred_fn) : any)
 *   Function to pass to in_list, or to allow placing the PPMRAIR function
 *   after the birl/end_i for easier reading.
 */
function fn_find(birl=undef, end_i=undef) =
  birl == undef
  ? function(pred_fn, birl, end_i) find(pred_fn, birl, end_i)
  : function(pred_fn)              find(pred_fn, birl, end_i)
;

/**
 * @overload reduce(op_fn, init, begin_i, end_i) : init_result
 * @overload reduce(op_fn, init, range_is) : init_result
 * @overload reduce(op_fn, init, list_is) : init_result
 *
 * Reduces (a.k.a. folds) a set of indices to produce some value/object based on
 * the indices.
 *
 * @param op_fn (function(i, acc) : any)
 *   Reduction callback, where `i` is the index and `acc` is the accumulator.
 *   Returns new accumulator value.
 *
 *   NOTE: acc IS THE SECOND PARAMETER which is different from most languages.
 *         This is to keep it consistent with the rest of the PPMRRAIR
 *         functions and this library in general.  You have been warned.
 *
 * @param birl (number | range | list)
 *   - If number, start index to check
 *   - If range, indices to check
 *   - If list, indices to check
 * @param end_i (number | undef)
 *   - If birl is a number, end index to check.  If end_i < birl then
 *     op_fn is never called, making this function return init.
 *
 * @returns (any)
 *   Final value of accumulator.
 */
function reduce(op_fn, init, birl, end_i) =
  // echo(str("reduce:\n  ", op_fn, "\n  ", type_value(init), "\n  ", birl, ", ", end_i ))
  let (
    _reduce_linear = function(op_fn, acc, begin_i, end_i)
      end_i > begin_i
      ?
        assert(param_count(op_fn) == 2, op_fn)
        assert(param_count(_reduce_linear) == 4)
        let( result = op_fn(begin_i, acc) )
        _reduce_linear(op_fn, result, begin_i + 1, end_i)
      : op_fn(begin_i, acc)
  )
  birlei_to_begin_i_end_i(
    function (op_fn, begin_i, end_i, map_back_fn)
      assert(param_count(op_fn) == 2, op_fn)
      end_i < begin_i
      ? init
      : _reduce_linear(op_fn, init, begin_i, end_i),
    op_fn, birl, end_i)
;

/** Hoists function into variable ns to be able to pass as a lambda */
function function_reduce() =
  function(op_fn, init, birl, end_i)
    reduce(op_fn, init, birl, end_i)
;

/**
 * @overload fn_reduce(init, begin_i, end_i) : (function(ppmrrair_fn) : init_result)
 * @overload fn_reduce(init, range_is) : (function(ppmrrair_fn) : init_result)
 * @overload fn_reduce(init, list_is) : (function(ppmrrair_fn) : init_result)
 * @overload fn_reduce(init) : (function(ppmrrair_fn, birl, end_i) : init_result)
 *
 * Give a compatible function signature that can be used in in_list by setting
 * the initial value of init or allows the op_fn to be placed after the
 * birl/end_i parameters for clarity.
 *
 * @param init (any)
 *   This is the initial value that will be passed to reduce.
 * @param birl (number | range | list | undef)
 *   - If undef, then returns function(op_fn, birl, end_i) : any,
 *     otherwise returns function(op_fn) : any.  This allows for placing
 *     the range at the top of the function call to make code easier to read.
 *   - If number, start index to check
 *   - If range, indices to check
 *   - If list, indices to check
 * @param end_i (number | undef)
 *   - If birl is a number, end index to check.  If end_i < birl then
 *     op_fn is never called, making this function return init.
 *
 * @returns (function(op_fn, birl, end_i) : any |
 *           function(op_fn) : any)
 *   Function to pass to in_list, or to allow placing the PPMRAIR function
 *   after the birl/end_i for easier reading.
 *
 *   NOTE: op_fn expects that acc IS THE SECOND PARAMETER which is
 *         different from most languages.
 *         This is to keep it consistent with the rest of the PPMRRAIR
 *         functions and this library in general.  You have been warned.
 */
function fn_reduce(init, birl=undef, end_i=undef) =
  birl == undef
  ? function(op_fn, birl, end_i) reduce(op_fn, init, birl, end_i)
  : function(op_fn)              reduce(op_fn, init, birl, end_i)
;

/**
 * @overload reduce_air(op_fn, init, begin_i, end_i) : [cont, init_result]
 * @overload reduce_air(op_fn, init, range_is) : [cont, init_result]
 * @overload reduce_air(op_fn, init, list_is) : [cont, init_result]
 *
 * Reduces (a.k.a. folds) a set of indices to produce some value/object based on
 * the indices.  This Reduction Allows for Incomplete Reduction.
 *
 * @param op_fn (function(i, acc) : list)
 *   Reduction callback, where `i` is the index and `acc` is the accumulator.
 *   Returns a list where element 0 is true if to continue to next iteration or
 *   false if to stop.  Element 1 is the new accumulator value.
 *
 *   NOTE: acc IS THE SECOND PARAMETER which is different from most languages.
 *         This is to keep it consistent with the rest of the PPMRRAIR
 *         functions and this library in general.  You have been warned.
 *
 * @param birl (number | range | list)
 *   - If number, start index to check
 *   - If range, indices to check
 *   - If list, indices to check
 * @param end_i (number | undef)
 *   - If birl is a number, end index to check.  If end_i < birl then
 *     op_fn is never called, making this function return init.
 *
 * @returns (list)
 *   Index 0 is a boolean. truthy indicates the entire range was processed.
 *   Index 1 is the final value of accumulator.
 */
function reduce_air(op_fn, init, birl, end_i) =
  // echo(str("reduce:\n  ", op_fn, "\n  ", init, "\n  ", birl, ", ", end_i ))
  let (
    _reduce_linear = function(op_fn, acc, begin_i, end_i)
      end_i > begin_i
      ? let (result = op_fn(begin_i, acc))
        result[0]
        ? _reduce_linear(op_fn, result[1], begin_i + 1, end_i)
        : result
      : op_fn(begin_i, acc)
  )
  birlei_to_begin_i_end_i(
    function (op_fn, begin_i, end_i, map_back_fn)
      end_i < begin_i
      ? init
      : _reduce_linear(op_fn, init, begin_i, end_i),
    op_fn, birl, end_i)
;

/** Hoists function into variable ns to be able to pass as a lambda */
function function_reduce_air() =
  function(op_fn, init, birl, end_i)
    reduce_air(op_fn, init, birl, end_i)
;

/**
 * @overload fn_reduce_air(init, begin_i, end_i) : (function(ppmrrair_fn) : [cont, init_result])
 * @overload fn_reduce_air(init, range_is) : (function(ppmrrair_fn) : [cont, init_result])
 * @overload fn_reduce_air(init, list_is) : (function(ppmrrair_fn) : [cont, init_result])
 * @overload fn_reduce_air(init) : (function(ppmrrair_fn, birl, end_i) : [cont, init_result])
 *
 * Give a compatible function signature that can be used in in_list by setting
 * the initial value of init.
 *
 * @param init (any)
 *   This is the initial value that will be passed to reduce_air.
 * @param birl (number | range | list | undef)
 *   - If undef, then returns function(op_fn, birl, end_i) : any,
 *     otherwise returns function(op_fn) : any.  This allows for placing
 *     the range at the top of the function call to make code easier to read.
 *   - If number, start index to check
 *   - If range, indices to check
 *   - If list, indices to check
 * @param end_i (number | undef)
 *   - If birl is a number, end index to check.  If end_i < birl then
 *     op_fn is never called, making this function return init.
 *
 * @returns (function(op_fn, birl, end_i) : any)
 *   Function to pass to in_list, or to allow placing the PPMRRAIR function
 *   after the birl/end_i for easier reading.
 *
 *   NOTE: op_fn expects that acc IS THE SECOND PARAMETER which is
 *         different from most languages.
 *         This is to keep it consistent with the rest of the PPMRRAIR
 *         functions and this library in general.  You have been warned.
 */
function fn_reduce_air(init, birl, end_i) =
  birl == undef
  ? function(op_fn, birl, end_i) reduce_air(op_fn, init, birl, end_i)
  : function(op_fn)              reduce_air(op_fn, init, birl, end_i)
;

////////////////////////////////////////////////////////////////////////////////
// Map and Filter
////////////////////////////////////////////////////////////////////////////////

/**
 * @overload filter(ppm_fn, begin_i, end_i) : list
 * @overload filter(ppm_fn, range_is) : list
 * @overload filter(ppm_fn, list_is) : list
 *
 * Filter function.
 *
 * @param ppm_fn (function(i) : bool | function(i, v) : bool)
 *   - If this takes 1 parameter, then if it return a truthy value, add the
 *     index to the list.
 *   - If this takes 2 parameters, then if passed only 1 parameter needs to call
 *     with a truthy as the second parameter and adds the returned value to the
 *     list.
 * @param birl (number | range | list)
 *   - If number, start index to check
 *   - If range, indices to check
 *   - If list, indices to check
 * @param end_i (number | undef)
 *   - If birl is a number, end index to check.  If end_i is less than birl,
 *     then ppm_fn() is never called, so filter will return an empty
 *     list.
 *
 * @returns (list)
 *   Returns a list of all indices or elements where ppm_fn returned
 *   a truthy value.
 */
function filter(ppm_fn, birl, end_i) =
  let (
    indices = birlei_to_indices(birl, end_i),
    pc = param_count(ppm_fn)
  )
  assert(pc == 1 || pc == 2, str("ppm_fn must be a function with 1 or 2 params, not ", pc, "."))
  pc == 1
  ? [
    for (i = indices) if (ppm_fn(i)) i
  ]
  : [
    for (i = indices) if (ppm_fn(i)) ppm_fn(i, true)
  ]
;

/** Hoists function into variable ns to be able to pass as a lambda */
function function_filter() =
  function(ppm_fn, birl, end_i)
    filter(ppm_fn, birl, end_i)
;

/**
 * @overload fn_filter(begin_i, end_i) : (function(ppmrrair_fn) : list)
 * @overload fn_filter(range_is) : (function(ppmrrair_fn) : list)
 * @overload fn_filter(list_is) : (function(ppmrrair_fn) : list)
 * @overload fn_filter() : (function(ppmrrair_fn, birl, end_i) : list)
 *
 * Give a compatible function signature that can be used in in_list or allows
 * the ppm_fn to be placed after the birl/end_i parameters for clarity.
 *
 * @param init (any)
 *   This is the initial value that will be passed to reduce.
 * @param birl (number | range | list | undef)
 *   - If undef, then returns function(ppm_fn, birl, end_i) : any,
 *     otherwise returns function(ppm_fn) : any.  This allows for
 *     placing the range at the top of the function call to make code easier to
 *     read.
 *   - If number, start index to check
 *   - If range, indices to check
 *   - If list, indices to check
 * @param end_i (number | undef)
 *   - If birl is a number, end index to check.  If end_i < birl then
 *     ppm_fn is never called, making this function return init.
 *
 * @returns (function(ppm_fn, birl, end_i) : any |
 *           function(ppm_fn) : any)
 *   Function to pass to in_list, or to allow placing the PPMRAIR function
 *   after the birl/end_i for easier reading.
 */
function fn_filter(birl=undef, end_i=undef) =
  birl == undef
  ? function(ppm_fn, birl, end_i) filter(ppm_fn, birl, end_i)
  : function(ppm_fn)              filter(ppm_fn, birl, end_i)
;

/**
 * @overload map(map_fn, begin_i, end_i) : list
 * @overload map(map_fn, range_is) : list
 * @overload map(map_fn, list_is) : list
 *
 * Map values to indices or array elements, producing an array that has as many
 * elements as indices provided.
 *
 * @param map_fn (function (i) : any)
 *   Function to take an index and return the remapped value/object.
 * @param birl (number | range | list)
 *   - If number, start index to check
 *   - If range, indices to check
 *   - If list, indices to check
 * @param end_i (number | undef)
 *   - If birl is a number, end index to check.  If end_i is less than birl,
 *     then map_fn() is never called, so map will return an empty list.
 *
 * @returns (list)
 *   A new mapped list.
 */
function map(map_fn, birl, end_i) =
  // echo(str("map birl: ", birl, " end_i: ", end_i))
  let (indices = birlei_to_indices(birl, end_i))
  // echo("indices: ", indices)
  [ for (i = indices)
      // echo("map", i)
      map_fn(i)
  ]
;

/** Hoists function into variable ns to be able to pass as a lambda */
function function_map() =
  function(map_fn, birl, end_i)
    map(map_fn, birl, end_i)
;

/**
 * @overload fn_map(begin_i, end_i) : (function(ppmrrair_fn) : list)
 * @overload fn_map(range_is) : (function(ppmrrair_fn) : list)
 * @overload fn_map(list_is) : (function(ppmrrair_fn) : list)
 * @overload fn_map() : (function(ppmrrair_fn, birl, end_i) : list)
 *
 * Give a compatible function signature that can be used in in_list or allows
 * the map_fn to be placed after the birl/end_i parameters for clarity.
 *
 * @param init (any)
 *   This is the initial value that will be passed to reduce.
 * @param birl (number | range | list | undef)
 *   - If undef, then returns function(map_fn, birl, end_i) : any,
 *     otherwise returns function(map_fn) : any.  This allows for
 *     placing the range at the top of the function call to make code easier to
 *     read.
 *   - If number, start index to check
 *   - If range, indices to check
 *   - If list, indices to check
 * @param end_i (number | undef)
 *   - If birl is a number, end index to check.  If end_i < birl then
 *     map_fn is never called, making this function return init.
 *
 * @returns (function(map_fn, birl, end_i) : any |
 *           function(map_fn) : any)
 *   Function to pass to in_list, or to allow placing the PPMRAIR function
 *   after the birl/end_i for easier reading.
 */
function fn_map(birl=undef, end_i=undef) =
  birl == undef
  ? function(map_fn, birl, end_i) map(map_fn, birl, end_i)
  : function(map_fn)              map(map_fn, birl, end_i)
;
