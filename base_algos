/**
 * ## base_algos
 *
 * ### How to Import
 *
 *     use <base_algos>
 *
 * ### Purpose
 *
 * The purpose of this library is to provide the minimum number of abstracted
 * composable algorithms to be able to make coding easier, both when reading and
 * writing.  They are quite fast, and although you could prolly make faster hand
 * rolled implementations, IMHO this makes it easier to read and rationalise as
 * to intent.  Also, the pattern used is repeated everywhere, making it easier
 * to learn how to use.
 *
 * ### FYI: Functions and Iterating are Abound!
 *
 * There is a lot of currying and passing of functions in this library.  (Mmmmmm
 * curry!)  No, not that type of curry.  Currying relates to having a function
 * return a function and using that function immediately.  For instance.  Say I
 * want to find the first instance of the letter "t" in a string.  Using this
 * library, the following could be done:
 *
 *     s = "Hello there!";
 *     i = find(fwd_i(s))(function(i)
 *           s[i] == "t"
 *         );
 *
 * Or it could be done using the algorithm adaptor `it_each` (See
 * [Algorithm Adaptors](#algorithm-adaptors)):
 *
 *     s = "Hello there!";
 *     i = it_each(s, find())(function(c)
 *           c == "t"
 *         );
 *
 * You'll notice the occurrence of `)(`.  This ends the algorithm or adaptor
 * call and start the next call which takes a function to test each element.
 * Also, observe that when the algorithm's `birlei` parameter is omitted, a
 * `function(birl, end_i)` is returned, which in this case is the function that
 * executes the `find` algorithm.  This reduces the algorithm down to standard
 * function signature.
 *
 * These 2 basic patterns are used everywhere in the library set, and though it
 * might look odd at first, you'll find that it becomes natural quite quickly.
 *
 * ### Iterators:
 *
 * The algorithms are index, not element centric, which means that a physical
 * container (i.e. a list) is *not* needed.  A virtual container (i.e. function)
 * is all that is required.  The indices act as iterators as one might find in
 * C++.  However, unlike C++ and python ranges, which are half open ranges
 * `[begin, end)`, these are closed ranges `[begin, end]`, meaning that the end
 * item is the last item in the range, not one past the end.
 *
 * For each of these algorithms, the `birl` parameter (formally
 * `begin_i_range_or_list`, but it became too much to type) state either:
 *
 * 1. Starting index (number)
 *    - Implies that a second `end_i` parameter will indicate the inclusive end
 *      index (number), conforming to OpenSCAD's closed range paradigm.
 * 2. Indices (range)
 *    - Will go through each item in the range and use them as indices to pass
 *      to the algorithm.  `end_i` must be `undef`.
 * 3. Indices (list)
 *    - Will go through each element in the list and use them as indices to pass
 *      to the algorithm.  `end_i` must be `undef`.
 *
 * ### Algorithms
 *
 * There are 4 basic algorithms (`reduce`, `reduce_air`, `filter` and `map`),
 * from which most other algorithms can be built.  For optimisation purposes,
 * `reduce_air` adds the ability to `A`llow an `I`ncomplete `R`eduction (hence
 * the `_air` suffix) over the range and filter adds a hybrid filter/map
 * feature.
 *
 * A few others (`find`, `find_upper`, `find_lower`) could have been implemented
 * with `reduce_air` but have been optimised with their own implementations.
 *
 * The `find*` and `reduce*` algorithms rely on recursive descent, but conform
 * to TCO (Tail Call Optimisation) so don't have a maximum depth.  The `filter`
 * and `map` algorithms use list comprehension so also have no limit to their
 * range size.
 *
 * > TTA:
 * >
 * > Should reduce_air's `init` param be `[ start, init ]` instead?  This would
 * > allow it to do nothing without the need for a special ternary check
 * > preceding it.
 * >
 * > A: I've yet not seen a good reason to do this.
 *
 * ### Algorithm Signatures
 *
 * All of the algorithms have a compatible signature that have a `birlei` (one
 * or two parameters, a `birl` and optional `end_i`).  When you call the
 * algorithm without the `birlei` parameter, it returns a function that takes
 * only a `birlei` parameter.  This is used with the
 * [Algorithms Adaptor](#algorithm-adaptors), potentially simplifying your code.
 * When it's passed a `birlei`, it returns a function that requires a PPMRRAIR
 * function.  That function that is then called by the algorithm on each index
 * that the `birlei` refers to.
 *
 * ### PPMRRAIR functions
 *
 * Named after the 4 function types: `P`redicate, `P`redicate/`M`ap, `R`eduction
 * and `R`eduction that `A`llows for `I`ncomplete `R`eduction, these functions
 * are passed to the algorithms where the algorithms then call them iteratively
 * over each `birlei` element:
 *
 * #### **Predicate** (`function(i) : result`)
 *
 * - A binary predicate is used by `find` and `filter`.  It has 2 results,
 *   truthy or falsy.
 * - A trinary predicate is used with `find_lower` and `find_upper`.  It has 3
 *   results: less than 0, equal to 0 and greater than 0.  This is akin to the
 *   spaceship operator in c++20.
 *
 * #### **Predicate/Map** (`function(i, v) : any`)
 *
 * - Optionally used by `filter`.
 * - If v is not passed then it has a falsy value (`undef`) indicating that the
 *   function is to act like a binary predicate.  Otherwise, if passed a true
 *   value, then it the function usually returns the element at that index,
 *   though can return anything which is to be placed in the resulting list.
 * - This 2 parameter function is a performance and memory allocation
 *   optimisation, allowing `filter` to do a `map` in the same step.
 *
 * #### **Reduction** (`function(i, acc) : acc`)
 *
 * - Used by `reduce`.
 * - Takes in the index and the previous accumulated object and returns the
 *   new accumulated object.
 * - This is roughly equivalent to a for_each loop in C++.
 *
 * > NOTE:
 * >
 * > `acc` **is the second parameter** which is different from most languages.
 * > This is to keep it consistent with the rest of the `PPMRRAIR` functions
 * > and this library in general.  You have been warned.
 *
 * #### **Reduction, Allow Incomplete Reduction** (`function(i, acc) : [cont, acc]`)
 *
 * - Used by `reduce_air`.
 * - Takes in the index and the previous accumulated object and returns a
 *   list `[ cont, new_acc ]`, where `cont` states if to continue looping if not
 *   finished iterating over the `birlei`.
 * - This is roughly equivalent to a for loop in C++.
 *
 * > NOTE:
 * >
 * > `acc` **is the second parameter** which is different from most languages.
 * > This is to keep it consistent with the rest of the `PPMRRAIR` functions
 * > and this library in general.  You have been warned.
 *
 * **See also** [Algorithm Adaptors](#algorithm-adaptors).
 */
use <indexable>
use <types>
include <types_consts>
use <range>
use <test>
use <birlei>
use <function>

/** ### The Base Algorithms */

/**
 * @callback BoundIndexFn
 * @param {SpaceshipFn} spaceship_fn
 *
 * @returns {(number|undef)}
 *   Index of the selected bound, or `undef` if no such index exists.
 *
 *   > NOTE:
 *   >
 *   > `undef` is returned rather than `end_i+1` because the searched indices
 *   > can be noncontiguous (range/list selectors).
 */

/**
 * @typedef {(number|range|list|undef)} OptionalBirl
 * - If `number`, start index to iterate over
 * - If `range`, indices to iterate over
 * - If `list`, indices to iterate over
 * - If `undef`, then tells function to return a curried version of itself,
 *   that only takes parameters of types `Birl` and `EndI`.
 */

/**
 * @callback AlgoFn
 *
 * Executes the algorithm.
 *
 * @param {Birl} birl
 * @param {EndI} [end_i]
 *
 * @returns {any}
 *   Returned value is based on the result of the function doing the iterating.
 */

/**
 * @typedef {BoundIndexFn} FindLowerFn
 *
 * @returns {(number|undef)}
 *   The first index `i` where `spaceship_fn(i) >= 0` or `undef` if none found.
 *
 *   > NOTE:
 *   >
 *   > The reason for returning `undef` rather than `end_i+1`, is because `birl`
 *   > could be a noncontiguous `range` or `list` of indices.
 */

/**
 * @typedef {AlgoFn} FindLowerBirleiFn
 *
 * @returns {FindLowerFn}
 *   Callback that returns the first index `i` where `spaceship_fn(i) >= 0` or
 *   `undef` if none found.
 */

/**
 * @callchain find_lower(birl, end_i)    (spaceship_fn) : (number|undef)
 * @callchain find_lower() (birl, end_i) (spaceship_fn) : (number|undef)
 *
 * Like C++'s `lower_bound`: returns the first index `i` for which
 * `spaceship_fn(i) >= 0`.
 *
 * > NOTE:
 * >
 * > The specified `birlei` of indices must be such that `spaceship_fn(i)`
 * > is monotonically nondecreasing over the searched indices; or the results
 * > are **UB**.
 *
 * @param {OptionalBirl} [birl]
 * @param {EndI} [end_i]
 *
 * @returns {(FindLowerFn|FindLowerBirleiFn)}
 *   - If `birl` is omitted, then will return type `FindLowerBirleiFn`.
 *   - Else returns type `FindLowerFn`.
 */
function find_lower(birl, end_i) =
  is_undef(birl)
  ? function(birl, end_i) find_lower(birl, end_i)
  : let (
      _find_binary = function(_spaceship_fn, begin_i, end_i)
        begin_i == end_i
        ? begin_i
        : let (
            mid_i = floor((begin_i + end_i) / 2),
            result = _spaceship_fn(mid_i)
          )
          result >= 0
            ? _find_binary(_spaceship_fn, begin_i,   mid_i)  // first-true lies at/before mid_i
            : _find_binary(_spaceship_fn, mid_i + 1, end_i)  // still false at mid_i -> go right
    )
    function(spaceship_fn)
      birlei_to_begin_i_end_i(
        function(_spaceship_fn, begin_i, end_i, map_back_fn)
          end_i < begin_i || _spaceship_fn(end_i) < 0
          ? undef
          : map_back_fn(_find_binary(_spaceship_fn, begin_i, end_i)),
        spaceship_fn, birl, end_i)
;

let (v = 0) test_eq(    v, echo(str("Searching for ", v)) it_each([0,1,2,3,4],       find_lower())(function(e) e-v));
let (v = 2) test_eq(    v, echo(str("Searching for ", v)) it_each([0,1,2,3,4],       find_lower())(function(e) e-v));
let (v = 1) test_eq(    v, echo(str("Searching for ", v)) it_each([0,1,2,3,4],       find_lower())(function(e) e-v));
let (v = 3) test_eq(    v, echo(str("Searching for ", v)) it_each([0,1,2,3,4],       find_lower())(function(e) e-v));
let (v = 4) test_eq(    v, echo(str("Searching for ", v)) it_each([0,1,2,3,4],       find_lower())(function(e) e-v));
let (v = 5) test_eq(undef, echo(str("Searching for ", v)) it_each([0,1,2,3,4],       find_lower())(function(e) e-v));
let (v = 7) test_eq(    v, echo(str("Searching for ", v)) it_each([0,1,2,3,4,5,6,7], find_lower())(function(e) e-v));
let (v = 2) test_eq(    2, echo(str("Searching for ", v)) it_each([0,1,2,2,4],       find_lower())(function(e) e-v));
let (v = 2) test_eq(    2, echo(str("Searching for ", v)) it_each([0,1,2,2,2],       find_lower())(function(e) e-v));
let (v = 2) test_eq(    1, echo(str("Searching for ", v)) it_each([0,2,2,2,2],       find_lower())(function(e) e-v));
let (v = 3) test_eq(undef, echo(str("Searching for ", v)) it_each([0,2,2,2,2],       find_lower())(function(e) e-v));

/**
 * @typedef {BoundIndexFn} FindUpperFn
 * Returns the first index `i` where `spaceship_fn(i) > 0`.
 */

/**
 * @callback FindUpperFn
 *
 * @callchain FindUpperFn(spaceship_fn) : (number|undef)

 * @param {SpaceshipFn} spaceship_fn
 *
 * @returns {(number|undef)}
 *   The first index `i` where `spaceship_fn(i) > 0` or `undef` if none found.
 *
 *   > NOTE:
 *   >
 *   > The reason for returning `undef` rather than `end_i+1`, is because `birl`
 *   > could be a noncontiguous `range` or `list` of indices.
 */

/**
 * @typedef {AlgoFn} FindUpperBirleiFn
 *
 * @returns {FindUpperFn}
 *   Callback that returns the first index `i` where `spaceship_fn(i) >= 0` or
 *   `undef` if none found.
 */

/**
 * @callchain find_upper(birl, end_i)    (spaceship_fn) : (number|undef)
 * @callchain find_upper() (birl, end_i) (spaceship_fn) : (number|undef)
 *
 * Like C++'s `upper_bound`: returns the first index `i` for which
 * `spaceship_fn(i) > 0`.
 *
 * > NOTE:
 * >
 * > The specified `birlei` of indices must be such that `spaceship_fn(i)`
 * > is monotonically nondecreasing over the searched indices; or the results
 * > are **UB**.
 *
 * @param {OptionalBirl} [birl]
 * @param {EndI} [end_i]
 *
 * @returns {(FindUpperFn|FindUpperBirleiFn)}
 *   - If `birl` is omitted, then will return type `FindUpperBirleiFn`.
 *   - Else returns type `FindUpperFn`.
 */
function find_upper(birl, end_i) =
  is_undef(birl)
  ? function(birl, end_i) find_upper(birl, end_i)
  : let (
      _find_binary = function(_spaceship_fn, begin_i, end_i)
        begin_i == end_i
        ? begin_i
        : let (
            mid_i = floor((begin_i + end_i) / 2),
            result = _spaceship_fn(mid_i)
          )
          (result > 0
            ? _find_binary(_spaceship_fn, begin_i,   mid_i)  // first-true (>0) at/before mid_i
            : _find_binary(_spaceship_fn, mid_i + 1, end_i)  // still <= 0 at mid_i -> go right
          )
  )
  function(spaceship_fn)
    birlei_to_begin_i_end_i(
      function(_spaceship_fn, begin_i, end_i, map_back_fn)
        end_i < begin_i || _spaceship_fn(end_i) <= 0
        ? undef
        : map_back_fn(_find_binary(_spaceship_fn, begin_i, end_i)),
      spaceship_fn, birl, end_i)
;

let (v = 0) test_eq(  v+1, echo(str("Searching for ", v)) it_each([0,1,2,3,4],       find_upper())(function(e) e-v));
let (v = 1) test_eq(  v+1, echo(str("Searching for ", v)) it_each([0,1,2,3,4],       find_upper())(function(e) e-v));
let (v = 2) test_eq(  v+1, echo(str("Searching for ", v)) it_each([0,1,2,3,4],       find_upper())(function(e) e-v));
let (v = 3) test_eq(  v+1, echo(str("Searching for ", v)) it_each([0,1,2,3,4],       find_upper())(function(e) e-v));
let (v = 4) test_eq(undef, echo(str("Searching for ", v)) it_each([0,1,2,3,4],       find_upper())(function(e) e-v));
let (v = 7) test_eq(undef, echo(str("Searching for ", v)) it_each([0,1,2,3,4,5,6,7], find_upper())(function(e) e-v));
let (v = 5) test_eq(undef, echo(str("Searching for ", v)) it_each([0,1,2,3,4],       find_upper())(function(e) e-v));
let (v = 2) test_eq(    4, echo(str("Searching for ", v)) it_each([0,1,2,2,4],       find_upper())(function(e) e-v));
let (v = 2) test_eq(undef, echo(str("Searching for ", v)) it_each([0,1,2,2,2],       find_upper())(function(e) e-v));
let (v = 2) test_eq(undef, echo(str("Searching for ", v)) it_each([0,2,2,2,2],       find_upper())(function(e) e-v));

/**
 * @callback FindFn
 * @param {PredFn} pred_fn
 * @returns {(number|undef)}
 *   First index where `pred_fn(i)` is `true`.  If none are found, returns
 *   `undef`.
 *
 *   > NOTE:
 *   >
 *   > The reason for returning `undef` rather than `end_i+1`, is because `birl`
 *   > could be a noncontiguous `range` or `list` of indices.
 */

/**
 * @typedef {AlgoFn} FindBirleiFn
 *
 * @returns {FindFn}
 *   Callback that returns first index where `pred_fn(i)` is `true`.  If none
 *   are found, returns `undef`.
 */

/**
 * @callchain find(birl, end_i)    (pred_fn) : (number|undef)
 * @callchain find() (birl, end_i) (pred_fn) : (number|undef)
 *
 * Returns the first index that results in `pred_fn(i)` returning a truthy
 * result.
 *
 * @param {OptionalBirl} [birl]
 * @param {EndI} [end_i]
 *
 * @returns {(FindFn|FindBirleiFn)}
 *   - If `birl` is omitted, then will return type `FindBirleiFn`.
 *   - Else returns type `FindFn`.
 */
function find(birl, end_i) =
  is_undef(birl)
  ? function(birl, end_i) find(birl, end_i)
  : let (
    _find_linear = function(_pred_fn, begin_i, end_i)
      begin_i <= end_i
      ? // echo("find_helper linear: ", begin_i, _pred_fn)
        _pred_fn(begin_i)
        ? begin_i
        : _find_linear(_pred_fn, begin_i + 1, end_i)
      : undef
  )
  function(pred_fn)
    birlei_to_begin_i_end_i(
      function(_pred_fn, begin_i, end_i, map_back_fn)
        end_i < begin_i
        ? undef
        : map_back_fn(_find_linear(_pred_fn, begin_i, end_i)),
      pred_fn, birl, end_i)
;

/**
 * @callback ReduceFn
 * @param {ReductionFn} reduction_fn
 * @returns {any}
 *   Final value of accumulator.
 */

/**
 * @typedef {AlgoFn} ReduceBirleiFn
 *
 * @returns {ReduceFn}
 *   Callback that returns final value of accumulator.
 */

/**
 * @callchain reduce(init, birl, end_i)  (op_fn) : result
 * @callchain reduce(init) (birl, end_i) (op_fn) : result
 *
 * Reduces (a.k.a. folds) a set of indices to produce some value/object based on
 * the indices.
 *
 * @param {any} init
 *   This is the initial value that is passed to the first iteration of `op_fn`
 *   as the accumulator.
 * @param {OptionalBirl} [birl]
 * @param {EndI} [end_i]
 *
 * @returns {(ReduceFn|ReduceBirleiFn)}
 *   - If `birl` is omitted, then will return type `ReduceBirleiFn`.
 *   - Else returns type `ReduceFn`.
 */
 function reduce(init, birl, end_i) =
  is_undef(birl)
  ? function(birl, end_i) reduce(init, birl, end_i)
  : // echo(str("reduce:\n  ", op_fn, "\n  ", type_value(init), "\n  ", birl, ", ", end_i ))
    let (
      _reduce_linear = function(op_fn, acc, begin_i, end_i)
        end_i > begin_i
        ?
          // assert(param_count(op_fn) == 2, op_fn)
          // assert(param_count(_reduce_linear) == 4)
          let( result = op_fn(begin_i, acc) )
          _reduce_linear(op_fn, result, begin_i + 1, end_i)
        : op_fn(begin_i, acc)
    )
    function(op_fn)
      birlei_to_begin_i_end_i(
        function(op_fn, begin_i, end_i, _)
          assert(param_count(op_fn) == 2, op_fn)
          end_i < begin_i
          ? init
          : _reduce_linear(op_fn, init, begin_i, end_i),
        op_fn, birl, end_i)
;

/**
 * @callback ReduceAirFn
 * @param {ReductionAirFn} reduction_fn
 * @returns {list[bool,any]}
 *   Last continue value and the final value of accumulator.  If the original
 *  `birlei` was empty will contain `[true, init]`.
 */

/**
 * @typedef {AlgoFn} ReduceAirBirleiFn
 *
 * @returns {ReduceAirFn}
 *   Callback that returns the last continue value and the final value of
 *   accumulator.  If the original `birlei` was empty will contain
 *   `[true, init]`.
 */

/**
 * @callchain reduce_air(init, birl, end_i)  (op_fn) : [cont, init_result]
 * @callchain reduce_air(init) (birl, end_i) (op_fn) : [cont, init_result]
 *
 * Reduces (a.k.a. folds) a set of indices to produce some value/object based on
 * the indices.  This Reduction Allows for Incomplete Reduction.
 *
 * @param {any} init
 *   This is the initial value that is passed to the first iteration of `op_fn`
 *   as the accumulator.
 * @param {OptionalBirl} [birl]
 * @param {EndI} [end_i]
 *
 * @returns {(ReduceAirFn|ReduceAirBirleiFn)}
 *   - If `birl` is omitted, then will return type `ReduceAirBirleiFn`.
 *   - Else returns type `ReduceAirFn`.
 */
function reduce_air(init, birl, end_i) =
  is_undef(birl)
  ? function(birl, end_i) reduce_air(init, birl, end_i)
  : // echo(str("reduce:\n  ", op_fn, "\n  ", init, "\n  ", birl, ", ", end_i ))
    let (
      _reduce_linear = function(op_fn, acc, begin_i, end_i)
        end_i > begin_i
        ? let (result = op_fn(begin_i, acc))
          result[0]
          ? _reduce_linear(op_fn, result[1], begin_i + 1, end_i)
          : result
        : op_fn(begin_i, acc)
    )
    function(op_fn)
      birlei_to_begin_i_end_i(
        function(op_fn, begin_i, end_i, map_back_fn)
          end_i < begin_i
          ? [ true, init ]
          : _reduce_linear(op_fn, init, begin_i, end_i),
        op_fn, birl, end_i)
;

////////////////////////////////////////////////////////////////////////////////
// Map and Filter
////////////////////////////////////////////////////////////////////////////////

/**
 * @callback FilterFn
 * @param {(PredFn|PredMapFn)} ppm_fn
 * @returns {list[any,...]}
 *   A list of elements where the predicate returned true.
 */

/**
 * @typedef {AlgoFn} FilterBirleiFn
 *
 * @returns {FilterFn}
 *   Callback that returns a list of elements where the predicate returned true.
 */

/**
 * @callchain filter(birl, end_i)    (ppm_fn) : list
 * @callchain filter() (birl, end_i) (ppm_fn) : list
 *
 * Filter function.
 *
 * @param {OptionalBirl} [birl]
 * @param {EndI} [end_i]
 *
 * @returns {(FilterFn|FilterBirleiFn)}
 *   - If `birl` is omitted, then will return type `FilterBirleiFn`.
 *   - Else returns type `FilterFn`.
 */
function filter(birl, end_i) =
  is_undef(birl)
  ? function(birl, end_i) filter(birl, end_i)
  : let (
      indices = birlei_to_indices(birl, end_i)
    )
    function(ppm_fn)
      let (
        pc = param_count(ppm_fn)
      )
      assert(pc == 1 || pc == 2, str("ppm_fn must be a function with 1 or 2 params, not ", pc, "."))
      pc == 1
      ? [
        for (i = indices) if (ppm_fn(i)) i
      ]
      : [
        for (i = indices) if (ppm_fn(i)) ppm_fn(i, true)
      ]
;

/**
 * @callback MapFn
 * @param {MapperFn} map_fn
 * @returns {list[any,...]}
 *   A list of elements that were mapped.
 */

/**
 * @typedef {AlgoFn} MapBirleiFn
 *
 * @returns {MapFn}
 *   Callback that returns a list of elements that were mapped.
 */

/**
 * @callchain map(birl, end_i)    (map_fn) : list
 * @callchain map() (birl, end_i) (map_fn) : list
 *
 * Map indices or list elements to values, producing a list that has as many
 * elements as indices provided.
 *
 * @param {OptionalBirl} [birl]
 * @param {EndI} [end_i]
 *
 * @returns {(MapFn|MapBirleiFn)}
 *   - If `birl` is omitted, then will return type `MapBirleiFn`.
 *   - Else returns type `MapFn`.
 */
function map(birl, end_i) =
  is_undef(birl)
  ? function(birl, end_i) map(birl, end_i)
  : function(map_fn)
      // echo(str("map birl: ", birl, " end_i: ", end_i))
      let (indices = birlei_to_indices(birl, end_i))
      // echo("indices: ", indices)
      [ for (i = indices)
          // echo("map", i)
          map_fn(i)
      ]
;
