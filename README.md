# OpenSCAD Curry Library (OCL)

- [Purpose](#purpose)
- [About this file](#about-this-file)
- [Installation](#installation)
  - [Importing Library Files](#importing-library-files)
- [Compatibility](#compatibility)
- [Status](#status)
- [Licence](#licence)
  - [Reading the Documentation](#reading-the-documentation)
    - [Callout Blocks](#callout-blocks)
    - [Section Emojis](#section-emojis)
    - [Symbol Emojis](#symbol-emojis)
  - [Signature Specifications](#signature-specifications)
  - [Libraries](#libraries)
    - [Parameter Names That Infer Types](#parameter-names-that-infer-types)
    - [Synopses of Files](#synopses-of-files)
- [API Table of Contents](#api-table-of-contents)

## Purpose

OpenSCAD is a really great programming language to parametrically describe a 3D
object, allowing binary union, difference and intersection operations.  However,
for those coming from a procedural rather than a functional programming
paradigm, it may be a bit difficult to get a handle on.  This library is to help
with that by taking some ideas from C++ and python and incorporating them into
the current OpenSCAD language without actually changing the language itself.

Although you may be able to write faster specific implementations of many of
these functions, they give an abstraction layer that makes it easier to code and
read.  From there, once you've created whatever code you want and you feel it's
not fast enough, optimisation is always an option.  Code readability and
maintainability are the primary goal of this library.  Speed is secondary
(though performance was also considered and it is quite fast).

## About this file

Most of this file is autogenerated with a static header.  I'll eventually be
breaking up this file into a shorter README.md and an API.md to be more inline
with GitHub's suggested document spec, but it's conception was done before I
knew about the spec.  Shouldn't be too hard, but the doc has a long way to go
yet and the breakup is low priority atm.

Currently, this doc is showing the private items (symbols prefixed by an
underscore) as well as the public ones.  Those will eventually disappear for
general usage.

## Installation

OpenSCAD finds `use <>` / `include <>` targets in a small set of library
locations.  In particular, library files are searched for:

- in the same folder as the design file you opened,
- in the library folder of the OpenSCAD installation, and
- in folders listed by the `OPENSCADPATH` environment variable.  (See
  [OpenSCAD User Manual - Include
  Statement](https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Include_Statement))

A practical way to use this library is to place (or clone) it into your user
library folder and then import files by relative path from there.  OpenSCAD
exposes the library folder location via **File â†’ Show Library Folder...**.  (See
[OpenSCAD User Manual - Libraries](https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Libraries))

Alternatively, if using in several projects, clone in one location and set the `OPENSCADPATH`
variable to point to that location.

### Importing Library Files

- For `*_consts` files: use the `include <>` idiom.
- For all other files: use the `use <>` idiom.

The include path must match the actual file names.  These files are
intentionally extensionless (similar to C++ standard library headers).

## Compatibility

- Intended to work across OpenSCAD versions.
- Known limitation: OpenSCAD **2021.01** has problems with some of the string
  formatting code paths due to incorrect recursion detection.  Upgrading to a
  newer OpenSCAD build avoids that issue.

## Status

- **Stable:** everything except `skin` which is mostly working.
- **In development:** `skin`.

## Licence

This project is licensed under the **BSD 3-Clause License**.  See
[`LICENSE`](./LICENSE).

### Reading the Documentation

#### Callout Blocks

Throughout the documentation, you'll find callout blocks with emojis:

| Callout                | Meaning                                                                  |
| ---------------------- | ------------------------------------------------------------------------ |
| â„¹ï¸ **NOTE:**           | Information to bring attention to the reader.                            |
| âš ï¸ **WARNING:**        | Important warning about potential issues or pitfalls.                    |
| ğŸ¤” **TO THINK ABOUT:** | Notes for the library developer about items needing more consideration.  |
| ğŸ“Œ **TO DO:**          | Planned work or improvements.                                            |

#### Section Emojis

The Table of Contents and documentation sections use these emojis:

| Emoji | Meaning                 |
| ----- | ----------------------- |
| ğŸ“˜    | File section header.    |
| ğŸ“‘    | Chapter within a file.  |

#### Symbol Emojis

Each documented symbol is prefixed with an emoji indicating its type:

| Emoji | Symbol Type                                   |
| ----- | --------------------------------------------- |
| âš™ï¸    | Function                                      |
| ğŸ§Š    | Module (builds geometry)                      |
| ğŸ§ª    | Module (test module, prefixed with `test_`)   |
| ğŸ’     | Value                                         |
| ğŸ§©    | Type definition (`@typedef`)                  |
| ğŸ§©âš™ï¸  | Callback type (`@callback`)                   |

### Signature Specifications

This library uses curried functions.  There is no clean way to document a full
curried call chain using standard JSDoc or TypeScript JSDoc today, so this
project defines a small extension.

Using the `@callchain` tag, the full curried call chain is written inline, for
example:

- `@callchain replace_each(a, a_birls, a_end_i) (b, b_birls, b_end_i): (string | list)`

If used, they are the first item in the documentation of a function, module,
callchain and will show as a code block in the rendered documentation in the
same relative position.

This makes the intended usage obvious to readers and makes it straightforward to
generate the `.md` documentation.  Different overloads may also be stated using
this syntax, and a call chain may comprise of only one link.  E.g. The call to
the first function may just end right there, if it doesn't curry.

### Libraries

#### Parameter Names That Infer Types

Many parameter names imply the types that they accept.

- `s` - A `string`.
- `l` - A `list`.
- `r` - A `range`.
- `sl` - A type being either a `string` or `list`.
- `slr` - A type being either a `string`, `list` or `range`.
- `birl` - A type being either a `number` starting a `(number, number)` pair, a
  `range` or a `list`.
- `birls` - A type being either a `number` starting a `(number, number)` pair, a
  `range`, a `list` or a `slice`.
- `end_i` - A `number` being the end of the `(number, number)` pair or `undef`
  if `birl` is not a `number`.  As these are usually the last element, if a
  non-number is used for the `birl`/`birls` then this parameter can just be
  omitted.

#### Synopses of Files

There are several files in this library set.

 1. [range](#file-range)
    - Wraps OpenSCAD ranges `[start:stop]`/`[start:step:stop]`, adds extra
      functionality and remove warnings when creating null ranges.
    - Ranges are considered indexable and can be dereferenced using `range_el`.
    - `range()` function does **not** generate a warning when a given `start`
      and `step`, makes it impossible to get to `stop`.  Instead, it returns an
      empty `range`.
 2. [types](#file-types), [types_consts](#file-types_consts)
    - Allows for classifying object types that are beyond the standard
      `is_num`, `is_string`, `is_list`, `is_undef`, `is_function`, `is_bool` by
      adding `is_int`, `is_float` and `is_nan`.  `is_range` is defined in range
      library.
    - Enumerates object types.
    - Generates a minimal string representing the type of an object.
 3. [birlei](#file-birlei)
    - Refers to the ome or two parameters describing a set of numbers to iterate
      over.
    - `birl` refers to `b`egin `i`ndex, `r`ange or `l`ist.  `ei` (a.k.a.
      `end_i`) refers to `e`nd `i`ndex.  Together, they give a range of
      numeric values, usually used as indices to dereference elements from
      indexable objects like strings, lists, or ranges.
    - When birlei are two numbers, `birl` **must be <=** `end_i` or nothing is
      iterated over.  There is no warning (unlike the built in range syntax).
      This is by design so as to be able to iterate over no elements.
 4. [base_algos](#file-base_algos)
    - The base algorithms which much of the library uses.
    - When the `birlei` is not passed, the algorithm returns a lambda that
      only take a `birlei`.
    - When passing a `birlei`, returns a lambda that takes a lambda which is
      called over the `birlei` set.
 5. [any_all](#file-any_all)
    - `any` and `all` algorithms.
 6. [indexable](#file-indexable), [indexable_consts](#file-indexable_consts)
    - Functions to manipulate a list or string as a stack / queue, use negative
      indices to get the indices / elements from the end, insert /
      remove / replace elements, and additional search algorithms.
    - Adds a new `slice` type that works similarly to python's slice, but still
      uses the closed range paradigm.  This is not indexable, but can be used
      with indexable functions that have a `birls` parameter (`s` for slice).
 7. [function](#file-function)
    - Allow counting of function parameters and applying an array to a function
      as parameters.
 8.  [test](#file-test)
    - Testing modules for TDD.
 9.  [param_check](#file-param_check)
    - Functions to check the validity of parameters.  Usage allows to switch
      them off by commenting them out.
 10. [transform](#file-transform)
    - Functions that allow transforming single points or a series of points
      quickly, usually by creating transformation matrices that can be
      multiplied against the point or points.
 11. [string](#file-string), [string_consts](#file-string_consts)
    - String formatting functions.
 12. [helpers](#file-helpers), [helpers_consts](#file-helpers_consts)
    - Miscellaneous functions that don't fit elsewhere.
 13. [skin](#file-skin)
    - Generates a polyhedron using slices.

## API Table of Contents

*If viewing on GitHub, you can also use the outline button (â˜°) near the top
 right of the page to navigate by heading.  However, I would suggest looking
 [directly at the file](README.md) rather then from the repo page since it
 doesn't work properly from there.*

Since there are **a lot** of functions here and other supplementary
documentation, all top level headings are shown and the headings below them have
been minimised.  To Navigate:

- Click on the link to go to the heading.
- Click to the right of the heading to open it up and see the headings below it.
<details><summary><a href="#file-range">ğŸ“˜ <b>range</b></a></summary>
<blockquote>
â€¢ <a href="#ch-range-_how_to__import">ğŸ“‘ <i>How to Import</i></a><br>
â€¢ <a href="#ch-range-_purpose">ğŸ“‘ <i>Purpose</i></a><br>
<details><summary><a href="#ch-range-_test">ğŸ“‘ <i>Test</i></a></summary>
<blockquote>
â€¢ <a href="#f-is_range">âš™ï¸is_range</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-range-_functions">ğŸ“‘ <i>Functions</i></a></summary>
<blockquote>
â€¢ <a href="#f-range">âš™ï¸range</a><br>
â€¢ <a href="#f-range_len">âš™ï¸range_len</a><br>
â€¢ <a href="#f-range_el">âš™ï¸range_el</a><br>
â€¢ <a href="#f-range_el_pos_idx">âš™ï¸range_el_pos_idx</a><br>
â€¢ <a href="#f-range_idx">âš™ï¸range_idx</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-range-range_types">ğŸ“‘ <i>range types</i></a></summary>
<blockquote>
â€¢ <a href="#t-range">ğŸ§©range</a><br>
</blockquote>
</details>
</blockquote>
</details>

<details><summary><a href="#file-types">ğŸ“˜ <b>types</b></a></summary>
<blockquote>
â€¢ <a href="#ch-types-_how_to__import">ğŸ“‘ <i>How to Import</i></a><br>
â€¢ <a href="#ch-types-_purpose">ğŸ“‘ <i>Purpose</i></a><br>
<details><summary><a href="#ch-types-_tests">ğŸ“‘ <i>Tests</i></a></summary>
<blockquote>
â€¢ <a href="#f-is_indexable_te">âš™ï¸is_indexable_te</a><br>
â€¢ <a href="#f-is_int">âš™ï¸is_int</a><br>
â€¢ <a href="#f-is_float">âš™ï¸is_float</a><br>
â€¢ <a href="#f-is_nan">âš™ï¸is_nan</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-types-_type__introspection">ğŸ“‘ <i>Type Introspection</i></a></summary>
<blockquote>
â€¢ <a href="#v-__t_y_p_e__n_a_m_e_s">ğŸ’ _TYPE_NAMES</a><br>
â€¢ <a href="#f-type_enum">âš™ï¸type_enum</a><br>
â€¢ <a href="#f-type_enum_to_str">âš™ï¸type_enum_to_str</a><br>
â€¢ <a href="#f-type">âš™ï¸type</a><br>
â€¢ <a href="#f-type_structure">âš™ï¸type_structure</a><br>
â€¢ <a href="#f-type_value">âš™ï¸type_value</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-types-types_types">ğŸ“‘ <i>types types</i></a></summary>
<blockquote>
â€¢ <a href="#t-_type_enum">ğŸ§©TypeEnum</a><br>
</blockquote>
</details>
</blockquote>
</details>

<details><summary><a href="#file-types_consts">ğŸ“˜ <b>types_consts</b></a></summary>
<blockquote>
â€¢ <a href="#ch-types_consts-_how_to__import">ğŸ“‘ <i>How to Import</i></a><br>
â€¢ <a href="#ch-types_consts-_purpose">ğŸ“‘ <i>Purpose</i></a><br>
<details><summary><a href="#ch-types_consts-_values">ğŸ“‘ <i>Values</i></a></summary>
<blockquote>
â€¢ <a href="#v-_r_a_n_g_e">ğŸ’ RANGE</a><br>
â€¢ <a href="#v-_l_i_s_t">ğŸ’ LIST</a><br>
â€¢ <a href="#v-_s_t_r">ğŸ’ STR</a><br>
â€¢ <a href="#v-_u_n_k_n_o_w_n">ğŸ’ UNKNOWN</a><br>
â€¢ <a href="#v-_s_l_i_c_e">ğŸ’ SLICE</a><br>
â€¢ <a href="#v-_u_n_d_e_f">ğŸ’ UNDEF</a><br>
â€¢ <a href="#v-_b_o_o_l">ğŸ’ BOOL</a><br>
â€¢ <a href="#v-_f_u_n_c">ğŸ’ FUNC</a><br>
â€¢ <a href="#v-_n_u_m">ğŸ’ NUM</a><br>
â€¢ <a href="#v-_i_n_t">ğŸ’ INT</a><br>
â€¢ <a href="#v-_f_l_o_a_t">ğŸ’ FLOAT</a><br>
â€¢ <a href="#v-_n_a_n">ğŸ’ NAN</a><br>
</blockquote>
</details>
</blockquote>
</details>

<details><summary><a href="#file-birlei">ğŸ“˜ <b>birlei</b></a></summary>
<blockquote>
â€¢ <a href="#ch-birlei-_how_to__import">ğŸ“‘ <i>How to Import</i></a><br>
â€¢ <a href="#ch-birlei-_purpose">ğŸ“‘ <i>Purpose</i></a><br>
<details><summary><a href="#ch-birlei-_functions">ğŸ“‘ <i>Functions</i></a></summary>
<blockquote>
â€¢ <a href="#f-birlei_to_begin_i_end_i">âš™ï¸birlei_to_begin_i_end_i</a><br>
â€¢ <a href="#f-birlei_to_indices">âš™ï¸birlei_to_indices</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-birlei-birlei_types">ğŸ“‘ <i>birlei types</i></a></summary>
<blockquote>
â€¢ <a href="#t-_birl">ğŸ§©Birl</a><br>
â€¢ <a href="#t-_end_i">ğŸ§©EndI</a><br>
â€¢ <a href="#t-_spaceship_fn">ğŸ§©SpaceshipFn</a><br>
â€¢ <a href="#t-_pred_fn">ğŸ§©PredFn</a><br>
â€¢ <a href="#t-_reduction_fn">ğŸ§©ReductionFn</a><br>
â€¢ <a href="#t-_reduction_air_fn">ğŸ§©ReductionAirFn</a><br>
â€¢ <a href="#t-_pred_map_fn">ğŸ§©PredMapFn</a><br>
â€¢ <a href="#t-_mapper_fn">ğŸ§©MapperFn</a><br>
â€¢ <a href="#t-_ppmrrair_fn">ğŸ§©PpmrrairFn</a><br>
â€¢ <a href="#t-_map_back_fn">ğŸ§©MapBackFn</a><br>
</blockquote>
</details>
</blockquote>
</details>

<details><summary><a href="#file-base_algos">ğŸ“˜ <b>base_algos</b></a></summary>
<blockquote>
â€¢ <a href="#ch-base_algos-_how_to__import">ğŸ“‘ <i>How to Import</i></a><br>
â€¢ <a href="#ch-base_algos-_purpose">ğŸ“‘ <i>Purpose</i></a><br>
â€¢ <a href="#ch-base_algos-_f_y_i____functions_and__iterating_are__abound_">ğŸ“‘ <i>FYI: Functions and Iterating are Abound!</i></a><br>
â€¢ <a href="#ch-base_algos-_iterators__">ğŸ“‘ <i>Iterators:</i></a><br>
â€¢ <a href="#ch-base_algos-_algorithms">ğŸ“‘ <i>Algorithms</i></a><br>
â€¢ <a href="#ch-base_algos-_algorithm__signatures">ğŸ“‘ <i>Algorithm Signatures</i></a><br>
<details><summary><a href="#ch-base_algos-_p_p_m_r_r_a_i_r_functions">ğŸ“‘ <i>PPMRRAIR functions</i></a></summary>
<blockquote>
â€¢ <a href="#predicate-functioni--result">Predicate (`function(i) : result`)</a><br>
â€¢ <a href="#predicatemap-functioni-v--any">Predicate/Map (`function(i, v) : any`)</a><br>
â€¢ <a href="#reduction-functioni-acc--acc">Reduction (`function(i, acc) : acc`)</a><br>
â€¢ <a href="#reduction-allow-incomplete-reduction-functioni-acc--cont-acc">Reduction, Allow Incomplete Reduction (`function(i, acc) : [cont, acc]`)</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-base_algos-_the__base__algorithms">ğŸ“‘ <i>The Base Algorithms</i></a></summary>
<blockquote>
â€¢ <a href="#f-find_lower">âš™ï¸find_lower</a><br>
â€¢ <a href="#f-find_upper">âš™ï¸find_upper</a><br>
â€¢ <a href="#f-find">âš™ï¸find</a><br>
â€¢ <a href="#f-reduce">âš™ï¸reduce</a><br>
â€¢ <a href="#f-reduce_air">âš™ï¸reduce_air</a><br>
â€¢ <a href="#f-filter">âš™ï¸filter</a><br>
â€¢ <a href="#f-map">âš™ï¸map</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-base_algos-base_algos_types">ğŸ“‘ <i>base_algos types</i></a></summary>
<blockquote>
â€¢ <a href="#t-_bound_index_fn">ğŸ§©BoundIndexFn</a><br>
â€¢ <a href="#t-_optional_birl">ğŸ§©OptionalBirl</a><br>
â€¢ <a href="#t-_algo_fn">ğŸ§©AlgoFn</a><br>
â€¢ <a href="#t-_find_lower_fn">ğŸ§©FindLowerFn</a><br>
â€¢ <a href="#t-_find_lower_birlei_fn">ğŸ§©FindLowerBirleiFn</a><br>
â€¢ <a href="#t-_find_upper_fn">ğŸ§©FindUpperFn</a><br>
â€¢ <a href="#t-_find_upper_fn">ğŸ§©FindUpperFn</a><br>
â€¢ <a href="#t-_find_upper_birlei_fn">ğŸ§©FindUpperBirleiFn</a><br>
â€¢ <a href="#t-_find_fn">ğŸ§©FindFn</a><br>
â€¢ <a href="#t-_find_birlei_fn">ğŸ§©FindBirleiFn</a><br>
â€¢ <a href="#t-_reduce_fn">ğŸ§©ReduceFn</a><br>
â€¢ <a href="#t-_reduce_birlei_fn">ğŸ§©ReduceBirleiFn</a><br>
â€¢ <a href="#t-_reduce_air_fn">ğŸ§©ReduceAirFn</a><br>
â€¢ <a href="#t-_reduce_air_birlei_fn">ğŸ§©ReduceAirBirleiFn</a><br>
â€¢ <a href="#t-_filter_fn">ğŸ§©FilterFn</a><br>
â€¢ <a href="#t-_filter_birlei_fn">ğŸ§©FilterBirleiFn</a><br>
â€¢ <a href="#t-_map_fn">ğŸ§©MapFn</a><br>
â€¢ <a href="#t-_map_birlei_fn">ğŸ§©MapBirleiFn</a><br>
</blockquote>
</details>
</blockquote>
</details>

<details><summary><a href="#file-any_all">ğŸ“˜ <b>any_all</b></a></summary>
<blockquote>
â€¢ <a href="#ch-any_all-_how_to__import">ğŸ“‘ <i>How to Import</i></a><br>
<details><summary><a href="#ch-any_all-_purpose">ğŸ“‘ <i>Purpose</i></a></summary>
<blockquote>
â€¢ <a href="#f-any">âš™ï¸any</a><br>
â€¢ <a href="#f-all">âš™ï¸all</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-any_all-any_all_types">ğŸ“‘ <i>any_all types</i></a></summary>
<blockquote>
â€¢ <a href="#t-_any_fn">ğŸ§©AnyFn</a><br>
â€¢ <a href="#t-_any_birlei_fn">ğŸ§©AnyBirleiFn</a><br>
â€¢ <a href="#t-_all_fn">ğŸ§©AllFn</a><br>
â€¢ <a href="#t-_all_birlei_fn">ğŸ§©AllBirleiFn</a><br>
</blockquote>
</details>
</blockquote>
</details>

<details><summary><a href="#file-indexable">ğŸ“˜ <b>indexable</b></a></summary>
<blockquote>
â€¢ <a href="#ch-indexable-_how_to__import">ğŸ“‘ <i>How to Import</i></a><br>
<details><summary><a href="#ch-indexable-_purpose">ğŸ“‘ <i>Purpose</i></a></summary>
<blockquote>
â€¢ <a href="#example">Example</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-indexable-_slices">ğŸ“‘ <i>Slices</i></a></summary>
<blockquote>
â€¢ <a href="#f-is_slice">âš™ï¸is_slice</a><br>
â€¢ <a href="#f-slice">âš™ï¸slice</a><br>
â€¢ <a href="#f-slice_to_range">âš™ï¸slice_to_range</a><br>
â€¢ <a href="#f-_slr_cache">âš™ï¸_slr_cache</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-indexable-_algorithm__adaptors">ğŸ“‘ <i>Algorithm Adaptors</i></a></summary>
<blockquote>
â€¢ <a href="#f-it_each">âš™ï¸it_each</a><br>
â€¢ <a href="#f-it_idxs">âš™ï¸it_idxs</a><br>
â€¢ <a href="#f-it_enum">âš™ï¸it_enum</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-indexable-_treat__all__indexables_the__same">ğŸ“‘ <i>Treat All Indexables the Same</i></a></summary>
<blockquote>
â€¢ <a href="#f-slr_len">âš™ï¸slr_len</a><br>
â€¢ <a href="#f-idx">âš™ï¸idx</a><br>
â€¢ <a href="#f-el">âš™ï¸el</a><br>
â€¢ <a href="#f-el_pos_idx">âš™ï¸el_pos_idx</a><br>
â€¢ <a href="#f-els">âš™ï¸els</a><br>
â€¢ <a href="#f-range_els">âš™ï¸range_els</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-indexable-_getting__traversing__indices">ğŸ“‘ <i>Getting/Traversing Indices</i></a></summary>
<blockquote>
â€¢ <a href="#f-idxs">âš™ï¸idxs</a><br>
â€¢ <a href="#f-fwd_i">âš™ï¸fwd_i</a><br>
â€¢ <a href="#f-rev_i">âš™ï¸rev_i</a><br>
â€¢ <a href="#f-next_in">âš™ï¸next_in</a><br>
â€¢ <a href="#f-prev_in">âš™ï¸prev_in</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-indexable-_functions_to__manipulate__strings_and__lists">ğŸ“‘ <i>Functions to Manipulate Strings and Lists</i></a></summary>
<blockquote>
â€¢ <a href="#f-push">âš™ï¸push</a><br>
â€¢ <a href="#f-pop">âš™ï¸pop</a><br>
â€¢ <a href="#f-unshift">âš™ï¸unshift</a><br>
â€¢ <a href="#f-shift">âš™ï¸shift</a><br>
â€¢ <a href="#f-insert">âš™ï¸insert</a><br>
â€¢ <a href="#f-remove">âš™ï¸remove</a><br>
â€¢ <a href="#f-remove_adjacent_dups">âš™ï¸remove_adjacent_dups</a><br>
â€¢ <a href="#f-remove_each">âš™ï¸remove_each</a><br>
â€¢ <a href="#f-replace">âš™ï¸replace</a><br>
â€¢ <a href="#f-replace_each">âš™ï¸replace_each</a><br>
â€¢ <a href="#f-swap">âš™ï¸swap</a><br>
â€¢ <a href="#f-rotate_left">âš™ï¸rotate_left</a><br>
â€¢ <a href="#f-rotate_right">âš™ï¸rotate_right</a><br>
â€¢ <a href="#f-head">âš™ï¸head</a><br>
â€¢ <a href="#f-head_multi">âš™ï¸head_multi</a><br>
â€¢ <a href="#f-tail">âš™ï¸tail</a><br>
â€¢ <a href="#f-tail_multi">âš™ï¸tail_multi</a><br>
â€¢ <a href="#f-osearch">âš™ï¸osearch</a><br>
â€¢ <a href="#f-csearch">âš™ï¸csearch</a><br>
â€¢ <a href="#f-quicksort_list_comp_ex">âš™ï¸quicksort_list_comp_ex</a><br>
â€¢ <a href="#f-quicksort_lib_ex1">âš™ï¸quicksort_lib_ex1</a><br>
â€¢ <a href="#f-quicksort_lib_ex2">âš™ï¸quicksort_lib_ex2</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-indexable-indexable_types">ğŸ“‘ <i>indexable types</i></a></summary>
<blockquote>
â€¢ <a href="#t-slice">ğŸ§©slice</a><br>
â€¢ <a href="#t-_birls">ğŸ§©Birls</a><br>
â€¢ <a href="#t-slr_cache">ğŸ§©slr_cache</a><br>
â€¢ <a href="#t-_get_ppmrrair_fn">ğŸ§©GetPpmrrairFn</a><br>
â€¢ <a href="#t-_equal_fn">ğŸ§©EqualFn</a><br>
â€¢ <a href="#t-_get_equal_fn">ğŸ§©GetEqualFn</a><br>
â€¢ <a href="#t-_remove_adjacent_dups_fn">ğŸ§©RemoveAdjacentDupsFn</a><br>
â€¢ <a href="#t-_replace_each_fn">ğŸ§©ReplaceEachFn</a><br>
â€¢ <a href="#t-_search_fn">ğŸ§©SearchFn</a><br>
â€¢ <a href="#t-_search_needle_fn">ğŸ§©SearchNeedleFn</a><br>
</blockquote>
</details>
</blockquote>
</details>

<details><summary><a href="#file-indexable_consts">ğŸ“˜ <b>indexable_consts</b></a></summary>
<blockquote>
â€¢ <a href="#ch-indexable_consts-_how_to__import">ğŸ“‘ <i>How to Import</i></a><br>
â€¢ <a href="#ch-indexable_consts-_purpose">ğŸ“‘ <i>Purpose</i></a><br>
<details><summary><a href="#ch-indexable_consts-_values">ğŸ“‘ <i>Values</i></a></summary>
<blockquote>
â€¢ <a href="#v-__s_l_r__c_a_c_h_e__h_e_a_d_e_r">ğŸ’ _SLR_CACHE_HEADER</a><br>
â€¢ <a href="#v-__s_l_r__l_e_n">ğŸ’ _SLR_LEN</a><br>
â€¢ <a href="#v-__s_l_r__t_e">ğŸ’ _SLR_TE</a><br>
â€¢ <a href="#v-__s_l_r__e_l_d">ğŸ’ _SLR_ELD</a><br>
â€¢ <a href="#v-__s_l_r__b_l_e_n">ğŸ’ _SLR_BLEN</a><br>
â€¢ <a href="#v-__s_l_r__e_l_i">ğŸ’ _SLR_ELI</a><br>
â€¢ <a href="#v-__s_l_r__i_d_x">ğŸ’ _SLR_IDX</a><br>
â€¢ <a href="#v-__s_l_r__s_t_r">ğŸ’ _SLR_STR</a><br>
â€¢ <a href="#v-__s_l_r__b_i_r_l">ğŸ’ _SLR_BIRL</a><br>
â€¢ <a href="#v-__s_l_r__e_n_d__i">ğŸ’ _SLR_END_I</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-indexable_consts-indexable_consts_types">ğŸ“‘ <i>indexable_consts types</i></a></summary>
<blockquote>
â€¢ <a href="#t-_slr_cache_enum">ğŸ§©SlrCacheEnum</a><br>
</blockquote>
</details>
</blockquote>
</details>

<details><summary><a href="#file-function">ğŸ“˜ <b>function</b></a></summary>
<blockquote>
â€¢ <a href="#ch-function-_how_to__import">ğŸ“‘ <i>How to Import</i></a><br>
â€¢ <a href="#ch-function-_purpose">ğŸ“‘ <i>Purpose</i></a><br>
<details><summary><a href="#ch-function-_function__introspection">ğŸ“‘ <i>Function Introspection</i></a></summary>
<blockquote>
â€¢ <a href="#f-param_count">âš™ï¸param_count</a><br>
â€¢ <a href="#f-apply_to_fn">âš™ï¸apply_to_fn</a><br>
â€¢ <a href="#f-apply_to_fn2">âš™ï¸apply_to_fn2</a><br>
</blockquote>
</details>
</blockquote>
</details>

<details><summary><a href="#file-test">ğŸ“˜ <b>test</b></a></summary>
<blockquote>
â€¢ <a href="#ch-test-_how_to__import">ğŸ“‘ <i>How to Import</i></a><br>
â€¢ <a href="#ch-test-_purpose">ğŸ“‘ <i>Purpose</i></a><br>
<details><summary><a href="#ch-test-_test__your__code_">ğŸ“‘ <i>Test Your Code!</i></a></summary>
<blockquote>
â€¢ <a href="#m-test_eq">ğŸ§ªtest_eq</a><br>
â€¢ <a href="#m-test_approx_eq">ğŸ§ªtest_approx_eq</a><br>
â€¢ <a href="#m-test_ne">ğŸ§ªtest_ne</a><br>
â€¢ <a href="#m-test_lt">ğŸ§ªtest_lt</a><br>
â€¢ <a href="#m-test_le">ğŸ§ªtest_le</a><br>
â€¢ <a href="#m-test_gt">ğŸ§ªtest_gt</a><br>
â€¢ <a href="#m-test_ge">ğŸ§ªtest_ge</a><br>
â€¢ <a href="#m-test_truthy">ğŸ§ªtest_truthy</a><br>
â€¢ <a href="#m-test_falsy">ğŸ§ªtest_falsy</a><br>
</blockquote>
</details>
</blockquote>
</details>

<details><summary><a href="#file-param_check">ğŸ“˜ <b>param_check</b></a></summary>
<blockquote>
â€¢ <a href="#ch-param_check-_how_to__import">ğŸ“‘ <i>How to Import</i></a><br>
â€¢ <a href="#ch-param_check-_purpose">ğŸ“‘ <i>Purpose</i></a><br>
<details><summary><a href="#ch-param_check-_type__checks">ğŸ“‘ <i>Type Checks</i></a></summary>
<blockquote>
â€¢ <a href="#f-verify_slr">âš™ï¸verify_slr</a><br>
â€¢ <a href="#f-verify_sl">âš™ï¸verify_sl</a><br>
â€¢ <a href="#f-verify_s">âš™ï¸verify_s</a><br>
â€¢ <a href="#f-verify_l">âš™ï¸verify_l</a><br>
â€¢ <a href="#f-verify_r">âš™ï¸verify_r</a><br>
â€¢ <a href="#f-verify_i">âš™ï¸verify_i</a><br>
â€¢ <a href="#f-verify_iu">âš™ï¸verify_iu</a><br>
â€¢ <a href="#f-verify_lu">âš™ï¸verify_lu</a><br>
â€¢ <a href="#f-verify_u">âš™ï¸verify_u</a><br>
â€¢ <a href="#f-verify_fn">âš™ï¸verify_fn</a><br>
â€¢ <a href="#f-verify_uu">âš™ï¸verify_uu</a><br>
â€¢ <a href="#f-verify_slice">âš™ï¸verify_slice</a><br>
â€¢ <a href="#f-verify_birlei">âš™ï¸verify_birlei</a><br>
â€¢ <a href="#f-verify_birlsei">âš™ï¸verify_birlsei</a><br>
â€¢ <a href="#f-verify_biei">âš™ï¸verify_biei</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-param_check-_value__checks">ğŸ“‘ <i>Value Checks</i></a></summary>
<blockquote>
â€¢ <a href="#f-verify_precache">âš™ï¸verify_precache</a><br>
â€¢ <a href="#f-verify_vbis">âš™ï¸verify_vbis</a><br>
â€¢ <a href="#f-verify_vbsis">âš™ï¸verify_vbsis</a><br>
â€¢ <a href="#f-_get_slr_len">âš™ï¸_get_slr_len</a><br>
â€¢ <a href="#f-verify_vi">âš™ï¸verify_vi</a><br>
â€¢ <a href="#f-verify_vie">âš™ï¸verify_vie</a><br>
â€¢ <a href="#f-verify_vpi">âš™ï¸verify_vpi</a><br>
â€¢ <a href="#f-verify_vpie">âš™ï¸verify_vpie</a><br>
â€¢ <a href="#f-verify_vlen">âš™ï¸verify_vlen</a><br>
â€¢ <a href="#f-verify_vblen">âš™ï¸verify_vblen</a><br>
â€¢ <a href="#f-verify_vbinc">âš™ï¸verify_vbinc</a><br>
â€¢ <a href="#f-verify_vnz">âš™ï¸verify_vnz</a><br>
â€¢ <a href="#f-verify_vpos">âš™ï¸verify_vpos</a><br>
â€¢ <a href="#f-verify_nesl">âš™ï¸verify_nesl</a><br>
</blockquote>
</details>
</blockquote>
</details>

<details><summary><a href="#file-transform">ğŸ“˜ <b>transform</b></a></summary>
<blockquote>
â€¢ <a href="#ch-transform-_how_to__import">ğŸ“‘ <i>How to Import</i></a><br>
â€¢ <a href="#ch-transform-_purpose">ğŸ“‘ <i>Purpose</i></a><br>
<details><summary><a href="#ch-transform-_generate__matrices_for__vector__transforms">ğŸ“‘ <i>Generate Matrices for Vector Transforms</i></a></summary>
<blockquote>
â€¢ <a href="#f-transpose">âš™ï¸transpose</a><br>
â€¢ <a href="#f-homogenise">âš™ï¸homogenise</a><br>
â€¢ <a href="#f-dehomogenise">âš™ï¸dehomogenise</a><br>
â€¢ <a href="#f-homogenise_transform">âš™ï¸homogenise_transform</a><br>
â€¢ <a href="#f-rot_x">âš™ï¸rot_x</a><br>
â€¢ <a href="#f-rot_y">âš™ï¸rot_y</a><br>
â€¢ <a href="#f-rot_z">âš™ï¸rot_z</a><br>
â€¢ <a href="#f-is_point">âš™ï¸is_point</a><br>
â€¢ <a href="#f-is_vector">âš™ï¸is_vector</a><br>
â€¢ <a href="#f-is_bound_vector">âš™ï¸is_bound_vector</a><br>
â€¢ <a href="#f-rot_axis">âš™ï¸rot_axis</a><br>
â€¢ <a href="#f-rotate">âš™ï¸rotate</a><br>
â€¢ <a href="#f-translate">âš™ï¸translate</a><br>
â€¢ <a href="#f-scale">âš™ï¸scale</a><br>
â€¢ <a href="#f-transform">âš™ï¸transform</a><br>
â€¢ <a href="#f-frame_transform">âš™ï¸frame_transform</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-transform-_matrix__math">ğŸ“‘ <i>Matrix Math</i></a></summary>
<blockquote>
â€¢ <a href="#f-invert">âš™ï¸invert</a><br>
â€¢ <a href="#f-row_reduction">âš™ï¸row_reduction</a><br>
â€¢ <a href="#f-identity">âš™ï¸identity</a><br>
â€¢ <a href="#f-augment">âš™ï¸augment</a><br>
â€¢ <a href="#f-_right_half">âš™ï¸_right_half</a><br>
â€¢ <a href="#f-_swap_rows">âš™ï¸_swap_rows</a><br>
â€¢ <a href="#f-_argmax_abs_col">âš™ï¸_argmax_abs_col</a><br>
â€¢ <a href="#f-_is_rect_matrix">âš™ï¸_is_rect_matrix</a><br>
â€¢ <a href="#f-_is_square_matrix">âš™ï¸_is_square_matrix</a><br>
â€¢ <a href="#f-_all_numeric">âš™ï¸_all_numeric</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-transform-transform_types">ğŸ“‘ <i>transform types</i></a></summary>
<blockquote>
â€¢ <a href="#t-_matrix">ğŸ§©Matrix</a><br>
â€¢ <a href="#t-_row3">ğŸ§©Row3</a><br>
â€¢ <a href="#t-_row4">ğŸ§©Row4</a><br>
â€¢ <a href="#t-_matrix3x3">ğŸ§©Matrix3x3</a><br>
â€¢ <a href="#t-_matrix4x4">ğŸ§©Matrix4x4</a><br>
â€¢ <a href="#t-_point2_d">ğŸ§©Point2D</a><br>
â€¢ <a href="#t-_point3_d">ğŸ§©Point3D</a><br>
â€¢ <a href="#t-_point">ğŸ§©Point</a><br>
â€¢ <a href="#t-_vector2_d">ğŸ§©Vector2D</a><br>
â€¢ <a href="#t-_vector3_d">ğŸ§©Vector3D</a><br>
â€¢ <a href="#t-_vector">ğŸ§©Vector</a><br>
â€¢ <a href="#t-_b_vector2_d">ğŸ§©BVector2D</a><br>
â€¢ <a href="#t-_b_vector3_d">ğŸ§©BVector3D</a><br>
â€¢ <a href="#t-_b_vector">ğŸ§©BVector</a><br>
â€¢ <a href="#t-_axis_frame_ref">ğŸ§©AxisFrameRef</a><br>
â€¢ <a href="#t-_planar_frame_ref">ğŸ§©PlanarFrameRef</a><br>
â€¢ <a href="#t-_spatial_frame_ref">ğŸ§©SpatialFrameRef</a><br>
â€¢ <a href="#t-_frame_ref">ğŸ§©FrameRef</a><br>
</blockquote>
</details>
</blockquote>
</details>

<details><summary><a href="#file-string">ğŸ“˜ <b>string</b></a></summary>
<blockquote>
â€¢ <a href="#ch-string-_how_to__import">ğŸ“‘ <i>How to Import</i></a><br>
<details><summary><a href="#ch-string-_purpose">ğŸ“‘ <i>Purpose</i></a></summary>
<blockquote>
â€¢ <a href="#f-align_left">âš™ï¸align_left</a><br>
â€¢ <a href="#f-align_right">âš™ï¸align_right</a><br>
â€¢ <a href="#f-repeat">âš™ï¸repeat</a><br>
â€¢ <a href="#f-_sign_str">âš™ï¸_sign_str</a><br>
â€¢ <a href="#f-float_to_string">âš™ï¸float_to_string</a><br>
â€¢ <a href="#f-obj_to_string">âš™ï¸obj_to_string</a><br>
â€¢ <a href="#f-to_csv">âš™ï¸to_csv</a><br>
â€¢ <a href="#f-list_to_string">âš™ï¸list_to_string</a><br>
â€¢ <a href="#f-fmt_list_fn">âš™ï¸fmt_list_fn</a><br>
â€¢ <a href="#f-fmt_pt_list_fn">âš™ï¸fmt_pt_list_fn</a><br>
â€¢ <a href="#f-fmt_pt_fn">âš™ï¸fmt_pt_fn</a><br>
â€¢ <a href="#f-pt_list_to_string">âš™ï¸pt_list_to_string</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-string-string_types">ğŸ“‘ <i>string types</i></a></summary>
<blockquote>
â€¢ <a href="#t-_show_sign_enum">ğŸ§©ShowSignEnum</a><br>
</blockquote>
</details>
</blockquote>
</details>

<details><summary><a href="#file-string_consts">ğŸ“˜ <b>string_consts</b></a></summary>
<blockquote>
â€¢ <a href="#ch-string_consts-_how_to__import">ğŸ“‘ <i>How to Import</i></a><br>
â€¢ <a href="#ch-string_consts-_purpose">ğŸ“‘ <i>Purpose</i></a><br>
<details><summary><a href="#ch-string_consts-_values_for__show_sign___parameters">ğŸ“‘ <i>Values for `show_sign` Parameters</i></a></summary>
<blockquote>
â€¢ <a href="#v-_s_h_o_w__s_i_g_n__n_e_g">ğŸ’ SHOW_SIGN_NEG</a><br>
â€¢ <a href="#v-_s_h_o_w__s_i_g_n__p_o_s__n_e_g">ğŸ’ SHOW_SIGN_POS_NEG</a><br>
â€¢ <a href="#v-_s_h_o_w__s_i_g_n__s_p_c__n_e_g">ğŸ’ SHOW_SIGN_SPC_NEG</a><br>
</blockquote>
</details>
</blockquote>
</details>

<details><summary><a href="#file-helpers">ğŸ“˜ <b>helpers</b></a></summary>
<blockquote>
â€¢ <a href="#ch-helpers-_how_to__import">ğŸ“‘ <i>How to Import</i></a><br>
â€¢ <a href="#ch-helpers-_purpose">ğŸ“‘ <i>Purpose</i></a><br>
<details><summary><a href="#ch-helpers-_conversion_functions">ğŸ“‘ <i>Conversion functions</i></a></summary>
<blockquote>
â€¢ <a href="#f-r2d">âš™ï¸r2d</a><br>
â€¢ <a href="#f-d2r">âš™ï¸d2r</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-helpers-_circular____spherical__calculations">ğŸ“‘ <i>Circular / Spherical Calculations</i></a></summary>
<blockquote>
â€¢ <a href="#f-arc_len">âš™ï¸arc_len</a><br>
â€¢ <a href="#f-arc_len_angle">âš™ï¸arc_len_angle</a><br>
â€¢ <a href="#f-_circle_line_intersections">âš™ï¸_circle_line_intersections</a><br>
â€¢ <a href="#f-_pick_right">âš™ï¸_pick_right</a><br>
â€¢ <a href="#f-_theta_deg">âš™ï¸_theta_deg</a><br>
â€¢ <a href="#f-_wrap_diff_deg">âš™ï¸_wrap_diff_deg</a><br>
â€¢ <a href="#f-arc_len_for_shift">âš™ï¸arc_len_for_shift</a><br>
â€¢ <a href="#f-shift_for_arc_len">âš™ï¸shift_for_arc_len</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-helpers-_miscellaneous">ğŸ“‘ <i>Miscellaneous</i></a></summary>
<blockquote>
â€¢ <a href="#f-not">âš™ï¸not</a><br>
â€¢ <a href="#f-clamp">âš™ï¸clamp</a><br>
â€¢ <a href="#f-vector_info">âš™ï¸vector_info</a><br>
â€¢ <a href="#f-equal">âš™ï¸equal</a><br>
â€¢ <a href="#f-function_equal">âš™ï¸function_equal</a><br>
â€¢ <a href="#f-default">âš™ï¸default</a><br>
â€¢ <a href="#f-_i_n_c_o_m_p_l_e_t_e">âš™ï¸INCOMPLETE</a><br>
â€¢ <a href="#f-offset_angle">âš™ï¸offset_angle</a><br>
â€¢ <a href="#m-arrow">ğŸ§Šarrow</a><br>
â€¢ <a href="#m-axis">ğŸ§Šaxis</a><br>
â€¢ <a href="#f-fl">âš™ï¸fl</a><br>
â€¢ <a href="#f-_assert">âš™ï¸Assert</a><br>
â€¢ <a href="#f-interpolated_values">âš™ï¸interpolated_values</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-helpers-helpers_types">ğŸ“‘ <i>helpers types</i></a></summary>
<blockquote>
â€¢ <a href="#t-_vector_info">ğŸ§©VectorInfo</a><br>
â€¢ <a href="#t-_identity_fn">ğŸ§©IdentityFn</a><br>
</blockquote>
</details>
</blockquote>
</details>

<details><summary><a href="#file-helpers_consts">ğŸ“˜ <b>helpers_consts</b></a></summary>
<blockquote>
â€¢ <a href="#ch-helpers_consts-_how_to__import">ğŸ“‘ <i>How to Import</i></a><br>
â€¢ <a href="#ch-helpers_consts-_purpose">ğŸ“‘ <i>Purpose</i></a><br>
<details><summary><a href="#ch-helpers_consts-_for_indexing_type___vector_info___t-_vector_info__">ğŸ“‘ <i>For indexing type [VectorInfo](#t-_vector_info).</i></a></summary>
<blockquote>
â€¢ <a href="#v-_v_i__v_e_c_t_o_r">ğŸ’ VI_VECTOR</a><br>
â€¢ <a href="#v-_v_i__l_e_n_g_t_h">ğŸ’ VI_LENGTH</a><br>
â€¢ <a href="#v-_v_i__d_i_r">ğŸ’ VI_DIR</a><br>
â€¢ <a href="#v-_v_i__n_o_r_m_a_l">ğŸ’ VI_NORMAL</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-helpers_consts-helpers_consts_types">ğŸ“‘ <i>helpers_consts types</i></a></summary>
<blockquote>
â€¢ <a href="#t-_vector_info_enum">ğŸ§©VectorInfoEnum</a><br>
</blockquote>
</details>
</blockquote>
</details>

<details><summary><a href="#file-skin">ğŸ“˜ <b>skin</b></a></summary>
<blockquote>
â€¢ <a href="#ch-skin-_how_to__import">ğŸ“‘ <i>How to Import</i></a><br>
â€¢ <a href="#ch-skin-_purpose">ğŸ“‘ <i>Purpose</i></a><br>
â€¢ <a href="#ch-skin-_design">ğŸ“‘ <i>Design</i></a><br>
<details><summary><a href="#ch-skin-_values">ğŸ“‘ <i>Values</i></a></summary>
<blockquote>
â€¢ <a href="#v-__s_k_i_n__i_d">ğŸ’ _SKIN_ID</a><br>
â€¢ <a href="#v-__s_k_i_n__p_t_s__i_n__l_a_y_e_r">ğŸ’ _SKIN_PTS_IN_LAYER</a><br>
â€¢ <a href="#v-__s_k_i_n__l_a_y_e_r_s">ğŸ’ _SKIN_LAYERS</a><br>
â€¢ <a href="#v-__s_k_i_n__p_t_s">ğŸ’ _SKIN_PTS</a><br>
â€¢ <a href="#v-__s_k_i_n__d_e_b_u_g__a_x_e_s">ğŸ’ _SKIN_DEBUG_AXES</a><br>
â€¢ <a href="#v-__s_k_i_n__c_o_m_m_e_n_t">ğŸ’ _SKIN_COMMENT</a><br>
â€¢ <a href="#v-__s_k_i_n__o_p_e_r_a_t_i_o_n">ğŸ’ _SKIN_OPERATION</a><br>
â€¢ <a href="#v-__s_k_i_n__w_a_l_l__d_i_a_g">ğŸ’ _SKIN_WALL_DIAG</a><br>
â€¢ <a href="#f-skin_to_string">âš™ï¸skin_to_string</a><br>
â€¢ <a href="#f-layer_pt">âš™ï¸layer_pt</a><br>
â€¢ <a href="#f-layer_pts">âš™ï¸layer_pts</a><br>
â€¢ <a href="#f-layer_side_faces">âš™ï¸layer_side_faces</a><br>
â€¢ <a href="#v-_ear_cw">ğŸ’ _ear_cw</a><br>
â€¢ <a href="#v-_ear_ccw">ğŸ’ _ear_ccw</a><br>
â€¢ <a href="#f-_pt_in_triangle">âš™ï¸_pt_in_triangle</a><br>
â€¢ <a href="#f-_any_point_in_ear">âš™ï¸_any_point_in_ear</a><br>
â€¢ <a href="#f-_cap_ears">âš™ï¸_cap_ears</a><br>
â€¢ <a href="#f-_proj_pts">âš™ï¸_proj_pts</a><br>
â€¢ <a href="#f-_proj_to_what_norm">âš™ï¸_proj_to_what_norm</a><br>
â€¢ <a href="#f-_cap_layer">âš™ï¸_cap_layer</a><br>
â€¢ <a href="#f-_cap_layers">âš™ï¸_cap_layers</a><br>
â€¢ <a href="#f-is_skin">âš™ï¸is_skin</a><br>
â€¢ <a href="#f-skin_new">âš™ï¸skin_new</a><br>
â€¢ <a href="#f-skin_extrude">âš™ï¸skin_extrude</a><br>
â€¢ <a href="#f-skin_create_faces">âš™ï¸skin_create_faces</a><br>
â€¢ <a href="#f-skin_transform">âš™ï¸skin_transform</a><br>
â€¢ <a href="#m-skin_to_polyhedron">ğŸ§Šskin_to_polyhedron</a><br>
â€¢ <a href="#f-skin_add_layer_if">âš™ï¸skin_add_layer_if</a><br>
â€¢ <a href="#f-skin_add_point_in_layer">âš™ï¸skin_add_point_in_layer</a><br>
â€¢ <a href="#m-skin_show_debug_axes">ğŸ§Šskin_show_debug_axes</a><br>
â€¢ <a href="#f-interpolate">âš™ï¸interpolate</a><br>
â€¢ <a href="#f-skin_limit">âš™ï¸skin_limit</a><br>
â€¢ <a href="#f-skin_verify">âš™ï¸skin_verify</a><br>
â€¢ <a href="#f-skin_max_layer_distance_fn">âš™ï¸skin_max_layer_distance_fn</a><br>
â€¢ <a href="#f-skin_max_pt_distance_fn">âš™ï¸skin_max_pt_distance_fn</a><br>
</blockquote>
</details>
<details><summary><a href="#ch-skin-skin_types">ğŸ“‘ <i>skin types</i></a></summary>
<blockquote>
â€¢ <a href="#t-skin">ğŸ§©skin</a><br>
â€¢ <a href="#t-_face">ğŸ§©Face</a><br>
â€¢ <a href="#t-_skin_extrude">ğŸ§©SkinExtrude</a><br>
â€¢ <a href="#t-_colour_lst">ğŸ§©ColourLst</a><br>
â€¢ <a href="#t-_colour_str">ğŸ§©ColourStr</a><br>
â€¢ <a href="#t-_colour_name">ğŸ§©ColourName</a><br>
â€¢ <a href="#t-_debug_style">ğŸ§©DebugStyle</a><br>
</blockquote>
</details>
</blockquote>
</details>

<hr/>

## ğŸ“˜range<a id='file-range'></a>

### <i>ğŸ“‘How to Import</i><a id='ch-range-_how_to__import'></a>

    use <range>

### <i>ğŸ“‘Purpose</i><a id='ch-range-_purpose'></a>

A range is a structure that can be iterated over, like one can do with a
list.  However, unlike in python, it:

1. Doesn't have the ability to index an element in the range
2. Doesn't have a simple means to determine if an object is a range object.
3. Doesn't have a way to interrogate it for its length.
4. Has a feature which if the end value is unreachable given an initial start
   and step value, it generates a warning.

This library is to help with those deficiencies.

> â„¹ï¸ NOTE:
>
> Ranges in OpenSCAD are closed ranges.  This means that if the step allows,
> the specified end value will be part of the iteration.  E.g. `range(1, 5)`
> will iterate on `1`, `2`, `3`, `4` *and* `5`, opposed to half open ranges
> like that used in python, where `range(1, 5)` would iterate on `1`, `2`,
> `3`, and `4`.

### <i>ğŸ“‘Test</i><a id='ch-range-_test'></a>

#### âš™ï¸is\_range<a id='f-is_range'></a>

<code>*function* is_range(o: any) : bool</code>

Tests if the object is a range object.

<details><summary>parameters</summary>

**<code>o</code>**: <code>any</code>

Object to test.

</details>

<details><summary>returns</summary>

**Returns**: <code>bool</code>

Returns `true` if object is a range, otherwise `false`.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘Functions</i><a id='ch-range-_functions'></a>

#### âš™ï¸range<a id='f-range'></a>

<code>*function* range(count\_or\_begin\_i: number, step\_or\_end\_i: number, end\_i: number) : <a href="#t-range">range</a>|list</code>

Possible callchains:

    range(count)                : (range|list)
    range(begin_i, end_i)       : (range|list)
    range(begin_i, step, end_i) : (range|list)

Creates a range object.

The callchains show the overloads, where `step` refers to the step count used
to go between `begin_i` and `end_i`.

> â„¹ï¸ NOTE:
>
> Will **not** generate a warning if step results in no elements in range,
> unlike `[ begin_i : end_i ]` or `[ begin_i : step : end_i ]`.  Instead,
> generates an empty list.

<details><summary>parameters</summary>

**<code>count_or_begin_i</code>**: <code>number</code>

- If `step_i_end_i` is `undef`, the number of indices to count, from `0` to
  `count_or_begin_i-1`.
  - If `â‰¤ 0` then returns an empty list.
- Else the beginning index.

**<code>step_or_end_i</code>**: <code>number</code> *(Optional)*

- If `end_i` is `undef`, then this is the end index.
- Else this is the step.

**<code>end_i</code>**: <code>number</code> *(Optional)*

- If a number, then this is the ending index.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-range">range</a>|list</code>

This is the range to iterate over.  If `step < 0 and begin_i < end_i or
step > 0 and begin_i > end_i or count <= 0`, then returns an empty list.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸range\_len<a id='f-range_len'></a>

<code>*function* range_len(r: <a href="#t-range">range</a>) : number</code>

Will return the number of elements the range will return.

> â„¹ï¸ NOTE:
>
> Assumes range was created with [`range()`](#f-range), so that the elements
> must be valid. E.g. `[ -B : +S : -E ]` will never occur as it would have
> been converted to `[]`.

<details><summary>parameters</summary>

**<code>r</code>**: <code><a href="#t-range">range</a></code>

The range to count how many indices it will iterate over.

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

The number of indices the range contains.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸range\_el<a id='f-range_el'></a>

<code>*function* range_el(r: <a href="#t-range">range</a>, i: number, \_r\_len: number|undef) : number</code>

Will return the element that would have been returned if left to iterate `i`
times.

> â„¹ï¸ NOTE:
>
> It is **UB** to dereference at an index that is not in the range.

<details><summary>parameters</summary>

**<code>r</code>**: <code><a href="#t-range">range</a></code>

The range to get index from if left to iterate `i` times.

**<code>i</code>**: <code>number</code>

The number iterations to have been done to get the return value.
If negative then start counting from end to beginning.

**<code>_r_len</code>**: <code>number|undef</code> *(Optional)*

Cached length of `r`.  Will calculate it if `undef`.

> â„¹ï¸ NOTE:
>
> This is a private parameter and it may disappear at any time in the
> future.  Use at your own peril!

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

The index to have retrieved if iterated over `i` times.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸range\_el\_pos\_idx<a id='f-range_el_pos_idx'></a>

<code>*function* range_el_pos_idx(r: <a href="#t-range">range</a>, i: number) : number</code>

Dereference range at index `i`, allowing only positive indices.

> â„¹ï¸ NOTE:
>
> It is **UB** to dereference at an index that is not in the range.

<details><summary>parameters</summary>

**<code>r</code>**: <code><a href="#t-range">range</a></code>

The range to get index from if left to iterate `i` times.

**<code>i</code>**: <code>number</code>

The number iterations to have been done to get the return value.
Must be positive `(i >= 0)`.

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

The index to have retrieved if iterated over `i` times.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸range\_idx<a id='f-range_idx'></a>

<code>*function* range_idx(r: <a href="#t-range">range</a>, i: number, \_r\_len: number|undef) : number</code>

Gets the index for a range.  Allows for negative values to reference
elements starting from the end going backwards.

<details><summary>parameters</summary>

**<code>r</code>**: <code><a href="#t-range">range</a></code>

The range to get the index for.

**<code>i</code>**: <code>number</code>

The index of the element.  If value is negative, then goes backward from
end of range.

**<code>_r_len</code>**: <code>number|undef</code> *(Optional)*

Cached length of `r`.  Will calculate it if `undef`.

> â„¹ï¸ NOTE:
>
> This is a private parameter and it may disappear at any time in the
> future.  Use at your own peril!

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

The positive index.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘range types</i><a id='ch-range-range_types'></a>

#### ğŸ§©range<a id='t-range'></a>

<code>*type* range = list</code>

An iterable range of numeric values that consists of a start, step and stop.
If step allows, stop is included in the range.

> â„¹ï¸ NOTE:
>
> Ranges in OpenSCAD are closed ranges.  This means that if the step allows,
> the specified end value will be part of the iteration.  E.g. `range(1, 5)`
> will iterate on `1`, `2`, `3`, `4` *and* `5`, opposed to half open ranges
> like that used in python, where `range(1, 5)` would iterate on `1`, `2`,
> `3`, and `4`.

> â„¹ï¸ NOTE:
>
> `len()` doesn't work on a range.  Use [`range_len()`](#f-range_len)
> instead.

<details><summary>slots</summary>
<code><b>0</b></code>: <code>number</code>

Beginning value.

<code><b>1</b></code>: <code>number</code>

Step value.

<code><b>2</b></code>: <code>number</code>

Stop value.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

<hr/>

## ğŸ“˜types<a id='file-types'></a>

### <i>ğŸ“‘How to Import</i><a id='ch-types-_how_to__import'></a>

    use <types>
    include <types_consts> // Symbol names for type enums.

### <i>ğŸ“‘Purpose</i><a id='ch-types-_purpose'></a>

This library allows representing types as enumerated values, strings or
minimal strings for complex types.

### <i>ğŸ“‘Tests</i><a id='ch-types-_tests'></a>

#### âš™ï¸is\_indexable\_te<a id='f-is_indexable_te'></a>

<code>*function* is_indexable_te(type\_enum: <a href="#t-TypeEnum">TypeEnum</a>) : bool</code>

States if a te (type_enum) represents an indexable type, either directly with
`sl[index]` or indirectly with `range_el(r, index)`.

<details><summary>parameters</summary>

**<code>type_enum</code>**: <code><a href="#t-TypeEnum">TypeEnum</a></code>

Enum for type (See [type_enum](#t-_type_enum))

</details>

<details><summary>returns</summary>

**Returns**: <code>bool</code>

Returns `true` if indexable, `false` otherwise.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸is\_int<a id='f-is_int'></a>

<code>*function* is_int(o: any) : bool</code>

States if object is an integer (has no fractional part).

<details><summary>parameters</summary>

**<code>o</code>**: <code>any</code>

Object to query.

</details>

<details><summary>returns</summary>

**Returns**: <code>bool</code>

Returns `true` if integer, `false` otherwise.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸is\_float<a id='f-is_float'></a>

<code>*function* is_float(o: any) : bool</code>

States if object is a float (has a fractional part).

<details><summary>parameters</summary>

**<code>o</code>**: <code>any</code>

Object to query.

</details>

<details><summary>returns</summary>

**Returns**: <code>bool</code>

Returns `true` if float, `false` otherwise.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸is\_nan<a id='f-is_nan'></a>

<code>*function* is_nan(n: any) : bool</code>

States if object is a NaN object.

<details><summary>parameters</summary>

**<code>n</code>**: <code>any</code>

Object to query.

</details>

<details><summary>returns</summary>

**Returns**: <code>bool</code>

Returns `true` if NaN, `false` otherwise.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘Type Introspection</i><a id='ch-types-_type__introspection'></a>

#### ğŸ’ \_TYPE\_NAMES<a id='v-__t_y_p_e__n_a_m_e_s'></a>

<code>*value* _TYPE_NAMES : list\[string]</code>

The names of the types indexed by the type enums.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸type\_enum<a id='f-type_enum'></a>

<code>*function* type_enum(o: any, distinguish\_float\_from\_int: bool) : number</code>

Function to get the type of an object as an enum.

<details><summary>parameters</summary>

**<code>o</code>**: <code>any</code>

The object to get the type from.

**<code>distinguish_float_from_int</code>**: <code>bool</code> *(Default: `false`)*

Flag to indicate if to distinguish floats from integers rather than
grouping them together as numbers.

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

The number corresponding to the type enum.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸type\_enum\_to\_str<a id='f-type_enum_to_str'></a>

<code>*function* type_enum_to_str(i: number) : string</code>

Convert the type enum to a string.

<details><summary>parameters</summary>

**<code>i</code>**: <code>number</code>

Type enum to convert.

</details>

<details><summary>returns</summary>

**Returns**: <code>string</code>

The string corresponding to the type enum.  If type enum is not recognised,
return "*INVALID TYPE*".

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸type<a id='f-type'></a>

<code>*function* type(o: any, distinguish\_float\_from\_int: bool) : string</code>

Gets a string representation of the type of `o`.

<details><summary>parameters</summary>

**<code>o</code>**: <code>any</code>

Object to query.

**<code>distinguish_float_from_int</code>**: <code>bool</code> *(Default: `false`)*

States if to distinguish a float from an int when detecting a number.

</details>

<details><summary>returns</summary>

**Returns**: <code>string</code>

Returns string representation of `o`'s type.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸type\_structure<a id='f-type_structure'></a>

<code>*function* type_structure(o: any) : string</code>

Attempts to simplify the type structure of object o recursively.

- If o is a list
  - if all elements in that list contain the same type structure,
    - simplify the list by only showing that structure once and append to it
      how many times it is repeated.
  - else if not the same, then recursively simplify each element.
- else it's some other type, so will just output the type of the object.

<details><summary>parameters</summary>

**<code>o</code>**: <code>any</code>

Gets the simplified type structure of o.

</details>

<details><summary>returns</summary>

**Returns**: <code>string</code>

This string is a representation of the type structure of o.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸type\_value<a id='f-type_value'></a>

<code>*function* type_value(o: any) : string</code>

Gives a string that outputs the type_structure and value of object passed in.

<details><summary>parameters</summary>

**<code>o</code>**: <code>any</code>

The object to list information about.

</details>

<details><summary>returns</summary>

**Returns**: <code>string</code>

Give info for `o` as string.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘types types</i><a id='ch-types-types_types'></a>

#### ğŸ§©TypeEnum<a id='t-_type_enum'></a>

<code>*type* TypeEnum = number</code>

Number representing a type.  Use [`type_enum_to_str()`](#f-type_enum_to_str)
to get name of type.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

<hr/>

## ğŸ“˜types_consts<a id='file-types_consts'></a>

### <i>ğŸ“‘How to Import</i><a id='ch-types_consts-_how_to__import'></a>

    include <types_consts>

### <i>ğŸ“‘Purpose</i><a id='ch-types_consts-_purpose'></a>

Constants representing the types as enumerated values.

### <i>ğŸ“‘Values</i><a id='ch-types_consts-_values'></a>

#### ğŸ’ RANGE<a id='v-_r_a_n_g_e'></a>

<code>*value* RANGE : <a href="#t-TypeEnum">TypeEnum</a></code>

Enum for range type

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
assert(type_enum([0:1]) == RANGE);
assert(type_enum(range(0,1)) == RANGE)
```

```openscad
// Beware, an empty range is a LIST!!
assert(type_enum(range(1,0)) == LIST)
```

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ LIST<a id='v-_l_i_s_t'></a>

<code>*value* LIST : <a href="#t-TypeEnum">TypeEnum</a></code>

Enum for list type

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
assert(type_enum([]) == LIST);
```

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ STR<a id='v-_s_t_r'></a>

<code>*value* STR : <a href="#t-TypeEnum">TypeEnum</a></code>

Enum for string type

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
assert(type_enum("") == STR);
```

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ UNKNOWN<a id='v-_u_n_k_n_o_w_n'></a>

<code>*value* UNKNOWN : <a href="#t-TypeEnum">TypeEnum</a></code>

Enum for unknown type.  Shouldn't be possible to get this value.

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
assert(type_enum(???) == UNKNOWN);
```

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ SLICE<a id='v-_s_l_i_c_e'></a>

<code>*value* SLICE : <a href="#t-TypeEnum">TypeEnum</a></code>

Enum for slice type

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
assert(type_enum(slice(0, -1)) == SLICE);
```

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ UNDEF<a id='v-_u_n_d_e_f'></a>

<code>*value* UNDEF : <a href="#t-TypeEnum">TypeEnum</a></code>

Enum for undef type

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
assert(type_enum(undef) == UNDEF);
```

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ BOOL<a id='v-_b_o_o_l'></a>

<code>*value* BOOL : <a href="#t-TypeEnum">TypeEnum</a></code>

Enum for boolean type

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
assert(type_enum(true) == BOOL);
```

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ FUNC<a id='v-_f_u_n_c'></a>

<code>*value* FUNC : <a href="#t-TypeEnum">TypeEnum</a></code>

Enum for function type

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
assert(type_enum(function() 0) == FUNC);
```

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ NUM<a id='v-_n_u_m'></a>

<code>*value* NUM : <a href="#t-TypeEnum">TypeEnum</a></code>

Enum for number type

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
assert(type_enum(1) == NUM);
```

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ INT<a id='v-_i_n_t'></a>

<code>*value* INT : <a href="#t-TypeEnum">TypeEnum</a></code>

Enum for integer type

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
assert(type_enum(1, true) == INT);
```

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ FLOAT<a id='v-_f_l_o_a_t'></a>

<code>*value* FLOAT : <a href="#t-TypeEnum">TypeEnum</a></code>

Enum for floating point type

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
assert(type_enum(1.1, true) == FLOAT);
```

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ NAN<a id='v-_n_a_n'></a>

<code>*value* NAN : <a href="#t-TypeEnum">TypeEnum</a></code>

Enum for NaN

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
assert(type_enum(1/0) == NAN);
```

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

<hr/>

## ğŸ“˜birlei<a id='file-birlei'></a>

### <i>ğŸ“‘How to Import</i><a id='ch-birlei-_how_to__import'></a>

    use <birlei>

### <i>ğŸ“‘Purpose</i><a id='ch-birlei-_purpose'></a>

This is the core of the library's algorithm set.  It evolved from having two
indices,
`begin_i` and `end_i` so that functions could be made to recursively iterate
over them.  However, it didn't contain a step, but there was already an
object that worked for list comprehension and it worked the same way as lists
would.

However, to actually use a range or list recursively, they would have to be
indexable in a similar way, so the [ranges](#file-range) library was made.
`begin_i` would be used to count to `end_i` over the length of the object,
dereferencing each element as needed.

Keeping this in the user facing API was done because just counting from N to
M is very common, and without dereferencing a list or range it's marginally
faster.

### <i>ğŸ“‘Functions</i><a id='ch-birlei-_functions'></a>

#### âš™ï¸birlei\_to\_begin\_i\_end\_i<a id='f-birlei_to_begin_i_end_i'></a>

<code>*function* birlei_to_begin_i_end_i(algo\_fn: function, ppmrrair\_fn: <a href="#t-PpmrrairFn">PpmrrairFn</a>, birl: <a href="#t-Birl">Birl</a>, end\_i: <a href="#t-EndI">EndI</a>) : any</code>

Helper which calls `algo_fn` but remaps signature `function(fn, birl, end_i)`
to signature `function(fn, begin_i, end_i, map_back_fn)`.

<details><summary>parameters</summary>

**<code>algo_fn</code>**: <code>function</code>

Function with `(fn, begin_i, end_i, map_back_fn)` signature to call, where:

- `fn`: `number`
  - ppmrrair function to call.
- `begin_i`: `number`
  - Starting index to operate on.
- `end_i`: `number`
  - Ending index to operate on.
- `map_back_fn`: `function(i: number|undef): (number|undef)`
  - When the algorithm is returning a number from the `birlei`, the
    algorithm is to pass the index it found to this function, which will
    remap it back to the `birlei` value.
  - If this function is passed `undef`, it returns `undef` for
    convenience.

**<code>ppmrrair_fn</code>**: <code><a href="#t-PpmrrairFn">PpmrrairFn</a></code>

- Takes index or element and possibly a second param and returns a value.

**<code>birl</code>**: <code><a href="#t-Birl">Birl</a></code>

- If `number`, start index to iterate over
- If `range`, indices to iterate over
- If `list`, indices to iterate over

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code>

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code>any</code>

Result of `algo_fn()`.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸birlei\_to\_indices<a id='f-birlei_to_indices'></a>

<code>*function* birlei_to_indices(birl: <a href="#t-Birl">Birl</a>, end\_i: <a href="#t-EndI">EndI</a>) : list|<a href="#t-range">range</a></code>

Helper to convert birlei parameters to an lr to traverse.

<details><summary>parameters</summary>

**<code>birl</code>**: <code><a href="#t-Birl">Birl</a></code>

- If `number`, start index to iterate over
- If `range`, indices to iterate over
- If `list`, indices to iterate over

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code>

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code>list|<a href="#t-range">range</a></code>

Returns a list or range describing the indices to traverse.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘birlei types</i><a id='ch-birlei-birlei_types'></a>

#### ğŸ§©Birl<a id='t-_birl'></a>

<code>*type* Birl = number|<a href="#t-range">range</a>|list</code>

- If `number`, start index to iterate over
- If `range`, indices to iterate over
- If `list`, indices to iterate over

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©EndI<a id='t-_end_i'></a>

<code>*type* EndI = number|undef</code>

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©SpaceshipFn<a id='t-_spaceship_fn'></a>

<code>*callback* SpaceshipFn(probe: any) : number</code>

Compares a derived comparison value against an internally stored value.

Definitions:

- probe: the argument passed to this callback by the algorithm.
- comparison value: the value derived from the probe that is actually
  compared to the stored value.

Probe convention:

- Without an [Algorithm Adaptor](#algorithm-adaptors), the probe is a number
  within the `birlei`.
- With an Algorithm Adaptor, the probe is the adaptor's output:
  - [`it_each`](#f-it_each): `slr_element`.
  - [`it_enum`](#f-it_enum): `[index, slr_element]`.
  - [`it_idxs`](#f-it_idxs): `index`.

The callback is responsible for mapping probe â†’ comparison value.  The
mapping is defined by the callback's closure over the searched structure (slr
or any other abstract structure) and/or by how it interprets adaptor outputs.

<details><summary>parameters</summary>

**<code>probe</code>**: <code>any</code>

The probe value as defined above.

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

- comparison value < stored value: return < 0
- comparison value == stored value: return 0
- comparison value > stored value: return > 0

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©PredFn<a id='t-_pred_fn'></a>

<code>*callback* PredFn(probe: any) : bool</code>

Compares a derived comparison value against an internally stored value.

Definitions:

- probe: the argument passed to this callback by the algorithm.
- comparison value: the value derived from the probe that is actually
  compared to the stored value.

Probe convention:

- Without an [Algorithm Adaptor](#algorithm-adaptors), the probe is a number
  within the `birlei`.
- With an Algorithm Adaptor, the probe is the adaptor's output:
  - [`it_each`](#f-it_each): `slr_element`.
  - [`it_enum`](#f-it_enum): `[index, slr_element]`.
  - [`it_idxs`](#f-it_idxs): `index`.

The callback is responsible for mapping probe â†’ comparison value.  The
mapping is defined by the callback's closure over the searched structure (slr
or any other abstract structure) and/or by how it interprets adaptor outputs.

<details><summary>parameters</summary>

**<code>probe</code>**: <code>any</code>

The probe value as defined above.

</details>

<details><summary>returns</summary>

**Returns**: <code>bool</code>

- comparison value matches stored value: return `true`
- comparison value doesn't match stored value: return `false`

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©ReductionFn<a id='t-_reduction_fn'></a>

<code>*callback* ReductionFn(probe: any, accumulator: any) : any</code>

Mutates the accumulator given a derived comparison value.

Definitions:

- probe: the argument passed to this callback by the algorithm.
- comparison value: the value derived from the probe that is actually
  compared to the stored value.

Probe convention:

- Without an [Algorithm Adaptor](#algorithm-adaptors), the probe is a number
  within the `birlei`.
- With an Algorithm Adaptor, the probe is the adaptor's output:
  - [`it_each`](#f-it_each): `slr_element`.
  - [`it_enum`](#f-it_enum): `[index, slr_element]`.
  - [`it_idxs`](#f-it_idxs): `index`.

The callback is responsible for mapping probe â†’ comparison value.  The
mapping is defined by the callback's closure over the searched structure (slr
or any other abstract structure) and/or by how it interprets adaptor outputs.

> â„¹ï¸ NOTE:
>
> `acc` **is the second parameter** which is different from most languages.
> This is to keep it consistent with the rest of the `PPMRRAIR` functions
> and this library in general.  You have been warned.

<details><summary>parameters</summary>

**<code>probe</code>**: <code>any</code>

The probe value as defined above.

**<code>accumulator</code>**: <code>any</code>

The accumulator being mutated.

</details>

<details><summary>returns</summary>

**Returns**: <code>any</code>

The newly mutated accumulator value or the initial value if the `birlei`
was empty.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©ReductionAirFn<a id='t-_reduction_air_fn'></a>

<code>*callback* ReductionAirFn(probe: any, accumulator: any) : list\[bool,any]</code>

Mutates the accumulator given a derived comparison value.

Definitions:

- probe: the argument passed to this callback by the algorithm.
- comparison value: the value derived from the probe that is actually
  compared to the stored value.

Probe convention:

- Without an [Algorithm Adaptor](#algorithm-adaptors), the probe is a number
  within the `birlei`.
- With an Algorithm Adaptor, the probe is the adaptor's output:
  - [`it_each`](#f-it_each): `slr_element`.
  - [`it_enum`](#f-it_enum): `[index, slr_element]`.
  - [`it_idxs`](#f-it_idxs): `index`.

The callback is responsible for mapping probe â†’ comparison value.  The
mapping is defined by the callback's closure over the searched structure (slr
or any other abstract structure) and/or by how it interprets adaptor outputs.

> â„¹ï¸ NOTE:
>
> `acc` **is the second parameter** which is different from most languages.
> This is to keep it consistent with the rest of the `PPMRRAIR` functions
> and this library in general.  You have been warned.

<details><summary>parameters</summary>

**<code>probe</code>**: <code>any</code>

The probe value as defined above.

**<code>accumulator</code>**: <code>any</code>

The accumulator being mutated.

</details>

<details><summary>returns</summary>

**Returns**: <code>list\[bool,any]</code>

List containing if to continue Boolean and the newly mutated accumulator
value.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©PredMapFn<a id='t-_pred_map_fn'></a>

<code>*callback* PredMapFn(probe: any, get\_value: bool) : any</code>

Compares a derived comparison value against an internally stored value or
returns a value, depending on the second parameter's truthiness.

Definitions:

- probe: the argument passed to this callback by the algorithm.
- comparison value: the value derived from the probe that is actually
  compared to the stored value.

Probe convention:

- Without an [Algorithm Adaptor](#algorithm-adaptors), the probe is a number
  within the `birlei`.
- With an Algorithm Adaptor, the probe is the adaptor's output:
  - [`it_each`](#f-it_each): `slr_element`.
  - [`it_enum`](#f-it_enum): `[index, slr_element]`.
  - [`it_idxs`](#f-it_idxs): `index`.

The callback is responsible for mapping probe â†’ comparison value.  The
mapping is defined by the callback's closure over the searched structure (slr
or any other abstract structure) and/or by how it interprets adaptor outputs.

<details><summary>parameters</summary>

**<code>probe</code>**: <code>any</code>

The probe value as defined above.

**<code>get_value</code>**: <code>bool</code> *(Default: `undef`)*

States if to return the predicate result or the probed value.

</details>

<details><summary>returns</summary>

**Returns**: <code>any</code>

- if `get_value` is falsy, then
  - comparison value matches stored value: return `true`
  - comparison value doesn't match stored value: return `false`
- else returns the probed value

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©MapperFn<a id='t-_mapper_fn'></a>

<code>*callback* MapperFn(probe: any) : any</code>

Maps a probed value to a list.

Definitions:

- probe: the argument passed to this callback by the algorithm.

Probe convention:

- Without an [Algorithm Adaptor](#algorithm-adaptors), the probe is a number
  within the `birlei`.
- With an Algorithm Adaptor, the probe is the adaptor's output:
  - [`it_each`](#f-it_each): `slr_element`.
  - [`it_enum`](#f-it_enum): `[index, slr_element]`.
  - [`it_idxs`](#f-it_idxs): `index`.

The callback is responsible for mapping probe value.  The mapping is defined
by the callback's closure over the searched structure (slr or any other
abstract structure) and/or by how it interprets adaptor outputs.

<details><summary>parameters</summary>

**<code>probe</code>**: <code>any</code>

The probe value as defined above.

</details>

<details><summary>returns</summary>

**Returns**: <code>any</code>

Value that was mapped given the probe.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©PpmrrairFn<a id='t-_ppmrrair_fn'></a>

<code>*type* PpmrrairFn = <a href="#t-SpaceshipFn">SpaceshipFn</a>|<a href="#t-PredFn">PredFn</a>|<a href="#t-ReductionFn">ReductionFn</a>|<a href="#t-ReductionAirFn">ReductionAirFn</a>|<a href="#t-PredMapFn">PredMapFn</a>|<a href="#t-MapperFn">MapperFn</a></code>

The exact meaning depends on the type expected.  For more info, go to the
type you are interested in.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©MapBackFn<a id='t-_map_back_fn'></a>

<code>*callback* MapBackFn(i: number|undef) : number|undef</code>

When an algorithm is iterating, it iterates over a contiguous set of
integers.  The original set of values don't have to be contiguous.  This
function, remaps the contiguous integers back to the original set of values.

<details><summary>parameters</summary>

**<code>i</code>**: <code>number|undef</code>

Index to remap or undef if no index to remap.

</details>

<details><summary>returns</summary>

**Returns**: <code>number|undef</code>

- If originating algo_fn is returning an index, this function will map it
  to the correct index.
- If passed undef, returns undef.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

<hr/>

## ğŸ“˜base_algos<a id='file-base_algos'></a>

### <i>ğŸ“‘How to Import</i><a id='ch-base_algos-_how_to__import'></a>

    use <base_algos>

### <i>ğŸ“‘Purpose</i><a id='ch-base_algos-_purpose'></a>

The purpose of this library is to provide the minimum number of abstracted
composable algorithms to be able to make coding easier, both when reading and
writing.  They are quite fast, and although you could prolly make faster hand
rolled implementations, IMHO this makes it easier to read and rationalise as
to intent.  Also, the pattern used is repeated everywhere, making it easier
to learn how to use.

### <i>ğŸ“‘FYI: Functions and Iterating are Abound!</i><a id='ch-base_algos-_f_y_i____functions_and__iterating_are__abound_'></a>

There is a lot of currying and passing of functions in this library.  (Mmmmmm
curry!)  No, not that type of curry.  Currying relates to having a function
return a function and using that function immediately.  For instance.  Say I
want to find the first instance of the letter "t" in a string.  Using this
library, the following could be done:

```openscad
s = "Hello there!";
i = find(fwd_i(s))(function(i)
      s[i] == "t"
    );
```

Or it could be done using the algorithm adaptor `it_each` (See
[Algorithm Adaptors](#algorithm-adaptors)):

```openscad
s = "Hello there!";
i = it_each(s, find())(function(c)
      c == "t"
    );
```

You'll notice the occurrence of `)(`.  This ends the algorithm or adaptor
call and start the next call which takes a function to test each element.
Also, observe that when the algorithm's `birlei` parameter is omitted, a
`function(birl, end_i)` is returned, which in this case is the function that
executes the `find` algorithm.  This reduces the algorithm down to standard
function signature.

These 2 basic patterns are used everywhere in the library set, and though it
might look odd at first, you'll find that it becomes natural quite quickly.

### <i>ğŸ“‘Iterators:</i><a id='ch-base_algos-_iterators__'></a>

The algorithms are index, not element centric, which means that a physical
container (i.e. a list) is *not* needed.  A virtual container (i.e. function)
is all that is required.  The indices act as iterators as one might find in
C++.  However, unlike C++ and python ranges, which are half open ranges
`[begin, end)`, these are closed ranges `[begin, end]`, meaning that the end
item is the last item in the range, not one past the end.

For each of these algorithms, the `birl` parameter (formally
`begin_i_range_or_list`, but it became too much to type) state either:

1. Starting index (number)
   - Implies that a second `end_i` parameter will indicate the inclusive end
     index (number), conforming to OpenSCAD's closed range paradigm.
2. Indices (range)
   - Will go through each item in the range and use them as indices to pass
     to the algorithm.  `end_i` must be `undef`.
3. Indices (list)
   - Will go through each element in the list and use them as indices to pass
     to the algorithm.  `end_i` must be `undef`.

### <i>ğŸ“‘Algorithms</i><a id='ch-base_algos-_algorithms'></a>

There are 4 basic algorithms (`reduce`, `reduce_air`, `filter` and `map`),
from which most other algorithms can be built.  For optimisation purposes,
`reduce_air` adds the ability to `A`llow an `I`ncomplete `R`eduction (hence
the `_air` suffix) over the range and filter adds a hybrid filter/map
feature.

A few others (`find`, `find_upper`, `find_lower`) could have been implemented
with `reduce_air` but have been optimised with their own implementations.

The `find*` and `reduce*` algorithms rely on recursive descent, but conform
to TCO (Tail Call Optimisation) so don't have a maximum depth.  The `filter`
and `map` algorithms use list comprehension so also have no limit to their
range size.

> ğŸ¤” TO THINK ABOUT:
>
> Should reduce_air's `init` param be `[ start, init ]` instead?  This would
> allow it to do nothing without the need for a special ternary check
> preceding it.
>
> A: I've yet not seen a good reason to do this.

### <i>ğŸ“‘Algorithm Signatures</i><a id='ch-base_algos-_algorithm__signatures'></a>

All of the algorithms have a compatible signature that have a `birlei` (one
or two parameters, a `birl` and optional `end_i`).  When you call the
algorithm without the `birlei` parameter, it returns a function that takes
only a `birlei` parameter.  This is used with the
[Algorithms Adaptor](#algorithm-adaptors), potentially simplifying your code.
When it's passed a `birlei`, it returns a function that requires a PPMRRAIR
function.  That function that is then called by the algorithm on each index
that the `birlei` refers to.

### <i>ğŸ“‘PPMRRAIR functions</i><a id='ch-base_algos-_p_p_m_r_r_a_i_r_functions'></a>

Named after the 4 function types: `P`redicate, `P`redicate/`M`ap, `R`eduction
and `R`eduction that `A`llows for `I`ncomplete `R`eduction, these functions
are passed to the algorithms where the algorithms then call them iteratively
over each `birlei` element:

#### **Predicate** (`function(i) : result`)

- A binary predicate is used by `find` and `filter`.  It has 2 results,
  truthy or falsy.
- A trinary predicate is used with `find_lower` and `find_upper`.  It has 3
  results: less than 0, equal to 0 and greater than 0.  This is akin to the
  spaceship operator in c++20.

#### **Predicate/Map** (`function(i, v) : any`)

- Optionally used by `filter`.
- If v is not passed then it has a falsy value (`undef`) indicating that the
  function is to act like a binary predicate.  Otherwise, if passed a true
  value, then it the function usually returns the element at that index,
  though can return anything which is to be placed in the resulting list.
- This 2 parameter function is a performance and memory allocation
  optimisation, allowing `filter` to do a `map` in the same step.

#### **Reduction** (`function(i, acc) : acc`)

- Used by `reduce`.
- Takes in the index and the previous accumulated object and returns the
  new accumulated object.
- This is roughly equivalent to a for_each loop in C++.

> â„¹ï¸ NOTE:
>
> `acc` **is the second parameter** which is different from most languages.
> This is to keep it consistent with the rest of the `PPMRRAIR` functions
> and this library in general.  You have been warned.

#### **Reduction, Allow Incomplete Reduction** (`function(i, acc) : [cont, acc]`)

- Used by `reduce_air`.
- Takes in the index and the previous accumulated object and returns a
  list `[ cont, new_acc ]`, where `cont` states if to continue looping if not
  finished iterating over the `birlei`.
- This is roughly equivalent to a for loop in C++.

> â„¹ï¸ NOTE:
>
> `acc` **is the second parameter** which is different from most languages.
> This is to keep it consistent with the rest of the `PPMRRAIR` functions
> and this library in general.  You have been warned.

**See also** [Algorithm Adaptors](#algorithm-adaptors).

### <i>ğŸ“‘The Base Algorithms</i><a id='ch-base_algos-_the__base__algorithms'></a>

#### âš™ï¸find\_lower<a id='f-find_lower'></a>

<code>*function* find_lower(birl: <a href="#t-OptionalBirl">OptionalBirl</a>, end\_i: <a href="#t-EndI">EndI</a>) : <a href="#t-FindLowerFn">FindLowerFn</a>|<a href="#t-FindLowerBirleiFn">FindLowerBirleiFn</a></code>

Possible callchains:

    find_lower(birl, end_i)    (spaceship_fn) : (number|undef)
    find_lower() (birl, end_i) (spaceship_fn) : (number|undef)

Like C++'s `lower_bound`: returns the first index `i` for which
`spaceship_fn(i) >= 0`.

> â„¹ï¸ NOTE:
>
> The specified `birlei` of indices must be such that `spaceship_fn(i)`
> is monotonically nondecreasing over the searched indices; or the results
> are **UB**.

<details><summary><b>Example:</b><i> Find first element >= target in a sorted list</i></summary>

```openscad
use <base_algos>
use <indexable>

xs = [1, 3, 3, 5, 8];
target = 3;

// spaceship_fn(i) is negative when xs[i] < target,
// zero when xs[i] == target,
// positive when xs[i] > target.
idx = find_lower(fwd_i(xs))(
  function(i) xs[i] - target
);

// idx == 1  (first 3)
```



</details><details><summary><b>Example:</b><i> If not found, result is undef</i></summary>

```openscad
xs = [1, 3, 3, 5, 8];
target = 9;

idx = find_lower(fwd_i(xs))(
  function(i) xs[i] - target
);

assert(idx == undef);
```

</details>

<details><summary>parameters</summary>

**<code>birl</code>**: <code><a href="#t-OptionalBirl">OptionalBirl</a></code> *(Optional)*

- If `number`, start index to iterate over
- If `range`, indices to iterate over
- If `list`, indices to iterate over
- If `undef`, then tells function to return a curried version of itself,
  that only takes parameters of types `Birl` and `EndI`.

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Optional)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-FindLowerFn">FindLowerFn</a>|<a href="#t-FindLowerBirleiFn">FindLowerBirleiFn</a></code>

- If `birl` is omitted, then will return type `FindLowerBirleiFn`.
- Else returns type `FindLowerFn`.

Possible callchains:

    FindLowerFn(spaceship_fn) : (number|undef)
    FindLowerBirleiFn(birl, end_i) (spaceship_fn) : (number|undef)

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸find\_upper<a id='f-find_upper'></a>

<code>*function* find_upper(birl: <a href="#t-OptionalBirl">OptionalBirl</a>, end\_i: <a href="#t-EndI">EndI</a>) : <a href="#t-FindUpperFn">FindUpperFn</a>|<a href="#t-FindUpperBirleiFn">FindUpperBirleiFn</a></code>

Possible callchains:

    find_upper(birl, end_i)    (spaceship_fn) : (number|undef)
    find_upper() (birl, end_i) (spaceship_fn) : (number|undef)

Like C++'s `upper_bound`: returns the first index `i` for which
`spaceship_fn(i) > 0`.

> â„¹ï¸ NOTE:
>
> The specified `birlei` of indices must be such that `spaceship_fn(i)`
> is monotonically nondecreasing over the searched indices; or the results
> are **UB**.

<details><summary>parameters</summary>

**<code>birl</code>**: <code><a href="#t-OptionalBirl">OptionalBirl</a></code> *(Optional)*

- If `number`, start index to iterate over
- If `range`, indices to iterate over
- If `list`, indices to iterate over
- If `undef`, then tells function to return a curried version of itself,
  that only takes parameters of types `Birl` and `EndI`.

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Optional)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-FindUpperFn">FindUpperFn</a>|<a href="#t-FindUpperBirleiFn">FindUpperBirleiFn</a></code>

- If `birl` is omitted, then will return type `FindUpperBirleiFn`.
- Else returns type `FindUpperFn`.

Possible callchains:

    FindUpperFn(spaceship_fn) : (number|undef)
    FindUpperBirleiFn(birl, end_i) (spaceship_fn) : (number|undef)

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸find<a id='f-find'></a>

<code>*function* find(birl: <a href="#t-OptionalBirl">OptionalBirl</a>, end\_i: <a href="#t-EndI">EndI</a>) : <a href="#t-FindFn">FindFn</a>|<a href="#t-FindBirleiFn">FindBirleiFn</a></code>

Possible callchains:

    find(birl, end_i)    (pred_fn) : (number|undef)
    find() (birl, end_i) (pred_fn) : (number|undef)

Returns the first index that results in `pred_fn(i)` returning a truthy
result.

<details><summary>parameters</summary>

**<code>birl</code>**: <code><a href="#t-OptionalBirl">OptionalBirl</a></code> *(Optional)*

- If `number`, start index to iterate over
- If `range`, indices to iterate over
- If `list`, indices to iterate over
- If `undef`, then tells function to return a curried version of itself,
  that only takes parameters of types `Birl` and `EndI`.

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Optional)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-FindFn">FindFn</a>|<a href="#t-FindBirleiFn">FindBirleiFn</a></code>

- If `birl` is omitted, then will return type `FindBirleiFn`.
- Else returns type `FindFn`.

Possible callchains:

    FindFn(pred_fn) : (number|undef)
    FindBirleiFn(birl, end_i) (pred_fn) : (number|undef)

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸reduce<a id='f-reduce'></a>

<code>*function* reduce(init: any, birl: <a href="#t-OptionalBirl">OptionalBirl</a>, end\_i: <a href="#t-EndI">EndI</a>) : <a href="#t-ReduceFn">ReduceFn</a>|<a href="#t-ReduceBirleiFn">ReduceBirleiFn</a></code>

Possible callchains:

    reduce(init, birl, end_i)  (op_fn) : any
    reduce(init) (birl, end_i) (op_fn) : any

Reduces (a.k.a. folds) a set of indices to produce some value/object based on
the indices.

<details><summary>parameters</summary>

**<code>init</code>**: <code>any</code>

This is the initial value that is passed to the first iteration of `op_fn`
as the accumulator.

**<code>birl</code>**: <code><a href="#t-OptionalBirl">OptionalBirl</a></code> *(Optional)*

- If `number`, start index to iterate over
- If `range`, indices to iterate over
- If `list`, indices to iterate over
- If `undef`, then tells function to return a curried version of itself,
  that only takes parameters of types `Birl` and `EndI`.

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Optional)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-ReduceFn">ReduceFn</a>|<a href="#t-ReduceBirleiFn">ReduceBirleiFn</a></code>

- If `birl` is omitted, then will return type `ReduceBirleiFn`.
- Else returns type `ReduceFn`.

Possible callchains:

    ReduceFn(reduction_fn) : any
    ReduceBirleiFn(birl, end_i) (reduction_fn) : any

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸reduce\_air<a id='f-reduce_air'></a>

<code>*function* reduce_air(init: any, birl: <a href="#t-OptionalBirl">OptionalBirl</a>, end\_i: <a href="#t-EndI">EndI</a>) : <a href="#t-ReduceAirFn">ReduceAirFn</a>|<a href="#t-ReduceAirBirleiFn">ReduceAirBirleiFn</a></code>

Possible callchains:

    reduce_air(init, birl, end_i)  (op_fn) : list[bool, any]
    reduce_air(init) (birl, end_i) (op_fn) : list[bool, any]

Reduces (a.k.a. folds) a set of indices to produce some value/object based on
the indices.  This Reduction Allows for Incomplete Reduction.

<details><summary>parameters</summary>

**<code>init</code>**: <code>any</code>

This is the initial value that is passed to the first iteration of `op_fn`
as the accumulator.

**<code>birl</code>**: <code><a href="#t-OptionalBirl">OptionalBirl</a></code> *(Optional)*

- If `number`, start index to iterate over
- If `range`, indices to iterate over
- If `list`, indices to iterate over
- If `undef`, then tells function to return a curried version of itself,
  that only takes parameters of types `Birl` and `EndI`.

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Optional)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-ReduceAirFn">ReduceAirFn</a>|<a href="#t-ReduceAirBirleiFn">ReduceAirBirleiFn</a></code>

- If `birl` is omitted, then will return type `ReduceAirBirleiFn`.
- Else returns type `ReduceAirFn`.

Possible callchains:

    ReduceAirFn(reduction_fn) : list[bool,any]
    ReduceAirBirleiFn(birl, end_i) (reduction_fn) : list[bool,any]

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸filter<a id='f-filter'></a>

<code>*function* filter(birl: <a href="#t-OptionalBirl">OptionalBirl</a>, end\_i: <a href="#t-EndI">EndI</a>) : <a href="#t-FilterFn">FilterFn</a>|<a href="#t-FilterBirleiFn">FilterBirleiFn</a></code>

Possible callchains:

    filter(birl, end_i)    (ppm_fn) : list
    filter() (birl, end_i) (ppm_fn) : list

Filter function.

<details><summary>parameters</summary>

**<code>birl</code>**: <code><a href="#t-OptionalBirl">OptionalBirl</a></code> *(Optional)*

- If `number`, start index to iterate over
- If `range`, indices to iterate over
- If `list`, indices to iterate over
- If `undef`, then tells function to return a curried version of itself,
  that only takes parameters of types `Birl` and `EndI`.

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Optional)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-FilterFn">FilterFn</a>|<a href="#t-FilterBirleiFn">FilterBirleiFn</a></code>

- If `birl` is omitted, then will return type `FilterBirleiFn`.
- Else returns type `FilterFn`.

Possible callchains:

    FilterFn(ppm_fn) : list[any,...]
    FilterBirleiFn(birl, end_i) (ppm_fn) : list[any,...]

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸map<a id='f-map'></a>

<code>*function* map(birl: <a href="#t-OptionalBirl">OptionalBirl</a>, end\_i: <a href="#t-EndI">EndI</a>) : <a href="#t-MapFn">MapFn</a>|<a href="#t-MapBirleiFn">MapBirleiFn</a></code>

Possible callchains:

    map(birl, end_i)    (map_fn) : list
    map() (birl, end_i) (map_fn) : list

Map indices or list elements to values, producing a list that has as many
elements as indices provided.

<details><summary>parameters</summary>

**<code>birl</code>**: <code><a href="#t-OptionalBirl">OptionalBirl</a></code> *(Optional)*

- If `number`, start index to iterate over
- If `range`, indices to iterate over
- If `list`, indices to iterate over
- If `undef`, then tells function to return a curried version of itself,
  that only takes parameters of types `Birl` and `EndI`.

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Optional)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-MapFn">MapFn</a>|<a href="#t-MapBirleiFn">MapBirleiFn</a></code>

- If `birl` is omitted, then will return type `MapBirleiFn`.
- Else returns type `MapFn`.

Possible callchains:

    MapFn(map_fn) : list[any,...]
    MapBirleiFn(birl, end_i) (map_fn) : list[any,...]

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘base_algos types</i><a id='ch-base_algos-base_algos_types'></a>

#### ğŸ§©BoundIndexFn<a id='t-_bound_index_fn'></a>

<code>*callback* BoundIndexFn(spaceship\_fn: <a href="#t-SpaceshipFn">SpaceshipFn</a>) : number|undef</code>

<details><summary>parameters</summary>

**<code>spaceship_fn</code>**: <code><a href="#t-SpaceshipFn">SpaceshipFn</a></code>

Compares a derived comparison value against an internally stored value.

Definitions:

- probe: the argument passed to this callback by the algorithm.
- comparison value: the value derived from the probe that is actually
  compared to the stored value.

Probe convention:

- Without an [Algorithm Adaptor](#algorithm-adaptors), the probe is a number
  within the `birlei`.
- With an Algorithm Adaptor, the probe is the adaptor's output:
  - [`it_each`](#f-it_each): `slr_element`.
  - [`it_enum`](#f-it_enum): `[index, slr_element]`.
  - [`it_idxs`](#f-it_idxs): `index`.

The callback is responsible for mapping probe â†’ comparison value.  The
mapping is defined by the callback's closure over the searched structure (slr
or any other abstract structure) and/or by how it interprets adaptor outputs.

</details>

<details><summary>returns</summary>

**Returns**: <code>number|undef</code>

Index of the selected bound, or `undef` if no such index exists.

> â„¹ï¸ NOTE:
>
> `undef` is returned rather than `end_i+1` because the searched indices
> can be noncontiguous (range/list selectors).

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©OptionalBirl<a id='t-_optional_birl'></a>

<code>*type* OptionalBirl = number|<a href="#t-range">range</a>|list|undef</code>

- If `number`, start index to iterate over
- If `range`, indices to iterate over
- If `list`, indices to iterate over
- If `undef`, then tells function to return a curried version of itself,
  that only takes parameters of types `Birl` and `EndI`.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©AlgoFn<a id='t-_algo_fn'></a>

<code>*callback* AlgoFn(birl: <a href="#t-Birl">Birl</a>, end\_i: <a href="#t-EndI">EndI</a>) : any</code>

Executes the algorithm.

<details><summary>parameters</summary>

**<code>birl</code>**: <code><a href="#t-Birl">Birl</a></code>

- If `number`, start index to iterate over
- If `range`, indices to iterate over
- If `list`, indices to iterate over

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Optional)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code>any</code>

Returned value is based on the result of the function doing the iterating.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©FindLowerFn<a id='t-_find_lower_fn'></a>

<code>*callback* FindLowerFn(spaceship\_fn: <a href="#t-SpaceshipFn">SpaceshipFn</a>) : number|undef</code>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©FindLowerBirleiFn<a id='t-_find_lower_birlei_fn'></a>

<code>*callback* FindLowerBirleiFn(birl: <a href="#t-Birl">Birl</a>, end\_i: <a href="#t-EndI">EndI</a>) : any</code>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©FindUpperFn<a id='t-_find_upper_fn'></a>

<code>*callback* FindUpperFn(spaceship\_fn: <a href="#t-SpaceshipFn">SpaceshipFn</a>) : number|undef</code>

Returns the first index `i` where `spaceship_fn(i) > 0`.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©FindUpperFn<a id='t-_find_upper_fn'></a>

<code>*callback* FindUpperFn(spaceship\_fn: <a href="#t-SpaceshipFn">SpaceshipFn</a>) : number|undef</code>

Possible callchains:

    FindUpperFn(spaceship_fn) : (number|undef)

<details><summary>parameters</summary>

**<code>spaceship_fn</code>**: <code><a href="#t-SpaceshipFn">SpaceshipFn</a></code>

Compares a derived comparison value against an internally stored value.

Definitions:

- probe: the argument passed to this callback by the algorithm.
- comparison value: the value derived from the probe that is actually
  compared to the stored value.

Probe convention:

- Without an [Algorithm Adaptor](#algorithm-adaptors), the probe is a number
  within the `birlei`.
- With an Algorithm Adaptor, the probe is the adaptor's output:
  - [`it_each`](#f-it_each): `slr_element`.
  - [`it_enum`](#f-it_enum): `[index, slr_element]`.
  - [`it_idxs`](#f-it_idxs): `index`.

The callback is responsible for mapping probe â†’ comparison value.  The
mapping is defined by the callback's closure over the searched structure (slr
or any other abstract structure) and/or by how it interprets adaptor outputs.

</details>

<details><summary>returns</summary>

**Returns**: <code>number|undef</code>

The first index `i` where `spaceship_fn(i) > 0` or `undef` if none found.

> â„¹ï¸ NOTE:
>
> The reason for returning `undef` rather than `end_i+1`, is because `birl`
> could be a noncontiguous `range` or `list` of indices.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©FindUpperBirleiFn<a id='t-_find_upper_birlei_fn'></a>

<code>*callback* FindUpperBirleiFn(birl: <a href="#t-Birl">Birl</a>, end\_i: <a href="#t-EndI">EndI</a>) : any</code>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©FindFn<a id='t-_find_fn'></a>

<code>*callback* FindFn(pred\_fn: <a href="#t-PredFn">PredFn</a>) : number|undef</code>

<details><summary>parameters</summary>

**<code>pred_fn</code>**: <code><a href="#t-PredFn">PredFn</a></code>

Compares a derived comparison value against an internally stored value.

Definitions:

- probe: the argument passed to this callback by the algorithm.
- comparison value: the value derived from the probe that is actually
  compared to the stored value.

Probe convention:

- Without an [Algorithm Adaptor](#algorithm-adaptors), the probe is a number
  within the `birlei`.
- With an Algorithm Adaptor, the probe is the adaptor's output:
  - [`it_each`](#f-it_each): `slr_element`.
  - [`it_enum`](#f-it_enum): `[index, slr_element]`.
  - [`it_idxs`](#f-it_idxs): `index`.

The callback is responsible for mapping probe â†’ comparison value.  The
mapping is defined by the callback's closure over the searched structure (slr
or any other abstract structure) and/or by how it interprets adaptor outputs.

</details>

<details><summary>returns</summary>

**Returns**: <code>number|undef</code>

First index where `pred_fn(i)` is `true`.  If none are found, returns
`undef`.

> â„¹ï¸ NOTE:
>
> The reason for returning `undef` rather than `end_i+1`, is because `birl`
> could be a noncontiguous `range` or `list` of indices.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©FindBirleiFn<a id='t-_find_birlei_fn'></a>

<code>*callback* FindBirleiFn(birl: <a href="#t-Birl">Birl</a>, end\_i: <a href="#t-EndI">EndI</a>) : any</code>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©ReduceFn<a id='t-_reduce_fn'></a>

<code>*callback* ReduceFn(reduction\_fn: <a href="#t-ReductionFn">ReductionFn</a>) : any</code>

<details><summary>parameters</summary>

**<code>reduction_fn</code>**: <code><a href="#t-ReductionFn">ReductionFn</a></code>

Mutates the accumulator given a derived comparison value.

Definitions:

- probe: the argument passed to this callback by the algorithm.
- comparison value: the value derived from the probe that is actually
  compared to the stored value.

Probe convention:

- Without an [Algorithm Adaptor](#algorithm-adaptors), the probe is a number
  within the `birlei`.
- With an Algorithm Adaptor, the probe is the adaptor's output:
  - [`it_each`](#f-it_each): `slr_element`.
  - [`it_enum`](#f-it_enum): `[index, slr_element]`.
  - [`it_idxs`](#f-it_idxs): `index`.

The callback is responsible for mapping probe â†’ comparison value.  The
mapping is defined by the callback's closure over the searched structure (slr
or any other abstract structure) and/or by how it interprets adaptor outputs.

> â„¹ï¸ NOTE:
>
> `acc` **is the second parameter** which is different from most languages.
> This is to keep it consistent with the rest of the `PPMRRAIR` functions
> and this library in general.  You have been warned.

</details>

<details><summary>returns</summary>

**Returns**: <code>any</code>

Final value of accumulator.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©ReduceBirleiFn<a id='t-_reduce_birlei_fn'></a>

<code>*callback* ReduceBirleiFn(birl: <a href="#t-Birl">Birl</a>, end\_i: <a href="#t-EndI">EndI</a>) : any</code>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©ReduceAirFn<a id='t-_reduce_air_fn'></a>

<code>*callback* ReduceAirFn(reduction\_fn: <a href="#t-ReductionAirFn">ReductionAirFn</a>) : list\[bool,any]</code>

<details><summary>parameters</summary>

**<code>reduction_fn</code>**: <code><a href="#t-ReductionAirFn">ReductionAirFn</a></code>

Mutates the accumulator given a derived comparison value.

Definitions:

- probe: the argument passed to this callback by the algorithm.
- comparison value: the value derived from the probe that is actually
  compared to the stored value.

Probe convention:

- Without an [Algorithm Adaptor](#algorithm-adaptors), the probe is a number
  within the `birlei`.
- With an Algorithm Adaptor, the probe is the adaptor's output:
  - [`it_each`](#f-it_each): `slr_element`.
  - [`it_enum`](#f-it_enum): `[index, slr_element]`.
  - [`it_idxs`](#f-it_idxs): `index`.

The callback is responsible for mapping probe â†’ comparison value.  The
mapping is defined by the callback's closure over the searched structure (slr
or any other abstract structure) and/or by how it interprets adaptor outputs.

> â„¹ï¸ NOTE:
>
> `acc` **is the second parameter** which is different from most languages.
> This is to keep it consistent with the rest of the `PPMRRAIR` functions
> and this library in general.  You have been warned.

</details>

<details><summary>returns</summary>

**Returns**: <code>list\[bool,any]</code>

Last continue value and the final value of accumulator.  If the original
 `birlei` was empty will contain `[true, init]`.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©ReduceAirBirleiFn<a id='t-_reduce_air_birlei_fn'></a>

<code>*callback* ReduceAirBirleiFn(birl: <a href="#t-Birl">Birl</a>, end\_i: <a href="#t-EndI">EndI</a>) : any</code>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©FilterFn<a id='t-_filter_fn'></a>

<code>*callback* FilterFn(ppm\_fn: <a href="#t-PredFn">PredFn</a>|<a href="#t-PredMapFn">PredMapFn</a>) : list\[any,...]</code>

<details><summary>parameters</summary>

**<code>ppm_fn</code>**: <code><a href="#t-PredFn">PredFn</a>|<a href="#t-PredMapFn">PredMapFn</a></code>

</details>

<details><summary>returns</summary>

**Returns**: <code>list\[any,...]</code>

A list of elements where the predicate returned true.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©FilterBirleiFn<a id='t-_filter_birlei_fn'></a>

<code>*callback* FilterBirleiFn(birl: <a href="#t-Birl">Birl</a>, end\_i: <a href="#t-EndI">EndI</a>) : any</code>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©MapFn<a id='t-_map_fn'></a>

<code>*callback* MapFn(map\_fn: <a href="#t-MapperFn">MapperFn</a>) : list\[any,...]</code>

<details><summary>parameters</summary>

**<code>map_fn</code>**: <code><a href="#t-MapperFn">MapperFn</a></code>

Maps a probed value to a list.

Definitions:

- probe: the argument passed to this callback by the algorithm.

Probe convention:

- Without an [Algorithm Adaptor](#algorithm-adaptors), the probe is a number
  within the `birlei`.
- With an Algorithm Adaptor, the probe is the adaptor's output:
  - [`it_each`](#f-it_each): `slr_element`.
  - [`it_enum`](#f-it_enum): `[index, slr_element]`.
  - [`it_idxs`](#f-it_idxs): `index`.

The callback is responsible for mapping probe value.  The mapping is defined
by the callback's closure over the searched structure (slr or any other
abstract structure) and/or by how it interprets adaptor outputs.

</details>

<details><summary>returns</summary>

**Returns**: <code>list\[any,...]</code>

A list of elements that were mapped.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©MapBirleiFn<a id='t-_map_birlei_fn'></a>

<code>*callback* MapBirleiFn(birl: <a href="#t-Birl">Birl</a>, end\_i: <a href="#t-EndI">EndI</a>) : any</code>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

<hr/>

## ğŸ“˜any_all<a id='file-any_all'></a>

### <i>ğŸ“‘How to Import</i><a id='ch-any_all-_how_to__import'></a>

    use <any_all>

### <i>ğŸ“‘Purpose</i><a id='ch-any_all-_purpose'></a>

Implements any and all algorithms.

#### âš™ï¸any<a id='f-any'></a>

<code>*function* any(birl: <a href="#t-OptionalBirl">OptionalBirl</a>, end\_i: <a href="#t-EndI">EndI</a>) : <a href="#t-AnyFn">AnyFn</a>|bool</code>

Possible callchains:

    any() (birl, end_i) : bool
    any(birl, end_i)    : bool

Will determine if any of the calls to pred_fn(i) will result in a truthy
result.

<details><summary>parameters</summary>

**<code>birl</code>**: <code><a href="#t-OptionalBirl">OptionalBirl</a></code> *(Optional)*

- If `number`, start index to iterate over
- If `range`, indices to iterate over
- If `list`, indices to iterate over
- If `undef`, then tells function to return a curried version of itself,
  that only takes parameters of types `Birl` and `EndI`.

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Optional)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-AnyFn">AnyFn</a>|bool</code>

- If `birl` is omitted, then will return type `AnyBirleiFn`.
- Else returns type `AnyFn`.

Possible callchains:

    AnyFn(pred_fn) : bool

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸all<a id='f-all'></a>

<code>*function* all(birl: <a href="#t-OptionalBirl">OptionalBirl</a>, end\_i: <a href="#t-EndI">EndI</a>) : function(pred_fn: <a href="#t-PredFn">PredFn</a>): bool</code>

Possible callchains:

    all()            : AllBirleiFn
    all(birl, end_i) : bool

Will determine if all of the calls to pred_fn(i) will result in a truthy
result.

<details><summary>parameters</summary>

**<code>birl</code>**: <code><a href="#t-OptionalBirl">OptionalBirl</a></code> *(Optional)*

- If `number`, start index to iterate over
- If `range`, indices to iterate over
- If `list`, indices to iterate over
- If `undef`, then tells function to return a curried version of itself,
  that only takes parameters of types `Birl` and `EndI`.

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Optional)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code>function(pred_fn: <a href="#t-PredFn">PredFn</a>): bool</code>

If all pred_fn(i) calls returns truthy, then returns true, otherwise
false.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘any_all types</i><a id='ch-any_all-any_all_types'></a>

#### ğŸ§©AnyFn<a id='t-_any_fn'></a>

<code>*callback* AnyFn(pred\_fn: <a href="#t-PredFn">PredFn</a>) : bool</code>

<details><summary>parameters</summary>

**<code>pred_fn</code>**: <code><a href="#t-PredFn">PredFn</a></code>

Compares a derived comparison value against an internally stored value.

Definitions:

- probe: the argument passed to this callback by the algorithm.
- comparison value: the value derived from the probe that is actually
  compared to the stored value.

Probe convention:

- Without an [Algorithm Adaptor](#algorithm-adaptors), the probe is a number
  within the `birlei`.
- With an Algorithm Adaptor, the probe is the adaptor's output:
  - [`it_each`](#f-it_each): `slr_element`.
  - [`it_enum`](#f-it_enum): `[index, slr_element]`.
  - [`it_idxs`](#f-it_idxs): `index`.

The callback is responsible for mapping probe â†’ comparison value.  The
mapping is defined by the callback's closure over the searched structure (slr
or any other abstract structure) and/or by how it interprets adaptor outputs.

</details>

<details><summary>returns</summary>

**Returns**: <code>bool</code>

First index where `pred_fn(i)` is `true` will result in `true`, else
`false`.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©AnyBirleiFn<a id='t-_any_birlei_fn'></a>

<code>*callback* AnyBirleiFn(birl: <a href="#t-Birl">Birl</a>, end\_i: <a href="#t-EndI">EndI</a>) : any</code>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©AllFn<a id='t-_all_fn'></a>

<code>*callback* AllFn(pred\_fn: <a href="#t-PredFn">PredFn</a>) : number|undef</code>

<details><summary>parameters</summary>

**<code>pred_fn</code>**: <code><a href="#t-PredFn">PredFn</a></code>

Compares a derived comparison value against an internally stored value.

Definitions:

- probe: the argument passed to this callback by the algorithm.
- comparison value: the value derived from the probe that is actually
  compared to the stored value.

Probe convention:

- Without an [Algorithm Adaptor](#algorithm-adaptors), the probe is a number
  within the `birlei`.
- With an Algorithm Adaptor, the probe is the adaptor's output:
  - [`it_each`](#f-it_each): `slr_element`.
  - [`it_enum`](#f-it_enum): `[index, slr_element]`.
  - [`it_idxs`](#f-it_idxs): `index`.

The callback is responsible for mapping probe â†’ comparison value.  The
mapping is defined by the callback's closure over the searched structure (slr
or any other abstract structure) and/or by how it interprets adaptor outputs.

</details>

<details><summary>returns</summary>

**Returns**: <code>number|undef</code>

First index where `pred_fn(i)` is `false` will result in `false`, else
`true`.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©AllBirleiFn<a id='t-_all_birlei_fn'></a>

<code>*callback* AllBirleiFn(birl: <a href="#t-Birl">Birl</a>, end\_i: <a href="#t-EndI">EndI</a>) : any</code>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

<hr/>

## ğŸ“˜indexable<a id='file-indexable'></a>

### <i>ğŸ“‘How to Import</i><a id='ch-indexable-_how_to__import'></a>

    use <indexable>

    // Only necessary if implementing your own algo that takes a slice.
    include <indexable_consts>

### <i>ğŸ“‘Purpose</i><a id='ch-indexable-_purpose'></a>

Treats all indexable objects similarly.  As a group, they are referred to as
`slr`s (`s`tring, `l`ist or `r`ange).  Any function that can take an indexable
reference and a `birlsei` can have the `birlsei` partially or completely
omitted (defaults to the start and end indices of the indexable).  To iterate
backwards, use a reverse `range`, `rev_i`, or a reverse `slice` (step < 0).

#### Example

```openscad
hello = "hello"
echo(els(hello, range(4, -1, 0)));
echo(els(hello, rev_i(hello)));
echo(els(hello, slice(-1, -1, 0)));
```

Would output
```
ECHO: "olleh"
ECHO: "olleh"
ECHO: "olleh"
```

> â„¹ï¸ NOTE:
>
> `birlei` (`begin_i`, `range`, or `list`, and `end_i`) is not the same as
> `birlsei` (`begin_i`, `range`, `list`, or `slice`, and `end_i`).
>
> - `birlei` is a general index specification and is not tied to any `slr`.
>   It may contain any integers (including negatives).
>
> - `birlsei` is a `birlei` that is tied to a specific `slr`.  It consists of
>   positive `slr` indices `(0..slr_len(slr)-1)` or no indices.
>
> <details><summary><b>TL;DR</b></summary>
>
> **`birlei` (not tied to any `slr`) can represent any number:**
>
> - `(begin_i, end_i)` pair.
>
>   Produces an empty `birlei` if `end_i < begin_i`.  Otherwise iterates over
>   the contiguous indices `begin_i .. end_i` (inclusive).
>
> - `list`: any list of integers `[ eâ‚, eâ‚‚, ... eâ‚™ ]`.
>
>   Produces an empty `birlei` if `n == 0`.  Otherwise iterates over all list
>   elements in order.
>
> - `range`: closed `range(begin_i, step, end_i)`.
>
>   Requires `step â‰  0`.  Produces an empty `birlei` if:
>
>   - `step > 0` and `end_i < begin_i`, or
>   - `step < 0` and `begin_i < end_i`.
>
>   Otherwise iterates the closed range.
>
>
> **`birlsei` (tied to an `slr`) can only represent positive numbers:**
>
> - `(begin_i, end_i)` pair.
>
>   `begin_i` and `end_i` are indices, so they must satisfy:
>
>       0 â‰¤ begin_i < slr_len(slr) and 0 â‰¤ end_i < slr_len(slr)
>
>   Produces an empty `birlsei` if `end_i < begin_i`.  Otherwise iterates over
>   the contiguous indices `begin_i .. end_i` (inclusive), and requires:
>
>       0 â‰¤ begin_i â‰¤ end_i < slr_len(slr)
>
> - `list`: any list of indices `[ eâ‚, eâ‚‚, ... eâ‚™ ]`.
>
>   Produces an empty `birlsei` if `n == 0`.  Otherwise requires for every
>   element:
>
>       0 â‰¤ eáµ¢ < slr_len(slr)
>
> - `range`: closed `range(begin_i, step, end_i)`.
>
>   Requires `step â‰  0` and:
>
>       0 â‰¤ begin_i < slr_len(slr) and 0 â‰¤ end_i < slr_len(slr)
>
>   Produces an empty `birlsei` if:
>
>   - `step > 0` and `end_i < begin_i`, or
>   - `step < 0` and `begin_i < end_i`.
>
>   Otherwise iterates the closed range.
>
> - slice: closed `slice(begin_i, step, end_i)`.
>
>   Requires `step â‰  0`.  A slice becomes iterable only when applied to an
>   `slr` (implicit call to `slice_to_range()`).
>
>   The resulting range may be empty.  When non-empty, its endpoints are
>   valid indices:
>
>       0 â‰¤ begin_i < slr_len(slr) and 0 â‰¤ end_i < slr_len(slr)
>
>   Iteration rules then follow the range rules above (based on `step` and
>   the ordering of `begin_i` and `end_i`).
>
> </details>

### <i>ğŸ“‘Slices</i><a id='ch-indexable-_slices'></a>

A `slice` is an object similar to a `range`, but it's not a realised
indexable object until it is paired with an `slr`.

#### âš™ï¸is\_slice<a id='f-is_slice'></a>

<code>*function* is_slice(o: any) : bool</code>

Check if object is a `slice` object.

<details><summary>parameters</summary>

**<code>o</code>**: <code>any</code>

Object to check.

</details>

<details><summary>returns</summary>

**Returns**: <code>bool</code>

`true` if object is a slice, `false` otherwise.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸slice<a id='f-slice'></a>

<code>*function* slice(begin\_i: number, step\_or\_end\_i: number, end\_i: number|undef) : <a href="#t-slice">slice</a></code>

Possible callchains:

    slice(begin_i, end_i)       : slice
    slice(begin_i, step, end_i) : slice

Create a `slice` object.

The callchains show the overloads, where `step` refers to the step count used
to go between `begin_i` and `end_i`.

<details><summary>parameters</summary>

**<code>begin_i</code>**: <code>number</code>

The first index of the slice.  If negative, then counts backward from end
of slr being referred to.

**<code>step_or_end_i</code>**: <code>number</code>

- If `end_i` not defined, then refers to the last index of the sequence.
  - If negative, then counts backward from end of `slr` being referred to.
- If `end_i` is defined, then refers to the step count used to go between
  `begin_i` and `end_i`.

**<code>end_i</code>**: <code>number|undef</code>

If defined, then the last index of the slice.  If negative, then counts
backward from end of slr being referred to.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-slice">slice</a></code>

Returns a slice object.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸slice\_to\_range<a id='f-slice_to_range'></a>

<code>*function* slice_to_range(slice: <a href="#t-slice">slice</a>, slr: string|list|<a href="#t-range">range</a>, \_slr\_len: number) : <a href="#t-range">range</a>|list</code>

Possible callchains:

    slice_to_range(slice, slr)           : (range|list)
    slice_to_range(slice, slr, _slr_len) : (range|list)

Converts a slice to a range when given a particular `slr`.

<details><summary>parameters</summary>

**<code>slice</code>**: <code><a href="#t-slice">slice</a></code>

The slice being converted.

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

The `slr` used as reference.

**<code>_slr_len</code>**: <code>number</code> *(Optional)*

If passed, then use that cached value instead of calculating `len(slr)`.

> â„¹ï¸ NOTE:
>
> This is a private parameter and it may disappear at any time in the
> future.  Use at your own peril!

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-range">range</a>|list</code>

A range that corresponds to what the slice is to do given an `slr`.
If the slice is completely before or after the slr, returns [].

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸\_slr\_cache<a id='f-_slr_cache'></a>

<code>*function* _slr_cache(slr: string|list|<a href="#t-range">range</a>, birls: <a href="#t-Birls">Birls</a>, end\_i: <a href="#t-EndI">EndI</a>) : <a href="#t-slr_cache">slr_cache</a></code>

A `birlsei` may be incomplete or may be a slice. This function normalise it
to a `birlei` such that:

1. If `is_num(birls) && is_undef(end_i)` then `end_i` is the index of the
   last element.
2. If `is_slice(birls)`, then convert to a a range using `slice_to_range()`.

> â„¹ï¸ NOTE:
>
> The `birlei` can represent only positive indices.

The returned array can be dereferenced using the \_SLR_* constants, which can
be included using the command `include<indexable_consts>` (DO NOT USE
`use<>`).

> â„¹ï¸ NOTE:
>
> All functions that dereference the slr or normalised `birlsei` are fully
> unrolled and optimized for their specific slr type, so will be faster when
> compared with using `el()` or `idx()` calls.

> ğŸ¤” TO THINK ABOUT:
>
> Do we need a _SLR_BTE to store the type of the normalised `birlsei`?
>
> Answer:
>
> I would think that testing using is_num(birls), is_list(birls) and
> is_num(`birls[0]`) would be faster than using a stored \_SLR\_BTE, unless
> considering using a dispatch table, which would require function call
> overhead, so is prolly not worth it.

> ğŸ¤” TO THINK ABOUT:
>
> Do we need the normalised `birlsei` to house values that are positive and
> negative?  Can we just make it house just positive values?
>
> Answer:
>
> No, if that's really needed, just add the `birlei` length to the index
> needed.  Don't want to slow things down in the most common case.

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

The `slr` used as reference.

**<code>birls</code>**: <code><a href="#t-Birls">Birls</a></code> *(Default: `0`)*

- If `number`, start index to iterate over.
- If `range`, indices to iterate over.
- If `list`, indices to iterate over.
- If `slice`, to convert to range providing indices to iterate over.

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Default: `idx(slr, -1)`)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-slr_cache">slr_cache</a></code>

 Normalised values:
 `[ header, slr_len, slr_te, eld_fn, blen, eli_fn, idx_fn, str_fn, birl, end_i ]`

 > MICRO OPTIMIZATION:
 >
 > On normalisation, if a birl is not a number, then end_i will not be
 > allocated.  Referencing that value will return undef and should be
 > marginally faster than having to actually get the undef value if it was
 > allocated.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘Algorithm Adaptors</i><a id='ch-indexable-_algorithm__adaptors'></a>

The `PPMRRAIR` functions usually are passed an integer as it's first
parameter, referring to the current index.  For convenience, there are
adaptor functions which allow referencing a `slr`'s element values.

- [`it_each`](#f-it_each): passes `slr_element`.
- [`it_enum`](#f-it_enum): passes `[index, slr_element]`.
- [`it_idxs`](#f-it_idxs): passes `index`.

Using these adaptors allows the use the length of the `slr` as reference if
the `birlsei` is partially or fully omitted.

#### âš™ï¸it\_each<a id='f-it_each'></a>

<code>*function* it_each(slr: string|list|<a href="#t-range">range</a>, algo\_fn: <a href="#t-AlgoFn">AlgoFn</a>, birls: <a href="#t-Birls">Birls</a>, end\_i: <a href="#t-EndI">EndI</a>) : <a href="#t-GetPpmrrairFn">GetPpmrrairFn</a></code>

Possible callchains:

    it_each(slr, algo_fn, birls, end_i) (ppmrrair_fn) : any

This convenience function will execute function `algo_fn` as if it were used
on a collection, remapping the first parameter being passed to `ppmrrair_fn`
so that it receives the <i>`element`</i> rather than the *index*.  Uses the
`slr` as a reference so that `birlsei` can be partially or fully omitted.
The `birlsei` is then normalised to a `birlei` and forwarded to `algo_fn`.

<details><summary><b>Example:</b><i> Using algorithm directly</i></summary>


```openscad
a = [1,2,3,4,5]
even_indices = filter(fwd_i(a))(function(i) a[i] % 2);
even_values  = filter(fwd_i(a))(function(i, v) v ? a[i] : a[i] % 2);
```



</details><details><summary><b>Example:</b><i> Using algorithm indirectly with <code>it_each()</code></i></summary>


```openscad
a = [1,2,3,4,5]
even_indices = it_each(a, filter())(function(e) e % 2);
even_values  = it_each(a, filter())(function(e, v) v ? e : e % 2);
```

</details>

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

This is the list to take element data from.

**<code>algo_fn</code>**: <code><a href="#t-AlgoFn">AlgoFn</a></code>

This is the operation function that is called. E.g. find(), filter(), etc.

**<code>birls</code>**: <code><a href="#t-Birls">Birls</a></code> *(Default: `0`)*

- If `number`, start index to iterate over.
- If `range`, indices to iterate over.
- If `list`, indices to iterate over.
- If `slice`, to convert to range providing indices to iterate over.

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Default: `idx(slr, -1)`)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-GetPpmrrairFn">GetPpmrrairFn</a></code>

The ppmrrair function that the specified `algo_fn()` will call.

Possible callchains:

    GetPpmrrairFn(ppmrrair_fn) : any

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸it\_idxs<a id='f-it_idxs'></a>

<code>*function* it_idxs(slr: string|list|<a href="#t-range">range</a>, algo\_fn: <a href="#t-AlgoFn">AlgoFn</a>, birls: <a href="#t-Birls">Birls</a>, end\_i: <a href="#t-EndI">EndI</a>) : <a href="#t-GetPpmrrairFn">GetPpmrrairFn</a></code>

Possible callchains:

    it_idxs(slr, algo_fn, birls, end_i) (ppmrrair_fn) : any

This convenience function will execute function `algo_fn` as if it were used
on a collection, `ppmrrair_fn` will still receive the *index*.  Uses the
`slr` as a reference so that `birlsei` can be partially or fully omitted.
The `birlsei` is then normalised to a `birlei` and forwarded to `algo_fn`.

<details><summary><b>Example:</b><i> Using algorithm directly</i></summary>


```openscad
a = [1,2,3,4,5]
even_indices = filter(fwd_i(a))(function(i) a[i] % 2);
even_values  = filter(fwd_i(a))(function(i, v) v ? a[i] : a[i] % 2);
```



</details><details><summary><b>Example:</b><i> Using algorithm indirectly with <code>it_idxs()</code></i></summary>


```openscad
a = [1,2,3,4,5]
even_indices = it_idxs(a, filter())(function(i) a[i] % 2);
even_values  = it_idxs(a, filter())(function(i, v) v ? a[i] : a[i] % 2);
```

</details>

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

This is the list to take element data from.

**<code>algo_fn</code>**: <code><a href="#t-AlgoFn">AlgoFn</a></code>

This is the operation function that is called. E.g. find(), filter(), etc.

**<code>birls</code>**: <code><a href="#t-Birls">Birls</a></code> *(Default: `0`)*

- If `number`, start index to iterate over.
- If `range`, indices to iterate over.
- If `list`, indices to iterate over.
- If `slice`, to convert to range providing indices to iterate over.

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Default: `idx(slr, -1)`)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-GetPpmrrairFn">GetPpmrrairFn</a></code>

The ppmrrair function that the specified `algo_fn()` will call.

Possible callchains:

    GetPpmrrairFn(ppmrrair_fn) : any

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸it\_enum<a id='f-it_enum'></a>

<code>*function* it_enum(slr: string|list|<a href="#t-range">range</a>, algo\_fn: <a href="#t-AlgoFn">AlgoFn</a>, birls: <a href="#t-Birls">Birls</a>, end\_i: <a href="#t-EndI">EndI</a>) : <a href="#t-GetPpmrrairFn">GetPpmrrairFn</a></code>

Possible callchains:

    it_enum(slr, algo_fn, birls, end_i) (ppmrrair_fn) : any

This convenience function will execute function `algo_fn` as if it were used
on a collection, remapping the first parameter being passed to `ppmrrair_fn`
so that it receives <i>`[index, element]`</i> rather than the *index*.  Uses
the `slr` as a reference so that `birlsei` can be partially or fully omitted.
The `birlsei` is then normalised to a `birlei` and forwarded to `algo_fn`.

**Example:**

<details><summary><b>Example:</b><i> Using algorithm directly</i></summary>


```openscad
a = [1,2,3,4,5]
even_indices = filter(fwd_i(a))(function(i) a[i] % 2);
even_values  = filter(fwd_i(a))(function(i, v) v ? a[i] : a[i] % 2);
```



</details><details><summary><b>Example:</b><i> Using algorithm indirectly with <code>it_enum()</code></i></summary>


```openscad
a = [1,2,3,4,5]
even_indices = it_enum(a, filter())(function(p) p[0] % 2);
even_values  = it_enum(a, filter())(function(p, v) v ? p[1] : p[0] % 2);
```

</details>

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

This is the list to take element data from.

**<code>algo_fn</code>**: <code><a href="#t-AlgoFn">AlgoFn</a></code>

This is the operation function that is called. E.g. find(), filter(), etc.

**<code>birls</code>**: <code><a href="#t-Birls">Birls</a></code> *(Default: `0`)*

- If `number`, start index to iterate over.
- If `range`, indices to iterate over.
- If `list`, indices to iterate over.
- If `slice`, to convert to range providing indices to iterate over.

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Default: `idx(slr, -1)`)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-GetPpmrrairFn">GetPpmrrairFn</a></code>

The ppmrrair function that the specified `algo_fn()` will call.

Possible callchains:

    GetPpmrrairFn(ppmrrair_fn) : any

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘Treat All Indexables the Same</i><a id='ch-indexable-_treat__all__indexables_the__same'></a>

#### âš™ï¸slr\_len<a id='f-slr_len'></a>

<code>*function* slr_len(slr: string|list|<a href="#t-range">range</a>) : number</code>

Will return the number of elements the string, list or range contains.

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

The `slr` to count how many elements it would iterate over.

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

The number of elements the `slr` contains.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸idx<a id='f-idx'></a>

<code>*function* idx(slr: string|list|<a href="#t-range">range</a>, i: number, \_slr\_len: number) : number</code>

If `i` is positive then returns `i`, otherwise add the slr's length to it so
as to count backwards from the end of the slr.

> â„¹ï¸ NOTE:
>
> If not `-slr_len(slr) â‰¤ i < slr_len(slr)`, then using the returned value to
> dereference the `slr` is **UB**.

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

The `slr` to get the index for.

**<code>i</code>**: <code>number</code>

The index of the element.  If value is negative, then goes backward from
end of slr, where -1 represents the last indexable index.

**<code>_slr_len</code>**: <code>number</code> *(Optional)*

If passed, then use that cached value instead of calculating `len(slr)`.

> â„¹ï¸ NOTE:
>
> This is a private parameter and it may disappear at any time in the
> future.  Use at your own peril!

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

The positive index.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸el<a id='f-el'></a>

<code>*function* el(slr: string|list|<a href="#t-range">range</a>, i: number) : any</code>

Dereference `slr` at index `i`, allowing for negative indices to go backward
from end.

> â„¹ï¸ NOTE:
>
> It is **UB** to dereference at an index that is not in the `slr`.

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

The `slr` to get the element from.

**<code>i</code>**: <code>number</code>

The index of the element.  If value is negative, then goes backward from
end of the `slr`.

</details>

<details><summary>returns</summary>

**Returns**: <code>any</code>

The element at the index specified.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸el\_pos\_idx<a id='f-el_pos_idx'></a>

<code>*function* el_pos_idx(slr: string|list|<a href="#t-range">range</a>, i: number) : any</code>

Dereference `slr` at index `i`, allowing only positive indices.

> â„¹ï¸ NOTE:
>
> It is **UB** to dereference at an index that is not in the `slr`.

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

The `slr` to get the element from.

**<code>i</code>**: <code>number</code>

The number iterations to have been done to get the return value.
Must be positive `(i >= 0)`.

</details>

<details><summary>returns</summary>

**Returns**: <code>any</code>

The element at the index specified.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸els<a id='f-els'></a>

<code>*function* els(slr: string|list|<a href="#t-range">range</a>, birls: <a href="#t-Birls">Birls</a>, end\_i: <a href="#t-EndI">EndI</a>) : string|list|<a href="#t-range">range</a></code>

Gets a substring, sub-range or sub-elements of a string, list or range.   If
`slr` is a `range` and the `birlei` is a `range`, the result is a `range`.

> â„¹ï¸ NOTE:
>
> To expand a range to a list, use `[ each range_to_expand ]`.

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

The `slr` to get the elements from.

**<code>birls</code>**: <code><a href="#t-Birls">Birls</a></code> *(Default: `0`)*

- If `number`, start index to iterate over.
- If `range`, indices to iterate over.
- If `list`, indices to iterate over.
- If `slice`, to convert to range providing indices to iterate over.

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Default: `idx(slr, -1)`)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code>string|list|<a href="#t-range">range</a></code>

The elements at the indices specified or the substring.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸range\_els<a id='f-range_els'></a>

<code>*function* range_els(r: <a href="#t-range">range</a>, birls: <a href="#t-Birls">Birls</a>, end\_i: <a href="#t-EndI">EndI</a>) : <a href="#t-range">range</a>|list</code>

Optimised version of `els` for ranges.  Gets elements from a range as a range
or list.

- If the `birlsei` is a list, then the subset of the range `r` will be a
  list.
- Else a new range is computed

<details><summary><b>Example:</b><i></i></summary>


```openscad
range_els([1 : 10], [2 : 2 : 5])
//  1  2  3  4  5  6  7  8  9 10  // element of     [ 1 : 1 : 10 ]
//     2     3                    // indices        [ 2 : 2 :  5 ]
//     2     3                    // final elements [ 2 : 2 :  4 ]

range_els([1 : 2 : 15], [2 : 3 : 5])
//  1  3  5  7  9  11 13 15       // elements of    [ 1 : 2 : 15 ]
//        2         5             // indices        [ 2 : 3 :  5 ]
//        5        11             // final elements [ 5 : 6 : 11 ]

([2 : 10], [1, 3, 6])
  2  3  4  5  6  7  8  9 10     // elements of    [ 2 : 1 : 10 ]
     1     4        6           // indices        [ 1, 3, 6 ]
     3     5        8           // final elements [ 3, 5, 8 ]
```

</details>

<details><summary>parameters</summary>

**<code>r</code>**: <code><a href="#t-range">range</a></code>

The r to get the elements from.

**<code>birls</code>**: <code><a href="#t-Birls">Birls</a></code> *(Default: `0`)*

- If `number`, start index to iterate over.
- If `range`, indices to iterate over.
- If `list`, indices to iterate over.
- If `slice`, to convert to range providing indices to iterate over.

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Default: `idx(r, -1)`)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-range">range</a>|list</code>

The elements at the indices specified or the substring.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘Getting/Traversing Indices</i><a id='ch-indexable-_getting__traversing__indices'></a>

#### âš™ï¸idxs<a id='f-idxs'></a>

<code>*function* idxs(slr: string|list|<a href="#t-range">range</a>, birls: <a href="#t-Birls">Birls</a>, end\_i: <a href="#t-EndI">EndI</a>) : list\[number,...]</code>

Gets the indices from a `birlsei` as a list.

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

The `slr` to get the indices from.

**<code>birls</code>**: <code><a href="#t-Birls">Birls</a></code> *(Default: `0`)*

- If `number`, start index to iterate over.
- If `range`, indices to iterate over.
- If `list`, indices to iterate over.
- If `slice`, to convert to range providing indices to iterate over.

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Default: `idx(slr, -1)`)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code>list\[number,...]</code>

The indices the `birlsei` would iterate over.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸fwd\_i<a id='f-fwd_i'></a>

<code>*function* fwd_i(slr: string|list|<a href="#t-range">range</a>, start\_offset: number, end\_offset: number, \_slr\_len: number) : <a href="#t-range">range</a></code>

Return a range representing indices to iterate over a list forwards.

> â„¹ï¸ NOTE:
>
> Dev is responsible for ensuring that when using start_offset / end_offset,
> that they don't go out of bounds, or if they do, the underlying PPMRRAIR
> function will handle it gracefully.

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

slr to iterate over

**<code>start_offset</code>**: <code>number</code> *(Default: `0`)*

Offset to start the starting point from.

- Should prolly be positive to not give an undefined index.

**<code>end_offset</code>**: <code>number</code> *(Default: `0`)*

Offset to end the ending point to.

- Should prolly be negative to not give an undefined index.

**<code>_slr_len</code>**: <code>number</code> *(Optional)*

If passed, then use that cached value instead of calculating `len(slr)`.

> â„¹ï¸ NOTE:
>
> This is a private parameter and it may disappear at any time in the
> future.  Use at your own peril!

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-range">range</a></code>

An ascending range that goes from `start_offset` to idx(slr, -1) +
end_offset.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸rev\_i<a id='f-rev_i'></a>

<code>*function* rev_i(slr: string|list|<a href="#t-range">range</a>, start\_offset: number, end\_offset: number, \_slr\_len: number) : <a href="#t-range">range</a></code>

Return a range representing indices to iterate over slr backwards.

> â„¹ï¸ NOTE:
>
> Dev is responsible for ensuring that when using start_offset / end_offset,
> that they don't go out of bounds, or if they do, the underlying PPMRRAIR
> function will handle it gracefully.

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

slr to iterate over

**<code>start_offset</code>**: <code>number</code> *(Default: `0`)*

Offset to start the starting point from.

- Should prolly be negative to not give an undefined index.

**<code>end_offset</code>**: <code>number</code> *(Default: `0`)*

Offset to end the ending point to.

- Should prolly be positive to not give an undefined index.

**<code>_slr_len</code>**: <code>number</code> *(Optional)*

If passed, then use that cached value instead of calculating `len(slr)`.

> â„¹ï¸ NOTE:
>
> This is a private parameter and it may disappear at any time in the
> future.  Use at your own peril!

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-range">range</a></code>

A descending range that goes from idx(slr, -1) + start_offset to
end_offset.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸next\_in<a id='f-next_in'></a>

<code>*function* next_in(slr: string|list|<a href="#t-range">range</a>, i: number, inc: number, wrap\_to\_0: bool, \_slr\_len: number) : number</code>

Gets the next index, wrapping if goes to or beyond slr_len(slr).

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

slr used for knowing when to wrap.

**<code>i</code>**: <code>number</code>

Index to start from.  Assumed: `0 <= i < slr_len(slr)`.

**<code>inc</code>**: <code>number</code> *(Default: `1`)*

Count to increase i by.

**<code>wrap_to_0</code>**: <code>bool</code> *(Default: `false`)*

If true, then when i+inc >= slr_len(slr), result is 0.  Otherwise, it wraps
to modulo slr_len(slr).

**<code>_slr_len</code>**: <code>number</code> *(Optional)*

If passed, then use that cached value instead of calculating `len(slr)`.

> â„¹ï¸ NOTE:
>
> This is a private parameter and it may disappear at any time in the
> future.  Use at your own peril!

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

Next element index in list.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸prev\_in<a id='f-prev_in'></a>

<code>*function* prev_in(slr: string|list|<a href="#t-range">range</a>, i: number, dec: number, wrap\_to\_last: bool, \_slr\_len: number) : number</code>

Gets the prev index, wrapping if goes negative.

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

slr used for knowing when to wrap.

**<code>i</code>**: <code>number</code>

Index to start from.  Assumed: `0 <= i < slr_len(slr)`.

**<code>dec</code>**: <code>number</code> *(Default: `1`)*

Count to decrease i by.

**<code>wrap_to_last</code>**: <code>bool</code> *(Default: `false`)*

If true, then when i-dec < 0, result is idx(slr, -1).  Otherwise, it wraps
to modulo slr_len(slr).

**<code>_slr_len</code>**: <code>number</code> *(Optional)*

If passed, then use that cached value instead of calculating `len(slr)`.

> â„¹ï¸ NOTE:
>
> This is a private parameter and it may disappear at any time in the
> future.  Use at your own peril!

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

Previous element index in list.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘Functions to Manipulate Strings and Lists</i><a id='ch-indexable-_functions_to__manipulate__strings_and__lists'></a>

#### âš™ï¸push<a id='f-push'></a>

<code>*function* push(sl: string|list, es: string|list|<a href="#t-range">range</a>) : string|list</code>

Push elements onto the end of `sl`.

<details><summary>parameters</summary>

**<code>sl</code>**: <code>string|list</code>

sl to add to.

**<code>es</code>**: <code>string|list|<a href="#t-range">range</a></code>

- if string, then
  - a string of characters to append to string or
  - list of characters to append to list.
- if list, then a list of elements to append to list.
- if range, then a range of elements to append to list.

</details>

<details><summary>returns</summary>

**Returns**: <code>string|list</code>

The updated string or list.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸pop<a id='f-pop'></a>

<code>*function* pop(sl: string|list, count: number, \_sl\_len: number) : string|list</code>

Pops 0 or more elements off the end of `sl`.

> â„¹ï¸ NOTE:
>
> It is **UB** to pop off more elements than are available.

<details><summary>parameters</summary>

**<code>sl</code>**: <code>string|list</code>

sl to remove from.

**<code>count</code>**: <code>number</code> *(Default: `1`)*

Number of elements to pop off end of list.

**<code>_sl_len</code>**: <code>number</code> *(Optional)*

If passed, then use that cached value instead of calculating `len(sl)`.

> â„¹ï¸ NOTE:
>
> This is a private parameter and it may disappear at any time in the
> future.  Use at your own peril!

</details>

<details><summary>returns</summary>

**Returns**: <code>string|list</code>

The updated sl.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸unshift<a id='f-unshift'></a>

<code>*function* unshift(sl: string|list, es: string|list|<a href="#t-range">range</a>) : string|list</code>

Unshift elements onto the beginning of `sl`.

<details><summary>parameters</summary>

**<code>sl</code>**: <code>string|list</code>

List to add to.

**<code>es</code>**: <code>string|list|<a href="#t-range">range</a></code>

- if string, then
  - a string of characters to prepend to string or
  - list of characters to prepend to list.
- if list, then a list of elements to prepend to list.
- if range, then a range of elements to prepend to list.

</details>

<details><summary>returns</summary>

**Returns**: <code>string|list</code>

The updated sl.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸shift<a id='f-shift'></a>

<code>*function* shift(sl: string|list, count: number, \_sl\_len: number) : string|list</code>

Shift elements off of the beginning of `sl`.

> â„¹ï¸ NOTE:
>
> It is **UB** to shift off more elements than are available.

<details><summary>parameters</summary>

**<code>sl</code>**: <code>string|list</code>

sl to remove from.

**<code>count</code>**: <code>number</code> *(Default: `1`)*

Number of elements to shift off beginning of list.

**<code>_sl_len</code>**: <code>number</code> *(Optional)*

If passed, then use that cached value instead of calculating `len(sl)`.

> â„¹ï¸ NOTE:
>
> This is a private parameter and it may disappear at any time in the
> future.  Use at your own peril!

</details>

<details><summary>returns</summary>

**Returns**: <code>string|list</code>

The updated sl.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸insert<a id='f-insert'></a>

<code>*function* insert(sl: string|list, i: number, es: string|list|<a href="#t-range">range</a>, es\_birls: <a href="#t-Birls">Birls</a>, es\_end\_i: <a href="#t-EndI">EndI</a>) : string|list</code>

Possible callchains:

    insert(sl, i, es, es_birls, es_end_i) : (string | list)

Insert specified elements in `es` into `sl` starting at index `i`.

<details><summary>parameters</summary>

**<code>sl</code>**: <code>string|list</code>

String or list to insert into.

**<code>i</code>**: <code>number</code>

Index to insert into.

- `0` to insert at beginning of list (like unshift)
- `len(sl)` to insert at end of list (like push)
- Negative values will insert starting from the end.
  - `-1` will insert between the second last element and the last element.
  - `-len(sl)` will insert at the beginning of list (like unshift)
  - **UB** if `i < -len(sl) or len(sl) < i`.

**<code>es</code>**: <code>string|list|<a href="#t-range">range</a></code>

Elements to insert.

**<code>es_birls</code>**: <code><a href="#t-Birls">Birls</a></code> *(Default: `0`)*

- If `number`, start index to iterate over.
- If `range`, indices to iterate over.
- If `list`, indices to iterate over.
- If `slice`, to convert to range providing indices to iterate over.

**<code>es_end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Default: `idx(es, -1)`)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code>string|list</code>

The updated sl.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸remove<a id='f-remove'></a>

<code>*function* remove(sl: string|list, begin\_i: number, end\_i: number, \_sl\_len: number) : string|list</code>

Removes a contiguous set of elements from a sl.

> â„¹ï¸ NOTE:
>
> `begin_i` and `end_i` accept negative values (`-1` is last element). Both
> are first converted to their non-negative equivalents by adding `len(sl)`.
> If the converted `end_i < begin_i`, nothing is removed. Otherwise the
> inclusive range `[begin_i..end_i]` is removed.
>
> Unless `end_i < begin_i`, it is **UB** if `begin_i` or `end_i` don't
> resolve to an index in the sl.

<details><summary>parameters</summary>

**<code>sl</code>**: <code>string|list</code>

List to remove elements from.

**<code>begin_i</code>**: <code>number</code>

The first index to remove. Can be negative to represent counting from end.

**<code>end_i</code>**: <code>number</code>

The last index to remove. Can be negative to represent counting from end.

**<code>_sl_len</code>**: <code>number</code> *(Optional)*

If passed, then use that cached value instead of calculating `len(sl)`.

> â„¹ï¸ NOTE:
>
> This is a private parameter and it may disappear at any time in the
> future.  Use at your own peril!

</details>

<details><summary>returns</summary>

**Returns**: <code>string|list</code>

The updated sl.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸remove\_adjacent\_dups<a id='f-remove_adjacent_dups'></a>

<code>*function* remove_adjacent_dups(sl: string|list, wrap: bool, \_sl\_len: number) : <a href="#t-RemoveAdjacentDupsFn">RemoveAdjacentDupsFn</a></code>

Possible callchains:

    remove_adjacent_dups(sl, wrap, _sl_len) (equal_fn) : (string | list)

Removes the same consecutive values, where same is defined by `equal_fn`.

<details><summary>parameters</summary>

**<code>sl</code>**: <code>string|list</code>

List to remove duplicate consecutive elements from.

**<code>wrap</code>**: <code>bool</code> *(Default: `false`)*

If true, then will consider the first and last element consecutive.

**<code>_sl_len</code>**: <code>number</code> *(Optional)*

If passed, then use that cached value instead of calculating `len(sl)`.

> â„¹ï¸ NOTE:
>
> This is a private parameter and it may disappear at any time in the
> future.  Use at your own peril!

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-RemoveAdjacentDupsFn">RemoveAdjacentDupsFn</a></code>

Callback that removes the adjacent duplicates.

Possible callchains:

    RemoveAdjacentDupsFn(equal_fn) : (string|list)

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸remove\_each<a id='f-remove_each'></a>

<code>*function* remove_each(sl: string|list, birls: <a href="#t-Birls">Birls</a>, end\_i: <a href="#t-EndI">EndI</a>) : string|list</code>

Removes each element indexed in the `birlsei`.

> â„¹ï¸ NOTE:
>
> **UB** if resulting `birlei` is not strictly increasing.

<details><summary>parameters</summary>

**<code>sl</code>**: <code>string|list</code>

List to remove elements from.

**<code>birls</code>**: <code><a href="#t-Birls">Birls</a></code> *(Default: `0`)*

- If `number`, start index to iterate over.
- If `range`, indices to iterate over.
- If `list`, indices to iterate over.
- If `slice`, to convert to range providing indices to iterate over.

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Default: `idx(sl, -1)`)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code>string|list</code>

The updated sl.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸replace<a id='f-replace'></a>

<code>*function* replace(a: string|list, a\_begin\_i: number, a\_end\_i: number, b: string|list|<a href="#t-range">range</a>, b\_birls: <a href="#t-Birls">Birls</a>, b\_end\_i: <a href="#t-EndI">EndI</a>) : string|list</code>

Replaces contiguous index set \[`a_begin_i`, `a_end_i`] from list `a` with
`birlsei` index set of list `b`.

<details><summary>parameters</summary>

**<code>a</code>**: <code>string|list</code>

List to have elements replaced.

**<code>a_begin_i</code>**: <code>number</code>

The starting index of a to replace.

**<code>a_end_i</code>**: <code>number</code>

The ending index of a to replace.

**<code>b</code>**: <code>string|list|<a href="#t-range">range</a></code>

List to draw elements from to replace the a element range with.

**<code>b_birls</code>**: <code><a href="#t-Birls">Birls</a></code> *(Default: `0`)*

- If `number`, start index to iterate over.
- If `range`, indices to iterate over.
- If `list`, indices to iterate over.
- If `slice`, to convert to range providing indices to iterate over.

**<code>b_end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Default: `idx(b, -1)`)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code>string|list</code>

This is the updated list of elements.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸replace\_each<a id='f-replace_each'></a>

<code>*function* replace_each(a: string|list, a\_birls: <a href="#t-Birls">Birls</a>, a\_end\_i: <a href="#t-EndI">EndI</a>) : <a href="#t-ReplaceEachFn">ReplaceEachFn</a></code>

Possible callchains:

    replace_each(a, a_birl a_end_i) (b, b_birl b_end_i) : (string | list)

Replaces each element specified by `a_birls, a_end_i` with each element
specified by `b_birls, b_end_i`.

> â„¹ï¸ NOTE:
>
> `a_birlsei` must be strictly increasing.

> â„¹ï¸ NOTE:
>
> Both `birlsei`s MUST iterate over the same number of elements.

<details><summary>parameters</summary>

**<code>a</code>**: <code>string|list</code>

sl to have elements replaced.

**<code>a_birls</code>**: <code><a href="#t-Birls">Birls</a></code> *(Default: `0`)*

- If `number`, start index to iterate over.
- If `range`, indices to iterate over.
- If `list`, indices to iterate over.
- If `slice`, to convert to range providing indices to iterate over.

**<code>a_end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Default: `idx(a, -1)`)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-ReplaceEachFn">ReplaceEachFn</a></code>

Get the replacement set and execute replacement.

Possible callchains:

    ReplaceEachFn(b, b_birls, b_end_i) : (string|list)

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸swap<a id='f-swap'></a>

<code>*function* swap(sl: string|list, begin\_i1: number, end\_i1: number, begin\_i2: number, end\_i2: number) : string|list</code>

Swap the elements between \[begin_i1 : end_i1] and \[begin_i2 : end_i2].
Range must be nondecreasing or there will not be any elements in that
range.  Negative values are normalised to positive by adding `len(sl)` to
them.

<details><summary>parameters</summary>

**<code>sl</code>**: <code>string|list</code>

List to swap elements in.

**<code>begin_i1</code>**: <code>number</code>

Starting index of group 1.

**<code>end_i1</code>**: <code>number</code>

Ending index of group 1.

**<code>begin_i2</code>**: <code>number</code>

Starting index of group 2.

**<code>end_i2</code>**: <code>number</code>

Ending index of group 2.

</details>

<details><summary>returns</summary>

**Returns**: <code>string|list</code>

List with ranges swapped.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸rotate\_left<a id='f-rotate_left'></a>

<code>*function* rotate_left(sl: string|list, i: number, \_sl\_len: number) : string|list</code>

Does a left rotation of the elements in the `sl` so that the elements are
reordered as if indices were `[i : len(sl)-1]` followed by `[0 : i - 1]`.

<details><summary>parameters</summary>

**<code>sl</code>**: <code>string|list</code>

This is the list to rotate.

**<code>i</code>**: <code>number</code>

- Number of elements to rotate left.
- If negative, rotates right.

**<code>_sl_len</code>**: <code>number</code> *(Optional)*

If passed, then use that cached value instead of calculating `len(sl)`.

> â„¹ï¸ NOTE:
>
> This is a private parameter and it may disappear at any time in the
> future.  Use at your own peril!

</details>

<details><summary>returns</summary>

**Returns**: <code>string|list</code>

Returns the rotated list.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸rotate\_right<a id='f-rotate_right'></a>

<code>*function* rotate_right(sl: string|list, i: number, \_sl\_len: number) : string|list</code>

Does a right rotation of the elements in the `sl` so that the elements are
reordered as if indices were `[len(sl)-i : len(sl)-1]` followed by
`[0 : len(sl)-i - 1]`.

<details><summary>parameters</summary>

**<code>sl</code>**: <code>string|list</code>

This is the list to rotate.

**<code>i</code>**: <code>number</code>

- Number of elements to rotate right.
- If negative, rotates left.

**<code>_sl_len</code>**: <code>number</code> *(Optional)*

If passed, then use that cached value instead of calculating `len(sl)`.

> â„¹ï¸ NOTE:
>
> This is a private parameter and it may disappear at any time in the
> future.  Use at your own peril!

</details>

<details><summary>returns</summary>

**Returns**: <code>string|list</code>

Returns the rotated list.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸head<a id='f-head'></a>

<code>*function* head(sl: string|list, \_sl\_len: number) : any</code>

Gets the element at the end of `sl`.

<details><summary>parameters</summary>

**<code>sl</code>**: <code>string|list</code>

List to get from.

**<code>_sl_len</code>**: <code>number</code> *(Optional)*

If passed, then use that cached value instead of calculating `len(sl)`.

> â„¹ï¸ NOTE:
>
> This is a private parameter and it may disappear at any time in the
> future.  Use at your own peril!

</details>

<details><summary>returns</summary>

**Returns**: <code>any</code>

Object at the head of the list.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸head\_multi<a id='f-head_multi'></a>

<code>*function* head_multi(sl: string|list, i: number, \_sl\_len: number) : string|list</code>

Gets the elements at the end of `sl`.

<details><summary>parameters</summary>

**<code>sl</code>**: <code>string|list</code>

List to get from.

**<code>i</code>**: <code>number</code>

Number of elements to retrieve from the head.

**<code>_sl_len</code>**: <code>number</code> *(Optional)*

If passed, then use that cached value instead of calculating `len(sl)`.

> â„¹ï¸ NOTE:
>
> This is a private parameter and it may disappear at any time in the
> future.  Use at your own peril!

</details>

<details><summary>returns</summary>

**Returns**: <code>string|list</code>

Objects at the head of the list.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸tail<a id='f-tail'></a>

<code>*function* tail(sl: string|list) : any</code>

Gets the element at the beginning of `sl`.

<details><summary>parameters</summary>

**<code>sl</code>**: <code>string|list</code>

List to get from.

</details>

<details><summary>returns</summary>

**Returns**: <code>any</code>

Object at the tail of the list.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸tail\_multi<a id='f-tail_multi'></a>

<code>*function* tail_multi(sl: string|list, i: number) : string|list</code>

Gets the elements at the beginning of `sl`.

<details><summary>parameters</summary>

**<code>sl</code>**: <code>string|list</code>

List to get from.

**<code>i</code>**: <code>number</code>

Number of elements to retrieve from the tail.

</details>

<details><summary>returns</summary>

**Returns**: <code>string|list</code>

Objects at the tail of the list.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸osearch<a id='f-osearch'></a>

<code>*function* osearch(haystack: string|list, birls: <a href="#t-Birls">Birls</a>, end\_i: <a href="#t-EndI">EndI</a>) : <a href="#t-SearchNeedleFn">SearchNeedleFn</a></code>

Possible callchains:

    osearch(haystack, birls, end_i) (needle, n_birls, n_end_i) (equal_fn) : (undef | number)

Searches for an ordered set of elements specified in needle that occurs as an
ordered set of elements in haystack.  Similar to built-in search() function,
but allows specifying an index range to search and exposes the equal()
operator to allow for non-exact matches.

<details><summary>parameters</summary>

**<code>haystack</code>**: <code>string|list</code>

String or list of consecutive items to search through.

**<code>birls</code>**: <code><a href="#t-Birls">Birls</a></code> *(Default: `0`)*

- If `number`, start index to iterate over.
- If `range`, indices to iterate over.
- If `list`, indices to iterate over.
- If `slice`, to convert to range providing indices to iterate over.

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Default: `idx(haystack, -1)`)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-SearchNeedleFn">SearchNeedleFn</a></code>

Curry function to get needle data.

Possible callchains:

    SearchNeedleFn(needle, n_birls, n_end_i) (equal_fn) : (number|undef)

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸csearch<a id='f-csearch'></a>

<code>*function* csearch(haystack: string|list, birls: <a href="#t-Birls">Birls</a>, end\_i: <a href="#t-EndI">EndI</a>) : <a href="#t-SearchNeedleFn">SearchNeedleFn</a></code>

Possible callchains:

    csearch(haystack, birls, end_i) (needle, n_birls, n_end_i) (equal_fn) : (undef | number)

Searches haystack for contiguous set of elements that starts from an ordered
set of indices that match an ordered set of elements specified in needle.
Similar to built-in search() function, but allows specifying an index range
to search and exposes the equal() operator to allow for non-exact matches.

<details><summary>parameters</summary>

**<code>haystack</code>**: <code>string|list</code>

String or list of consecutive items to search through.

**<code>birls</code>**: <code><a href="#t-Birls">Birls</a></code> *(Default: `0`)*

- If `number`, start index to iterate over.
- If `range`, indices to iterate over.
- If `list`, indices to iterate over.
- If `slice`, to convert to range providing indices to iterate over.

**<code>end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Default: `idx(haystack, -1)`)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-SearchNeedleFn">SearchNeedleFn</a></code>

Curry function to get needle data.

Possible callchains:

    SearchNeedleFn(needle, n_birls, n_end_i) (equal_fn) : (number|undef)

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸quicksort\_list\_comp\_ex<a id='f-quicksort_list_comp_ex'></a>

<code>*function* quicksort_list_comp_ex()</code>

Example quick sort algorithm from:
  (https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/List_Comprehensions)

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸quicksort\_lib\_ex1<a id='f-quicksort_lib_ex1'></a>

<code>*function* quicksort_lib_ex1()</code>

Example of quick sort algorithm using library.

Modified quicksort example from:
  (https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/List_Comprehensions)

> â„¹ï¸ NOTE:
>
> Not saying that it should be implemented this way.  Just testing.
> If done this way, could sort a subset, but the overhead would be
> significant.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸quicksort\_lib\_ex2<a id='f-quicksort_lib_ex2'></a>

<code>*function* quicksort_lib_ex2()</code>

Example of quick sort algorithm using library.

Modified quicksort example from:
  (https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/List_Comprehensions)

> â„¹ï¸ NOTE:
>
> Not saying that it should be implemented this way.  Just testing.
> If done this way, could sort a subset, but the overhead would be
> significant.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘indexable types</i><a id='ch-indexable-indexable_types'></a>

#### ğŸ§©slice<a id='t-slice'></a>

<code>*type* slice = list</code>

Slice is an unresolved range that works with an indexable.  It itself is
**not indexable**.  Use [`slice_to_range`](#f-slice_to_range) to convert to an
indexable range.

> â„¹ï¸ NOTE:
>
> Due to ranges using inclusive values, and slices adhering to that same
> paradigm, a slice cannot refer to an empty range unless `step` precludes
> `begin_i` from getting to `end_i` or the referred to `slr` has a length of
> `0`.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©Birls<a id='t-_birls'></a>

<code>*type* Birls = number|<a href="#t-range">range</a>|list|<a href="#t-slice">slice</a></code>

- If `number`, start index to iterate over.
- If `range`, indices to iterate over.
- If `list`, indices to iterate over.
- If `slice`, to convert to range providing indices to iterate over.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©slr\_cache<a id='t-slr_cache'></a>

<code>*type* slr_cache = list</code>

Cache returned by `_slr_cache(slr, birls, end_i)`.

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
len_of_slr = cache_obj[_SLR_LEN]
```

</details>

<details><summary>slots</summary>
<code><b>_SLR_LEN</b></code>: <code>number</code>

Length of `slr`.

<code><b>_SLR_TE</b></code>: <code><a href="#t-TypeEnum">TypeEnum</a></code>

Type enum of `slr`.

<code><b>_SLR_ELD</b></code>: <code>function(i: number): any</code>

`i` is the index to dereference the `slr` (Direct addressing).

Returns roughly `slr[i]`, where `0 <= i < slr_len`.

- If backward indexing equivalent to [`idx()`](#f-idx) is wanted, manually
  calculating it by the formula `slr_len - i` is required.  This maximises
  throughput for most common case.

<code><b>_SLR_BLEN</b></code>: <code>number</code>

Length of normalised `birlsei`.

<code><b>_SLR_ELI</b></code>: <code>function(j: number): any</code>

`j` is the index to dereference the normalised `birlsei` to index the `slr`
(Indirect addressing).  Returns roughly `slr[birlei[j]]`, where
`0 <= j < birlei_len`.

- If backward indexing equivalent to [`idx()`](#f-idx) is wanted, manually
  calculating it by the formula `birlei_len - j` is required.  This
  maximises throughput for most common case.

<code><b>_SLR_IDX</b></code>: <code>function(k: number): number</code>

`k` is the index to dereference the normalised `birlsei`.  Returns roughly
`birlei[k]`, where `0 <= k < birlei_len`.

- If backward indexing equivalent to [`idx()`](#f-idx) is wanted, manually
  calculating it by the formula `birlei_len - k` is required.  This
  maximises throughput for most common case.

<code><b>_SLR_STR</b></code>: <code>function(): string</code>

String representation of normalised `birlsei`.

<code><b>_SLR_BIRL</b></code>: <code>number|<a href="#t-range">range</a>|list</code>

Normalised birls.

<code><b>_SLR_END_I</b></code>: <code>number|undef</code>

Normalised end_i.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©GetPpmrrairFn<a id='t-_get_ppmrrair_fn'></a>

<code>*callback* GetPpmrrairFn(ppmrrair\_fn: <a href="#t-PpmrrairFn">PpmrrairFn</a>) : any</code>

Gets the PPMRRAIR function to apply the [AlgoFn](#t-_algo_fn) to.

<details><summary>parameters</summary>

**<code>ppmrrair_fn</code>**: <code><a href="#t-PpmrrairFn">PpmrrairFn</a></code>

The PPMRRAIR function to iterate with.

</details>

<details><summary>returns</summary>

**Returns**: <code>any</code>

The result of the adaptor call.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©EqualFn<a id='t-_equal_fn'></a>

<code>*callback* EqualFn(lhs: any, rhs: any) : bool</code>

Represents the equation `lhs == rhs`, but allows user to define what `==`
means.  For a less strict equality check, try
[`function_equal`](#f-function_equal).

<details><summary>parameters</summary>

**<code>lhs</code>**: <code>any</code>

The left hand side of the equality.

**<code>rhs</code>**: <code>any</code>

The right hand side of the equality.

</details>

<details><summary>returns</summary>

**Returns**: <code>bool</code>

The result of the equality test.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©GetEqualFn<a id='t-_get_equal_fn'></a>

<code>*callback* GetEqualFn(equal\_fn: <a href="#t-EqualFn">EqualFn</a>) : any</code>

Gets the equality function and perform a function with it.

<details><summary>parameters</summary>

**<code>equal_fn</code>**: <code><a href="#t-EqualFn">EqualFn</a></code> *(Default: `function(a, b) a == b`)*

The equality function.

</details>

<details><summary>returns</summary>

**Returns**: <code>any</code>

The resulting value when done.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©RemoveAdjacentDupsFn<a id='t-_remove_adjacent_dups_fn'></a>

<code>*callback* RemoveAdjacentDupsFn(equal\_fn: <a href="#t-EqualFn">EqualFn</a>) : any</code>

Callback that removes the adjacent duplicates.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©ReplaceEachFn<a id='t-_replace_each_fn'></a>

<code>*callback* ReplaceEachFn(b: string|list|<a href="#t-range">range</a>, b\_birls: <a href="#t-Birls">Birls</a>, b\_end\_i: <a href="#t-EndI">EndI</a>) : string|list</code>

<details><summary>parameters</summary>

**<code>b</code>**: <code>string|list|<a href="#t-range">range</a></code>

sl to have elements replaced.

**<code>b_birls</code>**: <code><a href="#t-Birls">Birls</a></code> *(Default: `0`)*

- If `number`, start index to iterate over.
- If `range`, indices to iterate over.
- If `list`, indices to iterate over.
- If `slice`, to convert to range providing indices to iterate over.

**<code>b_end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Default: `idx(b, -1)`)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code>string|list</code>

This is the updated list of elements.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©SearchFn<a id='t-_search_fn'></a>

<code>*callback* SearchFn(equal\_fn: <a href="#t-EqualFn">EqualFn</a>) : any</code>

Perform search.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©SearchNeedleFn<a id='t-_search_needle_fn'></a>

<code>*callback* SearchNeedleFn(needle: string|list, n\_birls: <a href="#t-Birls">Birls</a>, n\_end\_i: <a href="#t-EndI">EndI</a>) : <a href="#t-SearchFn">SearchFn</a></code>

Gets the needle data.

<details><summary>parameters</summary>

**<code>needle</code>**: <code>string|list</code>

String or list of items being searched for.

**<code>n_birls</code>**: <code><a href="#t-Birls">Birls</a></code> *(Default: `0`)*

- If `number`, start index to iterate over.
- If `range`, indices to iterate over.
- If `list`, indices to iterate over.
- If `slice`, to convert to range providing indices to iterate over.

**<code>n_end_i</code>**: <code><a href="#t-EndI">EndI</a></code> *(Default: `idx(needle, -1)`)*

- If related `birl` is a number, then this is the end index to iterate
  over.
  - If this value is less than the related birl's value, then nothing is
    iterated over.
- Else must be `undef`.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-SearchFn">SearchFn</a></code>

Callback to get the equality function.

Possible callchains:

    SearchFn(equal_fn) : (number|undef)

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

<hr/>

## ğŸ“˜indexable_consts<a id='file-indexable_consts'></a>

### <i>ğŸ“‘How to Import</i><a id='ch-indexable_consts-_how_to__import'></a>

    include <indexable_consts>

### <i>ğŸ“‘Purpose</i><a id='ch-indexable_consts-_purpose'></a>

Constants used by [`slr_cache`](#f-_slr_cache) for indexing the
[slr_cache](#t-slr_cache) object.

### <i>ğŸ“‘Values</i><a id='ch-indexable_consts-_values'></a>

#### ğŸ’ \_SLR\_CACHE\_HEADER<a id='v-__s_l_r__c_a_c_h_e__h_e_a_d_e_r'></a>

<code>*value* _SLR_CACHE_HEADER : string</code>

Used to indicate if a list object is identified as an `_SLR_CACHE` object.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ \_SLR\_LEN<a id='v-__s_l_r__l_e_n'></a>

<code>*value* _SLR_LEN : <a href="#t-SlrCacheEnum">SlrCacheEnum</a></code>

Value representing the length of `slr`.

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
_slr_cache(slr, birls, end_i)[_SLR_LEN]
```

Return type is number.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ \_SLR\_TE<a id='v-__s_l_r__t_e'></a>

<code>*value* _SLR_TE : <a href="#t-SlrCacheEnum">SlrCacheEnum</a></code>

Value representing the type of `slr`.

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
_slr_cache(slr, birls, end_i)[_SLR_TE]
```

Return type is `TypeEnum`

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ \_SLR\_ELD<a id='v-__s_l_r__e_l_d'></a>

<code>*value* _SLR_ELD : <a href="#t-SlrCacheEnum">SlrCacheEnum</a></code>

Function dereferences the `slr` DIRECTLY.  E.g. index directly to `slr`
without going through the BIRLEI.

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
_slr_cache(slr, birls, end_i)[_SLR_ELD]
```

Return type is `function(i): any`

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ \_SLR\_BLEN<a id='v-__s_l_r__b_l_e_n'></a>

<code>*value* _SLR_BLEN : <a href="#t-SlrCacheEnum">SlrCacheEnum</a></code>

Length of BIRLEI.

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
_slr_cache(slr, birls, end_i)[_SLR_BLEN]
```

Return type is `number`

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ \_SLR\_ELI<a id='v-__s_l_r__e_l_i'></a>

<code>*value* _SLR_ELI : <a href="#t-SlrCacheEnum">SlrCacheEnum</a></code>

Function dereferences the `slr` INDIRECTLY by getting index through the
BIRLEI, and using that index to index the `slr`.

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
_slr_cache(slr, birls, end_i)[_SLR_ELI]
```

Return type is `function(i): any`

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ \_SLR\_IDX<a id='v-__s_l_r__i_d_x'></a>

<code>*value* _SLR_IDX : <a href="#t-SlrCacheEnum">SlrCacheEnum</a></code>

Function that dereferences the BIRLEI value.

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
_slr_cache(slr, birls, end_i)[_SLR_IDX]
```

Return type is `function(i): number`

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ \_SLR\_STR<a id='v-__s_l_r__s_t_r'></a>

<code>*value* _SLR_STR : <a href="#t-SlrCacheEnum">SlrCacheEnum</a></code>

Function converting normalised BIRLEI to string.

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
_slr_cache(slr, birls, end_i)[_SLR_STR]
```

Return type is `function() : string`

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ \_SLR\_BIRL<a id='v-__s_l_r__b_i_r_l'></a>

<code>*value* _SLR_BIRL : <a href="#t-SlrCacheEnum">SlrCacheEnum</a></code>

Normalised BIRL component of BIRLEI.

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
_slr_cache(slr, birls, end_i)[_SLR_BIRL]
```

Return type is `number | list | range`

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ \_SLR\_END\_I<a id='v-__s_l_r__e_n_d__i'></a>

<code>*value* _SLR_END_I : <a href="#t-SlrCacheEnum">SlrCacheEnum</a></code>

Normalised END_I component of BIRLEI.

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
_slr_cache(slr, birls, end_i)[_SLR_END_I]
```

Return type is `number | undef`

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘indexable_consts types</i><a id='ch-indexable_consts-indexable_consts_types'></a>

#### ğŸ§©SlrCacheEnum<a id='t-_slr_cache_enum'></a>

<code>*type* SlrCacheEnum = number</code>

Enum used to dereference a [`slr_cache`](#t-slr_cache) type.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

<hr/>

## ğŸ“˜function<a id='file-function'></a>

### <i>ğŸ“‘How to Import</i><a id='ch-function-_how_to__import'></a>

    use <function>

### <i>ğŸ“‘Purpose</i><a id='ch-function-_purpose'></a>

Allows doing things with functions using introspection.

### <i>ğŸ“‘Function Introspection</i><a id='ch-function-_function__introspection'></a>

#### âš™ï¸param\_count<a id='f-param_count'></a>

<code>*function* param_count(fn: function) : number</code>

Counts the number of parameters that can be passed to the function fn.

<details><summary>parameters</summary>

**<code>fn</code>**: <code>function</code>

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

The number of parameters that the function can take.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸apply\_to\_fn<a id='f-apply_to_fn'></a>

<code>*function* apply_to_fn(fn: function, p: list) : any</code>

Applies each element in a list to a function's parameter list.

> ğŸ“Œ TO DO:
> 
> apply_to_fn has allocation overhead, where as apply_to_fn2 has lookup
> overhead.  NEED TO BENCHMARK to determine which to keep.

<details><summary>parameters</summary>

**<code>fn</code>**: <code>function</code>

A lambda that takes between 0 and 15 parameters.

**<code>p</code>**: <code>list</code>

A list of elements to apply to the function fn.  Must have the same or
fewer elements than `fn` can take and must be at most 15 elements.

</details>

<details><summary>returns</summary>

**Returns**: <code>any</code>

The return value of fn().

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸apply\_to\_fn2<a id='f-apply_to_fn2'></a>

<code>*function* apply_to_fn2(fn: function, p: list) : any</code>

Applies each element in a list to a function's parameter list.

> ğŸ“Œ TO DO:
> 
> apply_to_fn has allocation overhead, where as apply_to_fn2 has lookup
> overhead.  NEED TO BENCHMARK to determine which to keep.

<details><summary>parameters</summary>

**<code>fn</code>**: <code>function</code>

A lambda that takes between 0 and 15 parameters.

**<code>p</code>**: <code>list</code>

A list of elements to apply to the function fn.  Must have the same or
fewer elements than `fn` can take and must be at most 15 elements.

</details>

<details><summary>returns</summary>

**Returns**: <code>any</code>

The return value of fn().

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

<hr/>

## ğŸ“˜test<a id='file-test'></a>

### <i>ğŸ“‘How to Import</i><a id='ch-test-_how_to__import'></a>

    use <test>

### <i>ğŸ“‘Purpose</i><a id='ch-test-_purpose'></a>

Used to generate code for using TDD methodology.  Tries to report useful
error messages with an optional user configurable message.

### <i>ğŸ“‘Test Your Code!</i><a id='ch-test-_test__your__code_'></a>

#### ğŸ§ªtest\_eq<a id='m-test_eq'></a>

<code>*module* test_eq(expected: any, got: any, msg: string)</code>

Tests if `expected` is equal to `got`.

<details><summary>parameters</summary>

**<code>expected</code>**: <code>any</code>

Expected value.

**<code>got</code>**: <code>any</code>

The value actually received.

**<code>msg</code>**: <code>string</code> *(Default: `""`)*

A user message to append to failure message.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§ªtest\_approx\_eq<a id='m-test_approx_eq'></a>

<code>*module* test_approx_eq(expected: any, got: any, epsilon: number, msg: string)</code>

Tests if `expected` is approx equal to `got` within `epsilon`.

<details><summary>parameters</summary>

**<code>expected</code>**: <code>any</code>

Expected value.

**<code>got</code>**: <code>any</code>

The value actually received.

**<code>epsilon</code>**: <code>number</code>

How much tolerance to say that two numbers are equal.

**<code>msg</code>**: <code>string</code> *(Default: `""`)*

A user message to append to failure message.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§ªtest\_ne<a id='m-test_ne'></a>

<code>*module* test_ne(not\_expected: any, got: any, msg: string)</code>

Tests if `not_expected` is not equal to `got`.

<details><summary>parameters</summary>

**<code>not_expected</code>**: <code>any</code>

Value that wasn't expected.

**<code>got</code>**: <code>any</code>

The value actually received.

**<code>msg</code>**: <code>string</code> *(Default: `""`)*

A user message to append to failure message.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§ªtest\_lt<a id='m-test_lt'></a>

<code>*module* test_lt(lhs: any, rhs: any, msg: string)</code>

Tests if `lhs < rhs`.

<details><summary>parameters</summary>

**<code>lhs</code>**: <code>any</code>

Left hand side value to test.

**<code>rhs</code>**: <code>any</code>

Right hand side value to test.

**<code>msg</code>**: <code>string</code> *(Default: `""`)*

A user message to append to failure message.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§ªtest\_le<a id='m-test_le'></a>

<code>*module* test_le(lhs: any, rhs: any, msg: string)</code>

Tests if `lhs â‰¤ rhs`.

<details><summary>parameters</summary>

**<code>lhs</code>**: <code>any</code>

Left hand side value to test.

**<code>rhs</code>**: <code>any</code>

Right hand side value to test.

**<code>msg</code>**: <code>string</code> *(Default: `""`)*

A user message to append to failure message.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§ªtest\_gt<a id='m-test_gt'></a>

<code>*module* test_gt(lhs: any, rhs: any, msg: string)</code>

Tests if `lhs > rhs`.

<details><summary>parameters</summary>

**<code>lhs</code>**: <code>any</code>

Left hand side value to test.

**<code>rhs</code>**: <code>any</code>

Right hand side value to test.

**<code>msg</code>**: <code>string</code> *(Default: `""`)*

A user message to append to failure message.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§ªtest\_ge<a id='m-test_ge'></a>

<code>*module* test_ge(lhs: any, rhs: any, msg: string)</code>

Tests if `lhs â‰¥ rhs`.

<details><summary>parameters</summary>

**<code>lhs</code>**: <code>any</code>

Left hand side value to test.

**<code>rhs</code>**: <code>any</code>

Right hand side value to test.

**<code>msg</code>**: <code>string</code> *(Default: `""`)*

A user message to append to failure message.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§ªtest\_truthy<a id='m-test_truthy'></a>

<code>*module* test_truthy(val: any, msg: string)</code>

Tests if `val` is a truthy value

<details><summary>parameters</summary>

**<code>val</code>**: <code>any</code>

Value to test.

**<code>msg</code>**: <code>string</code> *(Default: `""`)*

A user message to append to failure message.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§ªtest\_falsy<a id='m-test_falsy'></a>

<code>*module* test_falsy(val: any, msg: string)</code>

Tests if `val` is a falsy value

<details><summary>parameters</summary>

**<code>val</code>**: <code>any</code>

Value to test.

**<code>msg</code>**: <code>string</code> *(Default: `""`)*

A user message to append to failure message.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

<hr/>

## ğŸ“˜param_check<a id='file-param_check'></a>

### <i>ğŸ“‘How to Import</i><a id='ch-param_check-_how_to__import'></a>

    use <param_check>

### <i>ğŸ“‘Purpose</i><a id='ch-param_check-_purpose'></a>

These functions do a minimal check to see if the parameters passed are what
are expected.

As this library is to be as fast as possible, the way this is done is by
adding to the beginning of the function a `let ( verify_... )` for each
parameter.  In this way, all parameter checks can be turned off by running:
```bash
find . -maxdepth 1 -type f ! -name '*.*' -print0 |
  while IFS= read -r -d '' f; do
    gawk '{ pattern = /^(\s+)(let \( _ = verify_)/;
            print gensub(pattern, "\\1// \\2", 1) }' "$f" > "$f.tmp" && \
      mv "$f.tmp" "$f" && \
      echo "Update to $f succeeded" || \
      echo "Failed to update $f"
  done
```

And turned on by running:
```bash
find . -maxdepth 1 -type f ! -name '*.*' -print0 |
  while IFS= read -r -d '' f; do
    gawk '{ pattern = /^(\s+)\/\/ (let \( _ = verify_)/;
            print gensub(pattern, "\\1\\2", 1) }' "$f" > "$f.tmp" && \
      mv "$f.tmp" "$f" && \
      echo "Update to $f succeeded" || \
      echo "Failed to update $f"
  done
```

Although this modifies the library, this will result in disabled parameter
checks having 0 effect on runtime performance.

Can make two libraries, one debug with parameter checking turned on and one
release with it turned off.

### <i>ğŸ“‘Type Checks</i><a id='ch-param_check-_type__checks'></a>

These check that the types are what they are expected to be.  They don't
check values.

#### âš™ï¸verify\_slr<a id='f-verify_slr'></a>

<code>*function* verify_slr(slr: string|list|<a href="#t-range">range</a>)</code>

Verifies the `slr` type is either a string, list or range.

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_sl<a id='f-verify_sl'></a>

<code>*function* verify_sl(sl: string|list)</code>

Verifies the `sl` type is either a string or list.

<details><summary>parameters</summary>

**<code>sl</code>**: <code>string|list</code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_s<a id='f-verify_s'></a>

<code>*function* verify_s(s: string)</code>

Verifies the `s` type is a string.

<details><summary>parameters</summary>

**<code>s</code>**: <code>string</code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_l<a id='f-verify_l'></a>

<code>*function* verify_l(l: list)</code>

Verifies the `l` type is a list.

<details><summary>parameters</summary>

**<code>l</code>**: <code>list</code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_r<a id='f-verify_r'></a>

<code>*function* verify_r(r: <a href="#t-range">range</a>)</code>

Verifies the `r` type is a range.

<details><summary>parameters</summary>

**<code>r</code>**: <code><a href="#t-range">range</a></code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_i<a id='f-verify_i'></a>

<code>*function* verify_i(i: number)</code>

Verifies the `i` type is a number.

<details><summary>parameters</summary>

**<code>i</code>**: <code>number</code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_iu<a id='f-verify_iu'></a>

<code>*function* verify_iu(iu: number|undef)</code>

Verifies the `iu` type is either a number or undef.

<details><summary>parameters</summary>

**<code>iu</code>**: <code>number|undef</code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_lu<a id='f-verify_lu'></a>

<code>*function* verify_lu(lu: list|undef)</code>

Verifies the `lu` type is either a list or undef.

<details><summary>parameters</summary>

**<code>lu</code>**: <code>list|undef</code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_u<a id='f-verify_u'></a>

<code>*function* verify_u(u: undef)</code>

Verifies `u` is undef.

<details><summary>parameters</summary>

**<code>u</code>**: <code>undef</code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_fn<a id='f-verify_fn'></a>

<code>*function* verify_fn(fn: function)</code>

Verifies `fn` is function.

<details><summary>parameters</summary>

**<code>fn</code>**: <code>function</code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_uu<a id='f-verify_uu'></a>

<code>*function* verify_uu(birls: number|list|<a href="#t-range">range</a>|<a href="#t-slice">slice</a>, end\_i: number|undef)</code>

Verifies the `birls` and `end_i` are both undef.

<details><summary>parameters</summary>

**<code>birls</code>**: <code>number|list|<a href="#t-range">range</a>|<a href="#t-slice">slice</a></code>

Value to check.

**<code>end_i</code>**: <code>number|undef</code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_slice<a id='f-verify_slice'></a>

<code>*function* verify_slice(slc: <a href="#t-slice">slice</a>)</code>

Verifies the `slc` type is a slice.

<details><summary>parameters</summary>

**<code>slc</code>**: <code><a href="#t-slice">slice</a></code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_birlei<a id='f-verify_birlei'></a>

<code>*function* verify_birlei(birl: number|list|<a href="#t-range">range</a>, end\_i: number|undef)</code>

Verifies the `birl` types are either a number, list or range and `end_i`
is either a number or undef as appropriate.

> â„¹ï¸ NOTE:
>
> A normalised `birlsei` is a `birlei`.

> ğŸ¤” TO THINK ABOUT:
>
> List check doesn't check to see if all values are numbers yet.  Necessary?

<details><summary>parameters</summary>

**<code>birl</code>**: <code>number|list|<a href="#t-range">range</a></code>

Value to check.

**<code>end_i</code>**: <code>number|undef</code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_birlsei<a id='f-verify_birlsei'></a>

<code>*function* verify_birlsei(birls: number|list|<a href="#t-range">range</a>|<a href="#t-slice">slice</a>, end\_i: number|undef)</code>

Verifies the `birls` type are either a number, list or range or slice
and `end_i` is either a number or undef as appropriate.

<details><summary>parameters</summary>

**<code>birls</code>**: <code>number|list|<a href="#t-range">range</a>|<a href="#t-slice">slice</a></code>

Value to check.

**<code>end_i</code>**: <code>number|undef</code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_biei<a id='f-verify_biei'></a>

<code>*function* verify_biei(begin\_i: number, end\_i: number)</code>

Verifies the `begin_i` and `end_i` types are both numbers.

<details><summary>parameters</summary>

**<code>begin_i</code>**: <code>number</code>

Value to check.

**<code>end_i</code>**: <code>number</code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘Value Checks</i><a id='ch-param_check-_value__checks'></a>

These check that the values are within bounds.

#### âš™ï¸verify\_precache<a id='f-verify_precache'></a>

<code>*function* verify_precache(slr: string|list|<a href="#t-range">range</a>, birls: number|list|<a href="#t-range">range</a>|<a href="#t-slice">slice</a>, end\_i: number|undef)</code>

Verifies the `slr` is a slr and that `birls` and `end_i` are the right type
and contain only positive values that are valid indices for the `slr`.

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

slr to check against.

**<code>birls</code>**: <code>number|list|<a href="#t-range">range</a>|<a href="#t-slice">slice</a></code>

Value to check.

**<code>end_i</code>**: <code>number|undef</code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_vbis<a id='f-verify_vbis'></a>

<code>*function* verify_vbis(slr: string|list|<a href="#t-range">range</a>, birl: number|list|<a href="#t-range">range</a>, end\_i: number|undef, \_slr\_len: number|undef)</code>

Verifies valid birlei indices.  I.e. `0 <= i < slr_len` where `i âˆˆ birlei`.

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

Value to reference.

**<code>birl</code>**: <code>number|list|<a href="#t-range">range</a></code>

Value to check.

**<code>end_i</code>**: <code>number|undef</code>

Value to check.

**<code>_slr_len</code>**: <code>number|undef</code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_vbsis<a id='f-verify_vbsis'></a>

<code>*function* verify_vbsis(slr: string|list|<a href="#t-range">range</a>, birls: number|list|<a href="#t-range">range</a>|<a href="#t-slice">slice</a>, end\_i: number|undef, \_slr\_len: number|undef)</code>

Verifies valid birlsei indices.  I.e. `0 <= i < slr_len(slr)` where
`i âˆˆ birlsei`.

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

Value to reference.

**<code>birls</code>**: <code>number|list|<a href="#t-range">range</a>|<a href="#t-slice">slice</a></code>

Value to check.

**<code>end_i</code>**: <code>number|undef</code>

Value to check.

**<code>_slr_len</code>**: <code>number|undef</code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸\_get\_slr\_len<a id='f-_get_slr_len'></a>

<code>*function* _get_slr_len(slr: string|list|<a href="#t-range">range</a>, \_slr\_len: number|undef) : number</code>

Verifies that `_slr_len` is undef or it is the same as `slr_len(slr)`.

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

Value to reference.

**<code>_slr_len</code>**: <code>number|undef</code>

- If number, then checked against actual `slr_len(slr)` value.
- If undef, then ignored.

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

Length of `slr`.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_vi<a id='f-verify_vi'></a>

<code>*function* verify_vi(slr: string|list|<a href="#t-range">range</a>, i: number, \_slr\_len: number|undef)</code>

Verifies valid `i`.  I.e. `-slr_len <= i < slr_len`.

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

Value to reference.

**<code>i</code>**: <code>number</code>

Value to check.

**<code>_slr_len</code>**: <code>number|undef</code>

Cache value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_vie<a id='f-verify_vie'></a>

<code>*function* verify_vie(slr: string|list|<a href="#t-range">range</a>, i: number, \_slr\_len: number|undef)</code>

Verifies valid `i`.  I.e. `-slr_len(slr) <= i <= slr_len(slr)`.
Like `verify_vi()` but allows `i` to be equal to `slr_len(slr)`.

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

Value to reference.

**<code>i</code>**: <code>number</code>

Value to check.

**<code>_slr_len</code>**: <code>number|undef</code>

Cache value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_vpi<a id='f-verify_vpi'></a>

<code>*function* verify_vpi(slr\_or\_i: string|list|<a href="#t-range">range</a>|number, i: number|undef, \_slr\_len: number|undef)</code>

Possible callchains:

    verify_vpi(i)
    verify_vpi(slr_or_i, i)
    verify_vpi(slr_or_i, i, _slr_len)

Verifies valid positive `i`.
- If 1 parameter, then `0 â‰¤ i`.
- If 2+ parameters, `0 â‰¤ i < slr_len(slr_or_i)`.

<details><summary>parameters</summary>

**<code>slr_or_i</code>**: <code>string|list|<a href="#t-range">range</a>|number</code>

- If slr, then this is the value to reference.
- If number, then this is the value to check.

**<code>i</code>**: <code>number|undef</code>

- If number, then this is the value to check.
- If undef, then this is ignored.

**<code>_slr_len</code>**: <code>number|undef</code>

- If number, then checked against actual `slr_len(slr_or_i)` value.
- If undef, then ignored.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_vpie<a id='f-verify_vpie'></a>

<code>*function* verify_vpie(slr: string|list|<a href="#t-range">range</a>, i: number, \_slr\_len: number|undef)</code>

Possible callchains:

    verify_vpie(slr, i)
    verify_vpie(slr, i, _slr_len)

Verifies valid positive `i`. E.g. `0 â‰¤ i â‰¤ slr_len(slr)`.
Like `verify_vpi()` but allows `i` to be equal to `slr_len(slr)`.

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

Value to reference.

**<code>i</code>**: <code>number</code>

Value to check.

**<code>_slr_len</code>**: <code>number|undef</code>

- If number, then checked against actual `slr_len(slr)` value.
- If undef, then ignored.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_vlen<a id='f-verify_vlen'></a>

<code>*function* verify_vlen(slr: string|list|<a href="#t-range">range</a>, \_slr\_len: number|undef)</code>

Verifies `is_undef(_slr_len) || _slr_len == slr_len(slr)`

<details><summary>parameters</summary>

**<code>slr</code>**: <code>string|list|<a href="#t-range">range</a></code>

Value to reference.

**<code>_slr_len</code>**: <code>number|undef</code>

- If number, then checked against actual `slr_len(slr)` value.
- If undef, then ignored.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_vblen<a id='f-verify_vblen'></a>

<code>*function* verify_vblen(birl: number|list|<a href="#t-range">range</a>, end\_i: number|undef, birlei\_len: number)</code>

Verifies birlei length is equal to `birlei_len`.

<details><summary>parameters</summary>

**<code>birl</code>**: <code>number|list|<a href="#t-range">range</a></code>

Value to reference.

**<code>end_i</code>**: <code>number|undef</code>

Value to reference.

**<code>birlei_len</code>**: <code>number</code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_vbinc<a id='f-verify_vbinc'></a>

<code>*function* verify_vbinc(birl: number|list|<a href="#t-range">range</a>, end\_i: number|undef)</code>

Verifies valid increasing `birlei`.

<details><summary>parameters</summary>

**<code>birl</code>**: <code>number|list|<a href="#t-range">range</a></code>

Value to check.

**<code>end_i</code>**: <code>number|undef</code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_vnz<a id='f-verify_vnz'></a>

<code>*function* verify_vnz(v: number)</code>

Verifies `v` is not `0`.

<details><summary>parameters</summary>

**<code>v</code>**: <code>number</code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_vpos<a id='f-verify_vpos'></a>

<code>*function* verify_vpos(v: number)</code>

Verifies `v` is a positive number (`v > 0`).

<details><summary>parameters</summary>

**<code>v</code>**: <code>number</code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸verify\_nesl<a id='f-verify_nesl'></a>

<code>*function* verify_nesl(sl: string|list)</code>

Verifies `sl` is a non-empty string or list.

<details><summary>parameters</summary>

**<code>sl</code>**: <code>string|list</code>

Value to check.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

<hr/>

## ğŸ“˜transform<a id='file-transform'></a>

### <i>ğŸ“‘How to Import</i><a id='ch-transform-_how_to__import'></a>

    use <transform>

### <i>ğŸ“‘Purpose</i><a id='ch-transform-_purpose'></a>

This library is for matrix math for a variety of things.

### <i>ğŸ“‘Generate Matrices for Vector Transforms</i><a id='ch-transform-_generate__matrices_for__vector__transforms'></a>

#### âš™ï¸transpose<a id='f-transpose'></a>

<code>*function* transpose(A: <a href="#t-Matrix">Matrix</a>) : <a href="#t-Matrix">Matrix</a></code>

Transpose of a matrix.

- Matrix (list of equal-length rows) â†’ transposed matrix

> â„¹ï¸ NOTE:
>
> There is no need to transpose a vector to a column vector.  When OpenSCAD
> sees `M * V` or `V * M`, the vector `V` is automatically treated as a
> column or
> row vector as appropriate.

<details><summary>parameters</summary>

**<code>A</code>**: <code><a href="#t-Matrix">Matrix</a></code>

The matrix to transpose.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-Matrix">Matrix</a></code>

The transpose of matrix A.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸homogenise<a id='f-homogenise'></a>

<code>*function* homogenise(pts: list\[<a href="#t-Point">Point</a>,...], n: number) : list\[<a href="#t-Point">Point</a>,...]</code>

Convert points to homogeneous coordinates.

Each point is padded with zeros up to dimension n-1, then a trailing 1 is
appended.

<details><summary>parameters</summary>

**<code>pts</code>**: <code>list\[<a href="#t-Point">Point</a>,...]</code>

List of points.  Each point must have dimension < n.

**<code>n</code>**: <code>number</code> *(Default: `4`)*

Target homogeneous dimension.  Must be greater than the dimension of every
point in pts.

</details>

<details><summary>returns</summary>

**Returns**: <code>list\[<a href="#t-Point">Point</a>,...]</code>

List of n-dimensional points with homogeneous coordinate 1 at index n-1.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸dehomogenise<a id='f-dehomogenise'></a>

<code>*function* dehomogenise(pts: list\[<a href="#t-Point">Point</a>,...], n: number) : list\[<a href="#t-Point">Point</a>,...]</code>

Dehomogenises a list of homogeneous points to Euclidean points.

Each input point must have at least n+1 coordinates.  The homogeneous divisor w is the
last coordinate of the point (index len(pt)-1).  This function returns the first n
coordinates divided by w, and discards all remaining coordinates.

This is the companion to homogenise() when homogenise() places w at the last coordinate.  A
typical pipeline is: homogenise points to match an MÃ—M transform, multiply, then project
back to N dimensions with dehomogenise(..., N).

Preconditions (enforced by asserts):

- Every point pt satisfies len(pt) > n.  (There must be a last coordinate to use as w.)
- w != 0.  (Homogeneous projection is undefined for w == 0.)

<details><summary>parameters</summary>

**<code>pts</code>**: <code>list\[<a href="#t-Point">Point</a>,...]</code>

List of homogeneous points.

**<code>n</code>**: <code>number</code> *(Default: `3`)*

Number of Euclidean coordinates to return per point.

</details>

<details><summary>returns</summary>

**Returns**: <code>list\[<a href="#t-Point">Point</a>,...]</code>

List of n-dimensional Euclidean points.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸homogenise\_transform<a id='f-homogenise_transform'></a>

<code>*function* homogenise_transform(A: <a href="#t-Matrix">Matrix</a>, n: number) : <a href="#t-Matrix">Matrix</a></code>

Embed a non-homogeneous square transform into a larger homogeneous matrix.

Returns a **homogeneous column-vector** matrix H (nÃ—n).  A is placed in the
top-left block.

Use:

- If H is used as a transform matrix, apply it like any other homogeneous
  column-vector matrix:
  - Single point p: treat p as homogeneous when multiplying.
  - Point list Ps: use transform(Ps, transpose(H)).

<details><summary>parameters</summary>

**<code>A</code>**: <code><a href="#t-Matrix">Matrix</a></code>

Square MÃ—M transform matrix.

**<code>n</code>**: <code>number</code> *(Default: `4`)*

Target homogeneous dimension.  Must satisfy M < n.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-Matrix">Matrix</a></code>

Homogeneous matrix H (nÃ—n) with A in the top-left block and identity
elsewhere.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸rot\_x<a id='f-rot_x'></a>

<code>*function* rot_x(a: number) : <a href="#t-Matrix3x3">Matrix3x3</a></code>

Rotation matrix about the X axis.

Returns a **non-homogeneous column-vector** rotation matrix M (3Ã—3).

Use:

- Single Point    p:  p' = M * p
- List of Points Ps:  Ps' = Ps * transpose(M)

<details><summary>parameters</summary>

**<code>a</code>**: <code>number</code>

Rotation angle in degrees.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-Matrix3x3">Matrix3x3</a></code>

Column-vector rotation matrix M.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸rot\_y<a id='f-rot_y'></a>

<code>*function* rot_y(a: number) : <a href="#t-Matrix3x3">Matrix3x3</a></code>

Rotation matrix about the Y axis.

Returns a **non-homogeneous column-vector** rotation matrix M (3Ã—3).

Use:

- Single Point    p:  p' = M * p
- List of Points Ps:  Ps' = Ps * transpose(M)

<details><summary>parameters</summary>

**<code>a</code>**: <code>number</code>

Rotation angle in degrees.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-Matrix3x3">Matrix3x3</a></code>

Column-vector rotation matrix M.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸rot\_z<a id='f-rot_z'></a>

<code>*function* rot_z(a: number) : <a href="#t-Matrix3x3">Matrix3x3</a></code>

Rotation matrix about the Z axis.

Returns a **non-homogeneous column-vector** rotation matrix M (3Ã—3).

Use:

- Single Point    p:  p' = M * p
- List of Points Ps:  Ps' = Ps * transpose(M)

<details><summary>parameters</summary>

**<code>a</code>**: <code>number</code>

Rotation angle in degrees.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-Matrix3x3">Matrix3x3</a></code>

Column-vector rotation matrix M.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸is\_point<a id='f-is_point'></a>

<code>*function* is_point(o: any, dim: number) : bool</code>

Checks if `o` has the shape of a vector of `dim` `number`s.

<details><summary>parameters</summary>

**<code>o</code>**: <code>any</code>

Object to test.

**<code>dim</code>**: <code>number</code> *(Default: `3`)*

Number of dimensions the vector should represent.

</details>

<details><summary>returns</summary>

**Returns**: <code>bool</code>

True if has the shape of a point of `dim` `number`s.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸is\_vector<a id='f-is_vector'></a>

<code>*function* is_vector(o: any, dim: number) : bool</code>

Checks if `o` has the shape of a free vector of `dim` `number`s.

<details><summary>parameters</summary>

**<code>o</code>**: <code>any</code>

Object to test.

**<code>dim</code>**: <code>number</code> *(Default: `3`)*

Number of dimensions the vector should represent.

</details>

<details><summary>returns</summary>

**Returns**: <code>bool</code>

True if has the shape of a free vector of `dim` `number`s.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸is\_bound\_vector<a id='f-is_bound_vector'></a>

<code>*function* is_bound_vector(o: any, dim: number) : bool</code>

Checks if `o` has the shape of 2 bound points of `dim` `number`s.  This
represents the starting and ending points of a bound vector.

<details><summary>parameters</summary>

**<code>o</code>**: <code>any</code>

Object to test.

**<code>dim</code>**: <code>number</code> *(Default: `3`)*

Number of dimensions the vector should represent.

</details>

<details><summary>returns</summary>

**Returns**: <code>bool</code>

True if has the shape of 2 bound points of `dim` `number`s.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸rot\_axis<a id='f-rot_axis'></a>

<code>*function* rot_axis(angle: number, axis: <a href="#t-Vector3D">Vector3D</a>) : <a href="#t-Matrix3x3">Matrix3x3</a></code>

Rotation matrix about an arbitrary axis.

Returns a **non-homogeneous column-vector** rotation matrix M (3Ã—3) that
rotates around the specified vector 'axis' rooted in the origin of the
coordinate system.

Use:

- Single Point    p:  p' = M * p
- List of Points Ps:  Ps' = Ps * transpose(M)

<details><summary>parameters</summary>

**<code>angle</code>**: <code>number</code>

Rotation angle in degrees.

**<code>axis</code>**: <code><a href="#t-Vector3D">Vector3D</a></code>

Rotation axis vector (must be non-zero).

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-Matrix3x3">Matrix3x3</a></code>

Column-vector rotation matrix M.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸rotate<a id='f-rotate'></a>

<code>*function* rotate(a: number|list\[number,number,number], v: <a href="#t-Vector3D">Vector3D</a>|<a href="#t-BVector3D">BVector3D</a>) : <a href="#t-Matrix3x3">Matrix3x3</a>|<a href="#t-Matrix4x4">Matrix4x4</a></code>

Rotation matrix that parallels OpenSCAD's rotate() module, with the
additional feature that it can also take a `BVector3D` for `v`, meaning that
it can rotate about the point stipulated by the point in slot 0 of the
BVector.

If `v` is a `Vector3D`, returns a **non-homogeneous column-vector** rotation
matrix M (3Ã—3) that rotates around the specified vector 'axis' rooted in the
origin of the coordinate system.

If `v` is a `BVector3D`, returns a **homogeneous column-vector** rotation
matrix M (4x4) that rotates around the specified vector 'axis' (`v[1]-v[0]`)
around point `v[0]`.

To not have to worry about the matrix size, it's recommended that you use the
[`transform()`](#f-transform) API.

Use if `p` or elements of `Ps` are homogeneous/non-homogeneous as `M` is:

- Single Point    p:  p' = M * p
- List of Points Ps:  Ps' = Ps * transpose(M)
or if don't want to worry about having to use
[`homogenise()`](#f-homogenise)/[`dehomogenise()`](#f-dehomogenise), use
[`transform()`](#f-transform) API:
- Single Point    p:  `p' = transform([p], transpose(M))`
- List of Points Ps:  `Ps' = transform(Ps, transpose(M))`

<details><summary>parameters</summary>

**<code>a</code>**: <code>number|list\[number,number,number]</code>

- If `number` and `v` is not supplied: rotate CCW around Z.
- If `number` and `v` is a `Vector3D`: rotate CCW around axis defined by
  `v`.
- If `list` `[rx,ry,rz]`: apply rotations about X then Y then Z (degrees).
  (v is ignored.)

**<code>v</code>**: <code><a href="#t-Vector3D">Vector3D</a>|<a href="#t-BVector3D">BVector3D</a></code> *(Optional)*

- If `a` is a number
  - If `v` is a specified Vector3D, then this is the axis vector.
  - If `v` is a specified BVector3D, then use direction for the axis vector
    and `v[0]` as the rotation point.
  - Otherwise axis vector is Z.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-Matrix3x3">Matrix3x3</a>|<a href="#t-Matrix4x4">Matrix4x4</a></code>

Column-vector rotation matrix M.

- If `v` is a `BVector3D`, then returns a homogenised transform matrix
  (4x4).
- If `v` is a `Vector3D`, then returns a non-homogenised transform matrix
  (3x3).

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸translate<a id='f-translate'></a>

<code>*function* translate(v: list\[number]) : <a href="#t-Matrix4x4">Matrix4x4</a></code>

Translation matrix that parallels OpenSCAD's translate() module.

Returns a **homogeneous column-vector** translation matrix T (4Ã—4).

Use:

- Single 3D point `p`: `p` must be as homogeneous (`[x,y,z,1]`) when multiplying.
- Point list `Ps` (3D): use `transform(Ps, transpose(T))`.

<details><summary>parameters</summary>

**<code>v</code>**: <code>list\[number]</code>

Translation vector.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-Matrix4x4">Matrix4x4</a></code>

Homogeneous column-vector translation matrix T.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸scale<a id='f-scale'></a>

<code>*function* scale(v: list\[number]) : <a href="#t-Matrix3x3">Matrix3x3</a></code>

Scale matrix that parallels OpenSCAD's scale() module.

Returns a **non-homogeneous column-vector** scaling matrix S (3Ã—3).

Use:

- Single point p (3-vector):  p' = S * p
- Point list Ps:              Ps' = Ps * transpose(S)

<details><summary>parameters</summary>

**<code>v</code>**: <code>list\[number]</code>

Per-axis scale factors.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-Matrix3x3">Matrix3x3</a></code>

Column-vector scaling matrix S.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸transform<a id='f-transform'></a>

<code>*function* transform(pts: list\[<a href="#t-Point">Point</a>], matrix\_or\_fn: <a href="#t-Matrix3x3">Matrix3x3</a>|<a href="#t-Matrix4x4">Matrix4x4</a>|function) : list\[<a href="#t-Point">Point</a>]</code>

Transform a list of points using either a matrix or a point-mapping function.

Points in pts are treated as **row vectors** (each point is a 1Ã—d row).

- If `matrix_or_fn` is a `Matrix`, and since all matrices generated by this
  library are column-vector matrices `M`, you must pass `transpose(M)` here.

- If matrix_or_fn is a homogeneous matrix (e.g.  4Ã—4 for 3D points), this
  function homogenises pts, multiplies, then dehomogenises back to the
  original point dimension.

<details><summary>parameters</summary>

**<code>pts</code>**: <code>list\[<a href="#t-Point">Point</a>]</code>

List of points (rows).  All points must have the same dimension.

**<code>matrix_or_fn</code>**: <code><a href="#t-Matrix3x3">Matrix3x3</a>|<a href="#t-Matrix4x4">Matrix4x4</a>|function</code>

Either:

- a matrix in row-vector orientation (typically `transpose(M)`), or
- a function that maps a single point to a transformed point.

</details>

<details><summary>returns</summary>

**Returns**: <code>list\[<a href="#t-Point">Point</a>]</code>

Transformed points.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸frame\_transform<a id='f-frame_transform'></a>

<code>*function* frame_transform(src\_ref: <a href="#t-AxisFrameRef">AxisFrameRef</a>|<a href="#t-PlanarFrameRef">PlanarFrameRef</a>|<a href="#t-SpatialFrameRef">SpatialFrameRef</a>, dst\_ref: <a href="#t-AxisFrameRef">AxisFrameRef</a>|<a href="#t-PlanarFrameRef">PlanarFrameRef</a>|<a href="#t-SpatialFrameRef">SpatialFrameRef</a>, axis\_scales: bool|number|list\[bool|number,...]) : <a href="#t-Matrix4x4">Matrix4x4</a></code>

Possible callchains:

    frame_transform(src_axis_ref,  dst_axis_ref,  axis_scales) : Matrix4x4
    frame_transform(src_plane_ref, dst_plane_ref, axis_scales) : Matrix4x4
    frame_transform(src_frame_ref, dst_frame_ref, axis_scales) : Matrix4x4

Returns a homogeneous transform matrix T (4Ã—4) that maps one reference frame
to another (move + orientation, with optional scaling).

Each reference frame is given as a "vector space" list:

  `[origin, end0, ..., endN]` where `N âˆˆ {0,1,2}`.  (So length is 2-4.)

The axis directions are defined by:

  `v_i = end_i - origin`   (for i = 0..N)

Axis order is the endpoint order:

    end0 -> axis 0 (x),  end1 -> axis 1 (y),  end2 -> axis 2 (z).

Mapping contract:
  - The origin maps exactly: `T * [src_origin,1] = [dst_origin,1]`
    (in homogeneous coordinates, i.e. the 3D point with a 1 appended).
  - Axis directions are reoriented so axis i in space 1 aligns to axis i in
    space 2.
  - If scaling is enabled (see axis_scales), axis magnitudes are adjusted per
    the selected rule.

Overloads (by input length):
  - 2-point ([`AxisFrameRef`](#t-_axis_frame_ref)):  aligns a single axis
    direction (end0-origin). Roll about that axis is not defined by the
    inputs.  When the directions are opposite (180Â°), a deterministic
    perpendicular axis is chosen to define the rotation.

    > â„¹ï¸ NOTE:
    >
    > Scaling is uniform (same factor in x/y/z); axis_scales controls that
    > single uniform factor.

  - 3-point ([`PlanarFrameRef`](#t-_planar_frame_ref)):  aligns two axes in a
    plane.  The third axis is derived as the right-hand normal:
    `cross(axis0, axis1)`.  The normal axis is not scaled.
  - 4-point ([`SpatialFrameRef`](#t-_spatial_frame_ref)):  aligns a full 3D
    frame (three axes).  The three axis vectors must be linearly independent
    (i.e. not coplanar).

axis_scales controls scaling along the defined axes:
  - false: reorient only (no scaling).
  - true:  per-axis ratio scaling:  `s_i = |dst_axis_i| / |src_axis_i|`.
  - number: scale each defined axis by that factor.
  - `list[(bool|number), ...]`: per-axis control in endpoint order.

> â„¹ï¸ NOTE:
>
> This returns a matrix intended for column-vector style application, i.e.
> vertices `v=[x,y,z,1]` are transformed as `m*v`.  The 4th row is
> `[0,0,0,1]`.

<details><summary>parameters</summary>

**<code>src_ref</code>**: <code><a href="#t-AxisFrameRef">AxisFrameRef</a>|<a href="#t-PlanarFrameRef">PlanarFrameRef</a>|<a href="#t-SpatialFrameRef">SpatialFrameRef</a></code>

**<code>dst_ref</code>**: <code><a href="#t-AxisFrameRef">AxisFrameRef</a>|<a href="#t-PlanarFrameRef">PlanarFrameRef</a>|<a href="#t-SpatialFrameRef">SpatialFrameRef</a></code>

**<code>axis_scales</code>**: <code>bool|number|list\[bool|number,...]</code> *(Default: `false`)*

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-Matrix4x4">Matrix4x4</a></code>

Homogeneous 4Ã—4 transform matrix, mapping `src_ref` -> `dst_ref`.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘Matrix Math</i><a id='ch-transform-_matrix__math'></a>

#### âš™ï¸invert<a id='f-invert'></a>

<code>*function* invert(A: <a href="#t-Matrix">Matrix</a>, eps: number) : <a href="#t-Matrix">Matrix</a></code>

Invert a square matrix using Gauss-Jordan elimination with partial pivoting.

<details><summary>parameters</summary>

**<code>A</code>**: <code><a href="#t-Matrix">Matrix</a></code>

Non-empty square numeric matrix (list of equal-length lists).

**<code>eps</code>**: <code>number</code> *(Default: `1e-12`)*

Pivot tolerance.  Must be > 0.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-Matrix">Matrix</a></code>

The inverse matrix `Aâ»Â¹`.

Assertion failure if `A` is not a valid square numeric matrix or if any
pivot has `|pivot| < eps`.

Example

    invert([[4,7],[2,6]])  // -> [[0.6,-0.7],[-0.2,0.4]]

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸row\_reduction<a id='f-row_reduction'></a>

<code>*function* row_reduction(aug: <a href="#t-Matrix">Matrix</a>, k: number, n: number, eps: number) : <a href="#t-Matrix">Matrix</a></code>

Performs Gauss-Jordan row reduction with partial pivoting on an augmented
matrix.

<details><summary>parameters</summary>

**<code>aug</code>**: <code><a href="#t-Matrix">Matrix</a></code>

Augmented matrix of shape `nÃ—(2n)`, typically `[A | I]`.

**<code>k</code>**: <code>number</code>

Current column index (0-based).  External callers pass 0.

**<code>n</code>**: <code>number</code>

Matrix order.  Must equal the row count of aug.

**<code>eps</code>**: <code>number</code>

Pivot tolerance.  Must be > 0.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-Matrix">Matrix</a></code>

The reduced augmented matrix.  For a non-singular A this is `[I | Aâ»Â¹]`.

Assertion failure if `|pivot| < eps` at any step.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸identity<a id='f-identity'></a>

<code>*function* identity(n: number) : <a href="#t-Matrix">Matrix</a></code>

Creates an nÃ—n identity matrix.

<details><summary>parameters</summary>

**<code>n</code>**: <code>number</code>

Matrix order.  Must be > 0.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-Matrix">Matrix</a></code>

The identity matrix of order n.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸augment<a id='f-augment'></a>

<code>*function* augment(A: <a href="#t-Matrix">Matrix</a>, B: <a href="#t-Matrix">Matrix</a>) : <a href="#t-Matrix">Matrix</a></code>

Horizontally concatenates two matrices with the same row count.

<details><summary>parameters</summary>

**<code>A</code>**: <code><a href="#t-Matrix">Matrix</a></code>

Left matrix with r rows.

**<code>B</code>**: <code><a href="#t-Matrix">Matrix</a></code>

Right matrix with r rows.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-Matrix">Matrix</a></code>

The augmented matrix `[A | B]`.

Assertion failure if A and B do not have the same non-zero row count.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸\_right\_half<a id='f-_right_half'></a>

<code>*function* _right_half(aug: <a href="#t-Matrix">Matrix</a>, n: number) : <a href="#t-Matrix">Matrix</a></code>

Extracts the right half (columns `n..2n-1`) of an `n Ã— (2n)` augmented matrix.

<details><summary>parameters</summary>

**<code>aug</code>**: <code><a href="#t-Matrix">Matrix</a></code>

Augmented matrix of shape nÃ—(2n).

**<code>n</code>**: <code>number</code>

Left block width and row count.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-Matrix">Matrix</a></code>

The right nÃ—n block.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸\_swap\_rows<a id='f-_swap_rows'></a>

<code>*function* _swap_rows(M: <a href="#t-Matrix">Matrix</a>, i: number, j: number) : <a href="#t-Matrix">Matrix</a></code>

Returns a copy of matrix M with rows i and j swapped.

<details><summary>parameters</summary>

**<code>M</code>**: <code><a href="#t-Matrix">Matrix</a></code>

Input matrix.

**<code>i</code>**: <code>number</code>

First row index (0-based).

**<code>j</code>**: <code>number</code>

Second row index (0-based).

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-Matrix">Matrix</a></code>

Matrix with rows i and j exchanged.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸\_argmax\_abs\_col<a id='f-_argmax_abs_col'></a>

<code>*function* _argmax_abs_col(aug: <a href="#t-Matrix">Matrix</a>, col: number, start: number) : number</code>

Finds the row index `r âˆˆ [start..n-1]` that maximises `|aug[r][col]|`.
Ties resolve to the first occurrence.

<details><summary>parameters</summary>

**<code>aug</code>**: <code><a href="#t-Matrix">Matrix</a></code>

Matrix to scan.

**<code>col</code>**: <code>number</code>

Column index to examine.

**<code>start</code>**: <code>number</code>

First row index to consider (inclusive).

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

Row index of the maximal absolute entry in the given column slice.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸\_is\_rect\_matrix<a id='f-_is_rect_matrix'></a>

<code>*function* _is_rect_matrix(M: any) : bool</code>

Tests whether M is a rectangular list-of-lists with consistent row length.

<details><summary>parameters</summary>

**<code>M</code>**: <code>any</code>

Candidate matrix.

</details>

<details><summary>returns</summary>

**Returns**: <code>bool</code>

true if M is a non-empty list of rows with equal positive length.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸\_is\_square\_matrix<a id='f-_is_square_matrix'></a>

<code>*function* _is_square_matrix(M: any) : bool</code>

Tests whether M is a square matrix (rectangular and rows == columns).

<details><summary>parameters</summary>

**<code>M</code>**: <code>any</code>

Candidate matrix.

</details>

<details><summary>returns</summary>

**Returns**: <code>bool</code>

true if M is rectangular and `len(M) == len(M[0])`.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸\_all\_numeric<a id='f-_all_numeric'></a>

<code>*function* _all_numeric(M: any) : bool</code>

Tests whether all entries of M are numeric.

<details><summary>parameters</summary>

**<code>M</code>**: <code>any</code>

Candidate matrix.

</details>

<details><summary>returns</summary>

**Returns**: <code>bool</code>

true if every element in every row is numeric.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘transform types</i><a id='ch-transform-transform_types'></a>

#### ğŸ§©Matrix<a id='t-_matrix'></a>

<code>*type* Matrix = list\[list\[number,...],...]</code>

Placeholder for NxM matrix.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©Row3<a id='t-_row3'></a>

<code>*type* Row3 = list\[number,number,number]</code>

A row of 3 numbers used in a Matrix3x3 type.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©Row4<a id='t-_row4'></a>

<code>*type* Row4 = list\[number,number,number,number]</code>

A row of 4 numbers used in a Matrix4x4 type.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©Matrix3x3<a id='t-_matrix3x3'></a>

<code>*type* Matrix3x3 = list\[<a href="#t-Row3">Row3</a>,<a href="#t-Row3">Row3</a>,<a href="#t-Row3">Row3</a>]</code>

A 3Ã—3 non-homogeneous transformation matrix used for rotations and scaling
in 3D space.  Operates on 3-element vectors/points directly.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©Matrix4x4<a id='t-_matrix4x4'></a>

<code>*type* Matrix4x4 = list\[<a href="#t-Row4">Row4</a>,<a href="#t-Row4">Row4</a>,<a href="#t-Row4">Row4</a>,<a href="#t-Row4">Row4</a>]</code>

A 4Ã—4 homogeneous transformation matrix used for translations, rotations
about arbitrary points, and combined transformations in 3D space.  Operates
on homogeneous 4-element vectors `[x,y,z,1]`.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©Point2D<a id='t-_point2_d'></a>

<code>*type* Point2D = list</code>

A 2D point.

<details><summary>slots</summary>
<code><b>0</b></code>: <code>number</code>

This is the dimension `0` or x dimension of the point.  Can also be accessed
by property `.x`.

<code><b>1</b></code>: <code>number</code>

This is the dimension `1` or y dimension of the point.  Can also be accessed
by property `.y`.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©Point3D<a id='t-_point3_d'></a>

<code>*type* Point3D = list</code>

A 3D point.

<details><summary>slots</summary>
<code><b>0</b></code>: <code>number</code>

This is the dimension `0` or x dimension of the point.  Can also be accessed
by property `.x`.

<code><b>1</b></code>: <code>number</code>

This is the dimension `1` or y dimension of the point.  Can also be accessed
by property `.y`.

<code><b>2</b></code>: <code>number</code>

This is the dimension `2` or z dimension of the point.  Can also be accessed
by property `.z`.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©Point<a id='t-_point'></a>

<code>*type* Point = list</code>

An ND point.

<details><summary>slots</summary>
<code><b>0</b></code>: <code>number</code>

This is the dimension `0` or x dimension of the point.  Can also be accessed
by property `.x`.

<code><b>1</b></code>: <code>number</code>

This is the dimension `1` or y dimension of the point.  Can also be accessed
by property `.y`.

<code><b>2</b></code>: <code>number</code>

This is the dimension `2` or z dimension of the point.  Can also be accessed
by property `.z`.

<code><b>n</b></code>: <code>number</code> *(Optional)*

This is the dimension `n` dimension of the point.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©Vector2D<a id='t-_vector2_d'></a>

<code>*type* Vector2D = list</code>

A bound 2D vector, which starts from the origin.

<details><summary>slots</summary>
<code><b>0</b></code>: <code>number</code>

This is the dimension `0` or x dimension of the vector.  Can also be
accessed by property `.x`.

<code><b>1</b></code>: <code>number</code>

This is the dimension `1` or y dimension of the vector.  Can also be
accessed by property `.y`.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©Vector3D<a id='t-_vector3_d'></a>

<code>*type* Vector3D = list</code>

A bound 3D vector, which starts from the origin.

<details><summary>slots</summary>
<code><b>0</b></code>: <code>number</code>

This is the dimension `0` or x dimension of the vector.  Can also be
accessed by property `.x`.

<code><b>1</b></code>: <code>number</code>

This is the dimension `1` or y dimension of the vector.  Can also be
accessed by property `.y`.

<code><b>2</b></code>: <code>number</code>

This is the dimension `2` or z dimension of the vector.  Can also be
accessed by property `.z`.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©Vector<a id='t-_vector'></a>

<code>*type* Vector = list</code>

A bound ND vector, which starts from the origin.

<details><summary>slots</summary>
<code><b>0</b></code>: <code>number</code>

This is the dimension `0` or x dimension of the vector.  Can also be
accessed by property `.x`.

<code><b>1</b></code>: <code>number</code>

This is the dimension `1` or y dimension of the vector.  Can also be
accessed by property `.y`.

<code><b>2</b></code>: <code>number</code>

This is the dimension `2` or z dimension of the vector.  Can also be
accessed by property `.z`.

<code><b>n</b></code>: <code>number</code> *(Optional)*

This is the dimension `n` dimension of the vector.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©BVector2D<a id='t-_b_vector2_d'></a>

<code>*type* BVector2D = list\[<a href="#t-Point2D">Point2D</a>,<a href="#t-Point2D">Point2D</a>]</code>

A bound 2D vector, which starts from point in slot 0 and goes to point in
slot 1.

<details><summary>slots</summary>
<code><b>0</b></code>: <code><a href="#t-Point2D">Point2D</a></code>

This is the starting point for this bound vector.

<code><b>1</b></code>: <code><a href="#t-Point2D">Point2D</a></code>

This is the ending point for this bound vector.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©BVector3D<a id='t-_b_vector3_d'></a>

<code>*type* BVector3D = list\[<a href="#t-Point3D">Point3D</a>,<a href="#t-Point3D">Point3D</a>]</code>

A bound 3D vector, which starts from point in slot 0 and goes to point in
slot 1.

<details><summary>slots</summary>
<code><b>0</b></code>: <code><a href="#t-Point3D">Point3D</a></code>

This is the starting point for this bound vector.

<code><b>1</b></code>: <code><a href="#t-Point3D">Point3D</a></code>

This is the ending point for this bound vector.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©BVector<a id='t-_b_vector'></a>

<code>*type* BVector = list\[<a href="#t-Point">Point</a>,<a href="#t-Point">Point</a>]</code>

A bound ND vector, which starts from point in slot 0 and goes to point in
slot 1.

<details><summary>slots</summary>
<code><b>0</b></code>: <code><a href="#t-Point">Point</a></code>

This is the starting point for this bound vector.

<code><b>1</b></code>: <code><a href="#t-Point">Point</a></code>

This is the ending point for this bound vector.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©AxisFrameRef<a id='t-_axis_frame_ref'></a>

<code>*type* AxisFrameRef = list\[<a href="#t-Point3D">Point3D</a>,<a href="#t-Point3D">Point3D</a>]</code>

Frame reference defined by an origin and a single axis endpoint:

    [origin, end0]

Note: roll about the axis is under-determined by this reference alone.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©PlanarFrameRef<a id='t-_planar_frame_ref'></a>

<code>*type* PlanarFrameRef = list\[<a href="#t-Point3D">Point3D</a>,<a href="#t-Point3D">Point3D</a>,<a href="#t-Point3D">Point3D</a>]</code>

Frame reference defined by an origin and two axis endpoints:

    [origin, end0, end1]

The third axis is implied by the right-hand normal `cross(end0-origin,
end1-origin)`.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©SpatialFrameRef<a id='t-_spatial_frame_ref'></a>

<code>*type* SpatialFrameRef = list\[<a href="#t-Point3D">Point3D</a>,<a href="#t-Point3D">Point3D</a>,<a href="#t-Point3D">Point3D</a>,<a href="#t-Point3D">Point3D</a>]</code>

Frame reference defined by an origin and three axis endpoints:

    [origin, end0, end1, end2]

This defines a full 3D frame (must be non-singular).

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©FrameRef<a id='t-_frame_ref'></a>

<code>*type* FrameRef = <a href="#t-AxisFrameRef">AxisFrameRef</a>|<a href="#t-PlanarFrameRef">PlanarFrameRef</a>|<a href="#t-SpatialFrameRef">SpatialFrameRef</a></code>

  Any supported frame reference shape.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

<hr/>

## ğŸ“˜string<a id='file-string'></a>

### <i>ğŸ“‘How to Import</i><a id='ch-string-_how_to__import'></a>

    use <string>
    include <string_consts> // Constants for show_sign parameter.

### <i>ğŸ“‘Purpose</i><a id='ch-string-_purpose'></a>

OpenSCAD doesn't have any string formatting, which can make reading debug
output challenging.  This library is to help with that.

#### âš™ï¸align\_left<a id='f-align_left'></a>

<code>*function* align_left(s: string, width: number, pad\_char: string) : string</code>

Makes `s` wider to fit into width characters by padding the string on the
right with the `pad_char` character.  If same or wider than width, then do
nothing.

<details><summary>parameters</summary>

**<code>s</code>**: <code>string</code>

String to align.

**<code>width</code>**: <code>number</code>

Minimum width to make `s`.

**<code>pad_char</code>**: <code>string</code> *(Default: `" "`)*

The character to pad `s` with.

</details>

<details><summary>returns</summary>

**Returns**: <code>string</code>

The padded string.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸align\_right<a id='f-align_right'></a>

<code>*function* align_right(s: string, width: number, pad\_char: string) : string</code>

Makes `s` wider to fit into width characters by padding the string on the
left with the `pad_char` character.  If same or wider than width, then do
nothing.

<details><summary>parameters</summary>

**<code>s</code>**: <code>string</code>

String to align.

**<code>width</code>**: <code>number</code>

Minimum width to make `s`.

**<code>pad_char</code>**: <code>string</code> *(Default: `" "`)*

The character to pad `s` with.

</details>

<details><summary>returns</summary>

**Returns**: <code>string</code>

The padded string.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸repeat<a id='f-repeat'></a>

<code>*function* repeat(c: string, i: number, r: string) : string</code>

Repeats a string `c`, `i` times.

<details><summary>parameters</summary>

**<code>c</code>**: <code>string</code>

The string to repeat.

**<code>i</code>**: <code>number</code>

The number of times to repeat.

**<code>r</code>**: <code>string</code> *(Default: `""`)*

The accumulated repeated string.

</details>

<details><summary>returns</summary>

**Returns**: <code>string</code>

The final repeated string.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸\_sign\_str<a id='f-_sign_str'></a>

<code>*function* _sign_str(v: number, show\_sign: <a href="#t-ShowSignEnum">ShowSignEnum</a>) : string</code>

Outputs the sign character for value `v` based on `show_sign` parameter.

<details><summary>parameters</summary>

**<code>v</code>**: <code>number</code>

Value to get +ve/-ve sign value from.

**<code>show_sign</code>**: <code><a href="#t-ShowSignEnum">ShowSignEnum</a></code>

 A value that is taken from SHOW_SIGN_*() consts.

</details>

<details><summary>returns</summary>

**Returns**: <code>string</code>

 Character of `-`, ``, `+` or ` ` (space) depending of sign of `v`.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸float\_to\_string<a id='f-float_to_string'></a>

<code>*function* float_to_string(v: number, left\_justified: bool, show\_sign: <a href="#t-ShowSignEnum">ShowSignEnum</a>, pad\_char: string, min\_width: number, precision: number) : string</code>

Converts a floating point number to a string with formatting.

TODO: Make function also do scientific formatting.

<details><summary>parameters</summary>

**<code>v</code>**: <code>number</code>

Number to convert to string.

**<code>left_justified</code>**: <code>bool</code> *(Default: `true`)*

States if number is left or right justified.

**<code>show_sign</code>**: <code><a href="#t-ShowSignEnum">ShowSignEnum</a></code> *(Default: `SHOW_SIGN_NEG`)*

SHOW_SIGN_NEG - States if to only show a negative sign.
SHOW_SIGN_POS_NEG - states if to show positive/negative signs.
SHOW_SIGN_SPC_NEG - States if to show space for positive sign or negative sign.

**<code>pad_char</code>**: <code>string</code> *(Default: `" "`)*

The character to use for padding a right justified value.

**<code>min_width</code>**: <code>number</code> *(Default: `1`)*

The minimum width of the string.

**<code>precision</code>**: <code>number</code> *(Default: `6`)*

The number of decimal places to use.

</details>

<details><summary>returns</summary>

**Returns**: <code>string</code>

Formatted number.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸obj\_to\_string<a id='f-obj_to_string'></a>

<code>*function* obj_to_string(obj: any, fmt\_fn: function, esc\_chars: list\[string,string], quote\_strings: bool, csv\_esc\_d\_quote: bool) : string</code>

Converts an object to a string so that if the object contains a string, all
escapable characters are escaped.

If `fmt_fn` doesn't recognise `obj` and `obj` is a string, puts double quotes
around it.  If `obj` is list, put `[]` around each element which is formatted
with `obj_to_string`.  Otherwise, use `fmt_fn()` or use `str()` to convert to
a string.

<details><summary>parameters</summary>

**<code>obj</code>**: <code>any</code>

Object to print.

**<code>fmt_fn</code>**: <code>function</code> *(Default: `function(obj) undef`)*

Formatting callback to convert obj to string if obj is recognised or undef
if not.
- obj (any) - Obj to attempt to convert.

@returns {(string|undef)}
  If recognised, the converted object as string, else undef.

**<code>esc_chars</code>**: <code>list\[string,string]</code> *(Default: `\["\\\"\r\n\t", "\\\"rnt"]`)*

A list of 2 strings, where esc_chars[0] is the characters to escape and
esc_chars[1] is the character to have `\\` prefixed to when escaping.  This
allows for only escaping certain characters if desired.

**<code>quote_strings</code>**: <code>bool</code> *(Default: `true`)*

If obj is a string, put double quotes around it. (Default: `true`)

**<code>csv_esc_d_quote</code>**: <code>bool</code> *(Default: `false`)*

When true, if the double quote is in the esc_chars then a double quote (")
will be replaced by a double double quote ("").  This is for the csv IETF
RFC 4180: https://datatracker.ietf.org/doc/html/rfc4180

</details>

<details><summary>returns</summary>

**Returns**: <code>string</code>

String rep of object.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸to\_csv<a id='f-to_csv'></a>

<code>*function* to_csv(a: list\[list\[any]], fmt\_fn: function|undef, RFC\_4180: bool) : string</code>

Converts a 2D array to a csv string.  If an element contains a double quote,
comma or newline, enclose it in double quotes and escape any double quotes.

<details><summary>parameters</summary>

**<code>a</code>**: <code>list\[list\[any]]</code>

A 2D list of any object types to convert to a CSV.

**<code>fmt_fn</code>**: <code>function|undef</code> *(Default: `function(e) undef`)*

Uses this to convert a field into a string if a string is returned.

**<code>RFC_4180</code>**: <code>bool</code> *(Default: `true`)*

- If true, a double quote (") will be replaced by a double double quote
  ("") within a string.  Line feeds not preceded with carriage returns will
  have the line feeds added.  This is to conform to IETF RFC 4180:
  https://datatracker.ietf.org/doc/html/rfc4180
- If false, double quotes and backslashes will be backslash escaped and
  line endings are left as is and new ones added will be "\n".

</details>

<details><summary>returns</summary>

**Returns**: <code>string</code>

Returns a string of the 2D list `a` as a CSV string.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸list\_to\_string<a id='f-list_to_string'></a>

<code>*function* list_to_string(list: list, row\_length: number, fmt\_el\_fn: function, indent: string, indent\_first\_line: bool, new\_indent: string, only\_first\_and\_last: bool) : string</code>

Takes a 1D list and outputs it as a string with only row_length elements on
each row.

E.g.  If row_length were 3 then we'd get something like this:

    [
       a, b, c,
       d, e, f
    ]


If the row_length doesn't evenly divide into the length of the list, it will
be padded with undef at the end.

<details><summary>parameters</summary>

**<code>list</code>**: <code>list</code>

A list to prettify.

**<code>row_length</code>**: <code>number</code> *(Default: `0`)*

The number of elements to show per line. 0 means list is printed as one row.

**<code>fmt_el_fn</code>**: <code>function</code> *(Default: `fmt_list_fn()`)*

Format element callback.  Where `i` is the index of the element, `e` is the
element at `i` and `indent` is the characters to put at the beginning of
the line.  Returns a string representation of the element.

**<code>indent</code>**: <code>string</code> *(Default: `""`)*

The character to put at the beginning of each line.

**<code>indent_first_line</code>**: <code>bool</code> *(Default: `false`)*

States if to indent the first line.

**<code>new_indent</code>**: <code>string</code> *(Default: `"  "`)*

The indent string to add when adding a new indent level.

**<code>only_first_and_last</code>**: <code>bool</code> *(Default: `false`)*

States if to output only first and last row (true) or all rows (false).

</details>

<details><summary>returns</summary>

**Returns**: <code>string</code>

Prettified list.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸fmt\_list\_fn<a id='f-fmt_list_fn'></a>

<code>*function* fmt_list_fn(precision: number, show\_sign: <a href="#t-ShowSignEnum">ShowSignEnum</a>) : function(i: number, e: any, indent: string): string</code>

Used to pass resulting lambda to list_to_string to format any numbers that
are found with a precision and sign formatting.  Everything else is rendered
by str().

<details><summary>parameters</summary>

**<code>precision</code>**: <code>number</code> *(Default: `6`)*

Number of decimal places to show.

**<code>show_sign</code>**: <code><a href="#t-ShowSignEnum">ShowSignEnum</a></code> *(Default: `SHOW_SIGN_SPC_NEG`)*

SHOW_SIGN_NEG - States if to only show a negative sign.
SHOW_SIGN_POS_NEG - states if to show positive/negative signs.
SHOW_SIGN_SPC_NEG - States if to show space for positive sign or negative sign.

</details>

<details><summary>returns</summary>

**Returns**: <code>function(i: number, e: any, indent: string): string</code>

Returns the lambda to render an element.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸fmt\_pt\_list\_fn<a id='f-fmt_pt_list_fn'></a>

<code>*function* fmt_pt_list_fn(precision: number, show\_sign: <a href="#t-ShowSignEnum">ShowSignEnum</a>, min\_widths\_for\_pts: list\[number,...]) : function(i: number, e: any, indent: string): string</code>

Passed to `list_to_string`, this will format elements as if they are a list
of coordinates, placing coordinates of one row over another aligning over the
decimal point.

<details><summary>parameters</summary>

**<code>precision</code>**: <code>number</code> *(Default: `6`)*

The number of decimal places to output.

**<code>show_sign</code>**: <code><a href="#t-ShowSignEnum">ShowSignEnum</a></code> *(Default: `SHOW_SIGN_SPC_NEG`)*

`SHOW_SIGN_NEG` - States if to only show a negative sign.
`SHOW_SIGN_POS_NEG` - states if to show positive/negative signs.
`SHOW_SIGN_SPC_NEG` - States if to show space for positive sign or negative sign.

**<code>min_widths_for_pts</code>**: <code>list\[number,...]</code> *(Optional)*

If specified, will output coord with minimum width of each specified by
corresponding value in this list.

</details>

<details><summary>returns</summary>

**Returns**: <code>function(i: number, e: any, indent: string): string</code>

Returns the lambda to render an element.

If an element is not a list, will output `*UNEXPECTED* ` followed by what
the element was.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸fmt\_pt\_fn<a id='f-fmt_pt_fn'></a>

<code>*function* fmt_pt_fn(precision: number, show\_sign: <a href="#t-ShowSignEnum">ShowSignEnum</a>, min\_widths\_for\_dims: list\[number,...]) : function(i: number, e: any, indent: string): string</code>

Passed to `list_to_string`, this will format element as if it's a coordinate.

<details><summary>parameters</summary>

**<code>precision</code>**: <code>number</code> *(Default: `6`)*

The number of decimal places to output.

**<code>show_sign</code>**: <code><a href="#t-ShowSignEnum">ShowSignEnum</a></code> *(Default: `SHOW_SIGN_SPC_NEG`)*

SHOW_SIGN_NEG - States if to only show a negative sign.
SHOW_SIGN_POS_NEG - states if to show positive/negative signs.
SHOW_SIGN_SPC_NEG - States if to show space for positive sign or negative sign.

**<code>min_widths_for_dims</code>**: <code>list\[number,...]</code> *(Optional)*

If specified, will output coord with minimum width of each specified by
corresponding value in this list.

</details>

<details><summary>returns</summary>

**Returns**: <code>function(i: number, e: any, indent: string): string</code>

Returns the lambda to render an element.

If an element is not a number, will output `*UNEXPECTED* ` followed by what
the element was.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸pt\_list\_to\_string<a id='f-pt_list_to_string'></a>

<code>*function* pt_list_to_string(pts: list\[<a href="#t-Point">Point</a>,...], cols: number, rows: ..., indent: string, only\_first\_and\_last: bool, precision: number) : string</code>

Formats a list of points aligning cols over rows.

<details><summary>parameters</summary>

**<code>pts</code>**: <code>list\[<a href="#t-Point">Point</a>,...]</code>

A list of coordinates.

**<code>cols</code>**: <code>number</code>

Number of columns

**<code>rows</code>**: <code>...</code>

Unused.

**<code>indent</code>**: <code>string</code> *(Default: `""`)*

The character to put at the beginning of each line.

**<code>only_first_and_last</code>**: <code>bool</code> *(Default: `false`)*

States if to output only first and last row (true) or all rows (false).

**<code>precision</code>**: <code>number</code> *(Default: `4`)*

The number of decimal places to output.

</details>

<details><summary>returns</summary>

**Returns**: <code>string</code>

String with the aligned points.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘string types</i><a id='ch-string-string_types'></a>

#### ğŸ§©ShowSignEnum<a id='t-_show_sign_enum'></a>

<code>*type* ShowSignEnum = number</code>

Used to specify how to show the sign of a number.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

<hr/>

## ğŸ“˜string_consts<a id='file-string_consts'></a>

### <i>ğŸ“‘How to Import</i><a id='ch-string_consts-_how_to__import'></a>

    include <string_consts>

### <i>ğŸ“‘Purpose</i><a id='ch-string_consts-_purpose'></a>

Constants representing how to show the sign of a number in string library.

### <i>ğŸ“‘Values for `show_sign` Parameters</i><a id='ch-string_consts-_values_for__show_sign___parameters'></a>

#### ğŸ’ SHOW\_SIGN\_NEG<a id='v-_s_h_o_w__s_i_g_n__n_e_g'></a>

<code>*value* SHOW_SIGN_NEG : <a href="#t-ShowSignEnum">ShowSignEnum</a></code>

The enum that represents showing only -ve and never +ve sign

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
assert(float_to_string( 1, show_sign = SHOW_SIGN_NEG, precision = 1) ==  "1.0")
assert(float_to_string(-1, show_sign = SHOW_SIGN_NEG, precision = 1) == " 1.0")
```

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ SHOW\_SIGN\_POS\_NEG<a id='v-_s_h_o_w__s_i_g_n__p_o_s__n_e_g'></a>

<code>*value* SHOW_SIGN_POS_NEG : <a href="#t-ShowSignEnum">ShowSignEnum</a></code>

The enum that represents showing only -ve and +ve signs

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
assert(float_to_string( 1, show_sign = SHOW_SIGN_POS_NEG, precision = 1) == "+1.0")
assert(float_to_string(-1, show_sign = SHOW_SIGN_POS_NEG, precision = 1) == "-1.0")
```

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ SHOW\_SIGN\_SPC\_NEG<a id='v-_s_h_o_w__s_i_g_n__s_p_c__n_e_g'></a>

<code>*value* SHOW_SIGN_SPC_NEG : <a href="#t-ShowSignEnum">ShowSignEnum</a></code>

The enum that represents showing only -ve and a space for +ve sign

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
assert(float_to_string( 1, show_sign = SHOW_SIGN_SPC_NEG, precision = 1) == " 1.0")
assert(float_to_string(-1, show_sign = SHOW_SIGN_SPC_NEG, precision = 1) == "-1.0")
```

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

<hr/>

## ğŸ“˜helpers<a id='file-helpers'></a>

### <i>ğŸ“‘How to Import</i><a id='ch-helpers-_how_to__import'></a>

    use <helpers>
    include <helpers_consts> // Only needed if using vector_info().

### <i>ğŸ“‘Purpose</i><a id='ch-helpers-_purpose'></a>

Miscellaneous helper functions.

### <i>ğŸ“‘Conversion functions</i><a id='ch-helpers-_conversion_functions'></a>

#### âš™ï¸r2d<a id='f-r2d'></a>

<code>*function* r2d(radians: number) : number</code>

Convert radians to degrees.

<details><summary>parameters</summary>

**<code>radians</code>**: <code>number</code>

radians to convert.

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

Equivalent degrees.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸d2r<a id='f-d2r'></a>

<code>*function* d2r(degrees: number) : number</code>

Convert degrees to radians.

<details><summary>parameters</summary>

**<code>degrees</code>**: <code>number</code>

degrees to convert.

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

Equivalent radians.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘Circular / Spherical Calculations</i><a id='ch-helpers-_circular____spherical__calculations'></a>

#### âš™ï¸arc\_len<a id='f-arc_len'></a>

<code>*function* arc_len(A: list, B: list, R: number) : number</code>

Calculates the arc length between vectors A and B for a circle/sphere of
radius R.  If A and B are the same magnitude, R can be omitted.

<details><summary>parameters</summary>

**<code>A</code>**: <code>list</code>

First vector.

**<code>B</code>**: <code>list</code>

Second vector.

**<code>R</code>**: <code>number</code> *(Optional)*

Radius to use to measure the length along a sphere's great arc.

- If not specified, then will use the magnitude of A. Asserts if magnitude
  of B is not the same.
- If R=1, then the result is equivalent to the arc angle in radians.
- If R=180/PI, then the result is equivalent to the arc angle in degrees.

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

The length of the great arc between the two vectors for a sphere of radius
R.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸arc\_len\_angle<a id='f-arc_len_angle'></a>

<code>*function* arc_len_angle(arc\_len: number, radius: number) : number</code>

Given the length of an arc and the radius of a circle/sphere that it's
traversing, returns the angle traversed in degrees.

`arc_len` and `radius` have the same units.

<details><summary>parameters</summary>

**<code>arc_len</code>**: <code>number</code>

Arc length along the circle.

**<code>radius</code>**: <code>number</code>

Circle radius (must be non-zero).

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

Angle in degrees. Sign follows arc_len.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸\_circle\_line\_intersections<a id='f-_circle_line_intersections'></a>

<code>*function* _circle_line_intersections(R: number, m: number, b: number) : list</code>

Computes the intersection points of a line and a circle around the origin.

The line is y = m*x + b and the circle is x^2 + y^2 = R^2.

<details><summary>parameters</summary>

**<code>R</code>**: <code>number</code>

Radius of the circle.  Callers such as arc_len_for_shift pass R > 0.

**<code>m</code>**: <code>number</code>

Slope of the line (dy/dx).

**<code>b</code>**: <code>number</code>

Y-intercept of the line.

</details>

<details><summary>returns</summary>

**Returns**: <code>list</code>

`[]` if there is no real intersection, or `[[x1, y1], [x2, y2]]` where each
`[x, y]` is a Cartesian intersection point.  For a tangent line both
returned points are identical.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸\_pick\_right<a id='f-_pick_right'></a>

<code>*function* _pick_right(ptlist: list) : list|undef</code>

Picks the "right-side" intersection point from up to two candidates.

This is intended to operate on the list returned by
_circle_line_intersections().  It chooses a single point on the right
half-plane according to a deterministic ordering.

<details><summary>parameters</summary>

**<code>ptlist</code>**: <code>list</code>

List of zero, one, or two points `[[x1, y1], [x2, y2]]`.

</details>

<details><summary>returns</summary>

**Returns**: <code>list|undef</code>

The selected point `[x, y]` or undef if no point has x >= 0.  Among
points with x >= 0 it selects the one with the largest x; if x ties,
it selects the point with the smaller y (the lower point).

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸\_theta\_deg<a id='f-_theta_deg'></a>

<code>*function* _theta_deg(pt: list) : number</code>

Computes the polar angle of a point on the circle in degrees.

<details><summary>parameters</summary>

**<code>pt</code>**: <code>list</code>

Point `[x, y]` in Cartesian coordinates.

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

Angle in degrees measured from the +X axis using atan2(y, x), with the
usual range (-180, 180].

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸\_wrap\_diff\_deg<a id='f-_wrap_diff_deg'></a>

<code>*function* _wrap_diff_deg(a1: number, a2: number) : number</code>

Computes the smallest signed difference between two angles in degrees.

<details><summary>parameters</summary>

**<code>a1</code>**: <code>number</code>

First angle in degrees.

**<code>a2</code>**: <code>number</code>

Second angle in degrees.

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

Signed difference a2 - a1 wrapped into the range (-180, 180].  This is
the minimal rotation in degrees that moves a1 onto a2.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸arc\_len\_for\_shift<a id='f-arc_len_for_shift'></a>

<code>*function* arc_len_for_shift(R: number, m: number, a: number, b: number) : number|undef</code>

Given a `circle R = sqrt(x^2 + y^2)` and a line `y = m*x + (b + a)`,
compute the arc-length difference `Î”s` along the circle between the
intersection of the original line `y = m*x + b` and the shifted line
`y = m*x + (b + a)`. Only the right-side `(x >= 0)` intersection is tracked.

<details><summary>parameters</summary>

**<code>R</code>**: <code>number</code>

circle radius

**<code>m</code>**: <code>number</code>

slope (dy/dx)

**<code>a</code>**: <code>number</code>

vertical shift of the line relative to b

**<code>b</code>**: <code>number</code> *(Default: `0`)*

original y-intercept (default 0)

</details>

<details><summary>returns</summary>

**Returns**: <code>number|undef</code>

Î”s (nonnegative) or `undef` if the right-side intersection does not exist
before or after the shift.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸shift\_for\_arc\_len<a id='f-shift_for_arc_len'></a>

<code>*function* shift_for_arc_len(R: number, m: number, delta\_s: number, b: number) : list\[number|undef,number|undef]</code>

Given a circle `R = sqrt(x^2 + y^2)` and line `y = m*x + b`, compute the
vertical (y-axis) shift values a that would produce a specified arc-length
difference `Î”s` between the original intersection and the shifted line
`y = m*x + (b + a)`, tracking only the right-side `(x >= 0)` intersection.

<details><summary>parameters</summary>

**<code>R</code>**: <code>number</code>

circle radius

**<code>m</code>**: <code>number</code>

slope (dy/dx)

**<code>delta_s</code>**: <code>number</code>

desired arc length difference

**<code>b</code>**: <code>number</code> *(Default: `0`)*

original y-intercept (default 0)

</details>

<details><summary>returns</summary>

**Returns**: <code>list\[number|undef,number|undef]</code>

Slot 0 is `a_up` and slot 1 is `a_down`, where:
    (is_undef(a_up) or a_up â‰¥ 0) and (is_undef(a_down) or a_down â‰¤ 0)
They would be undef if there is no solution for that direction.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘Miscellaneous</i><a id='ch-helpers-_miscellaneous'></a>

#### âš™ï¸not<a id='f-not'></a>

<code>*function* not(not\_fn: function) : function(p: <a href="#t-PredFn">PredFn</a>): bool</code>

Wrap a lambda so that it negates its return value.

<details><summary>parameters</summary>

**<code>not_fn</code>**: <code>function</code>

The function to invert the boolean's (or equivalent truthy/falsy) value.

</details>

<details><summary>returns</summary>

**Returns**: <code>function(p: <a href="#t-PredFn">PredFn</a>): bool</code>

Return the lambda that will invert a lambda's truth value.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸clamp<a id='f-clamp'></a>

<code>*function* clamp(v: number, lo: number, hi: number) : number</code>

Clamps a value between `[lo, hi]`.

<details><summary>parameters</summary>

**<code>v</code>**: <code>number</code>

Value to clamp.

**<code>lo</code>**: <code>number</code>

Lowest value v should take.

**<code>hi</code>**: <code>number</code>

Highest value v should take.

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

Value v that is clamped between `[lo, hi]`.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸vector\_info<a id='f-vector_info'></a>

<code>*function* vector_info(a: <a href="#t-Point">Point</a>, b: <a href="#t-Point">Point</a>) : <a href="#t-VectorInfo">VectorInfo</a></code>

Computes direction, length, unit vector and normal to unit vector, and puts
them into a list.

Add `include <helpers_consts>` to use the appropriate constants.

<details><summary>parameters</summary>

**<code>a</code>**: <code><a href="#t-Point">Point</a></code>

Starting point of vector

**<code>b</code>**: <code><a href="#t-Point">Point</a></code>

Ending point of vector

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-VectorInfo">VectorInfo</a></code>

Object containing the info of all the operations.  See `VectorInfo` type
for details.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸equal<a id='f-equal'></a>

<code>*function* equal(v1: any, v2: any, epsilon: number) : bool</code>

Checks the equality of two items.  If v1 and v2 are lists of the same length,
then check the equality of each element.  If each are numbers, then check to
see if they are both equal to each other within an error of epsilon.  All
other types are done using the == operator.

<details><summary>parameters</summary>

**<code>v1</code>**: <code>any</code>

First item to compare against.

**<code>v2</code>**: <code>any</code>

Second item to compare against.

**<code>epsilon</code>**: <code>number</code> *(Default: `1e-6`)*

The max error tolerated for a number.

</details>

<details><summary>returns</summary>

**Returns**: <code>bool</code>

True if the objects are equal within tolerance.  False otherwise.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸function\_equal<a id='f-function_equal'></a>

<code>*function* function_equal()</code>

Hoists function into variable namespace to be able to be passed as a lambda.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸default<a id='f-default'></a>

<code>*function* default(v: any, d: any) : any</code>

If v is undefined, then return the default value d.

<details><summary>parameters</summary>

**<code>v</code>**: <code>any</code>

The value to test if defined.

**<code>d</code>**: <code>any</code>

The result to give if v is undefined.

</details>

<details><summary>returns</summary>

**Returns**: <code>any</code>

If v is defined, then return v, else d.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸INCOMPLETE<a id='f-_i_n_c_o_m_p_l_e_t_e'></a>

<code>*function* INCOMPLETE()</code>

Used to mark code as incomplete.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸offset\_angle<a id='f-offset_angle'></a>

<code>*function* offset_angle(ref\_vec: <a href="#t-Point">Point</a>, vec: <a href="#t-Point">Point</a>, delta\_angle\_deg: number) : <a href="#t-Point">Point</a></code>

Rotate vec so that the angle between ref_vec and vec increases by
delta_angle_deg.

Uses rotate(delta_angle_deg, cross(ref_vec, vec)) and applies it to vec.

<details><summary>parameters</summary>

**<code>ref_vec</code>**: <code><a href="#t-Point">Point</a></code>

Reference vector.  Must have norm(ref_vec) > 0.

**<code>vec</code>**: <code><a href="#t-Point">Point</a></code>

Vector to rotate.  Must have norm(vec) > 0 and must not be (anti)parallel to
ref_vec.

**<code>delta_angle_deg</code>**: <code>number</code>

Angle increase in degrees.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-Point">Point</a></code>

The rotated vector.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§Šarrow<a id='m-arrow'></a>

<code>*module* arrow(l: number, t: number, c: list|string|undef, a: number)</code>

Create an arrow pointing up in the positive z direction.  Primarily used for
debugging.

<details><summary>parameters</summary>

**<code>l</code>**: <code>number</code>

Length of arrow.

**<code>t</code>**: <code>number</code> *(Default: `1`)*

Thickness of arrowhead shaft.

**<code>c</code>**: <code>list|string|undef</code>

Same as color() module's first parameter. `[r, g, b]`, `[r, g, b, a]`,
`"color_name"`, `"#hex_value"`.  If not defined, no colour is applied.

**<code>a</code>**: <code>number</code>

Same as color() module's optional second parameter.  Alpha value between
`[0, 1]`.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§Šaxis<a id='m-axis'></a>

<code>*module* axis(l: number, t: number)</code>

Create 3 arrows aligning to x, y and z axis coloured red, green and blue
respectively.

<details><summary>parameters</summary>

**<code>l</code>**: <code>number</code>

Length of arrow.

**<code>t</code>**: <code>number</code> *(Default: `1`)*

Thickness of arrowhead shaft.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸fl<a id='f-fl'></a>

<code>*function* fl(f: string, l: number) : string</code>

File line function to output something that looks like a file line to be able
to jump to the file/line in VSCode easier.

To make it easier in a file, create the following variable in that file:

```openscad
_fl = function(l) fl("<this-file-name>", l);
```

As a variable, it won't get exported.  Use that in your file.

<details><summary>parameters</summary>

**<code>f</code>**: <code>string</code>

Name of file.

**<code>l</code>**: <code>number</code>

Line number in file.

</details>

<details><summary>returns</summary>

**Returns**: <code>string</code>

Returns a string which will allow you to ctrl-click on the string text from
the terminal window.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸Assert<a id='f-_assert'></a>

<code>*function* Assert(truth: bool, msg: string|function) : <a href="#t-IdentityFn">IdentityFn</a></code>

Possible callchains:

    Assert(truth, msg) (value) : any

Asserts that `truth` is `true`.

Currently, `assert()` will evaluate the parameters prior to testing the
truthiness of `truth`.  If the `msg` is an expensive operation, this can have
performance consequences.  This function allows the `msg` to be a function,
preventing evaluation of the `msg` if not needed.

This also returns an identity function which allows to embed this inside of
an expression with minimal effort.

> â„¹ï¸ NOTE:
>
> There is an enhancement to potentially resolve this reported by me here:
> <https://github.com/openscad/openscad/issues/6240>

<details><summary>parameters</summary>

**<code>truth</code>**: <code>bool</code>

- If truthy, returns function that takes a parameter  which it returns
  unmodified.

**<code>msg</code>**: <code>string|function</code> *(Default: `""`)*

- If truth is falsy, then
  - If msg is a function, execute it to get the actual message.
  - Otherwise pass msg unmolested.
  - Assert fails with msg.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-IdentityFn">IdentityFn</a></code>

Returns a function that returns the `return_value` unmolested.  This allows
to put the `Assert()` function in the middle of an expression if desired.

Possible callchains:

    IdentityFn(return_value) : any

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸interpolated\_values<a id='f-interpolated_values'></a>

<code>*function* interpolated_values(p0: number|list, p1: number|list, number\_of\_values: number) : list\[number|list]</code>

Gets a list of `number_of_values` between `p0` and `p1`.

> â„¹ï¸ NOTE:
>
> `p0` and `p1` must be the same shape and must consist of values that have
> `+`, `-` and `/` operations defined for them.

<details><summary><b>Example:</b><i></i></summary>

```openscad
interpolated_values(1, 2, 1) == [1.5]
interpolated_values(1, 2, 3) == [1.25, 1.5, 1.75]
```

</details>

<details><summary>parameters</summary>

**<code>p0</code>**: <code>number|list</code>

Starting point.

**<code>p1</code>**: <code>number|list</code>

Ending point.

**<code>number_of_values</code>**: <code>number</code>

The number of values to put between `p0` and `p1`.

</details>

<details><summary>returns</summary>

**Returns**: <code>list\[number|list]</code>

List of `number_of_values` that are the interpolated values between `p0`
and `p1`.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘helpers types</i><a id='ch-helpers-helpers_types'></a>

#### ğŸ§©VectorInfo<a id='t-_vector_info'></a>

<code>*type* VectorInfo = list</code>

Results of the [vector_info()](#f-vector_info) call.

<details><summary>slots</summary>
<code><b>VI_VECTOR</b></code>: <code><a href="#t-Point">Point</a></code>

Direction of the ab vector.

<code><b>VI_LENGTH</b></code>: <code>number</code>

Length of ab vector.

<code><b>VI_DIR</b></code>: <code><a href="#t-Point">Point</a></code>

Unit ab vector.

<code><b>VI_NORMAL</b></code>: <code><a href="#t-Point">Point</a></code>

A normal unit vector by swapping first two dimensions and then making the
resulting first dimension negative.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©IdentityFn<a id='t-_identity_fn'></a>

<code>*callback* IdentityFn(return\_value: any) : any</code>

Returns the value passed.

<details><summary>parameters</summary>

**<code>return_value</code>**: <code>any</code>

</details>

<details><summary>returns</summary>

**Returns**: <code>any</code>

Returns `return_value`.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

<hr/>

## ğŸ“˜helpers_consts<a id='file-helpers_consts'></a>

### <i>ğŸ“‘How to Import</i><a id='ch-helpers_consts-_how_to__import'></a>

    include <helpers_consts>

### <i>ğŸ“‘Purpose</i><a id='ch-helpers_consts-_purpose'></a>

Helper constants.

### <i>ğŸ“‘For indexing type [VectorInfo](#t-_vector_info).</i><a id='ch-helpers_consts-_for_indexing_type___vector_info___t-_vector_info__'></a>

#### ğŸ’ VI\_VECTOR<a id='v-_v_i__v_e_c_t_o_r'></a>

<code>*value* VI_VECTOR : <a href="#t-VectorInfoEnum">VectorInfoEnum</a></code>

ab vector

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
assert(vector_info([1,0,0], [0,1,0])[VI_VECTOR] == [-1,1,0])
```

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ VI\_LENGTH<a id='v-_v_i__l_e_n_g_t_h'></a>

<code>*value* VI_LENGTH : <a href="#t-VectorInfoEnum">VectorInfoEnum</a></code>

length of ab

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
assert(equal(vector_info([1,0,0], [0,1,0])[VI_LENGTH], sqrt(2)))
```

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ VI\_DIR<a id='v-_v_i__d_i_r'></a>

<code>*value* VI_DIR : <a href="#t-VectorInfoEnum">VectorInfoEnum</a></code>

unit ab vector

<details><summary><b>Example:</b><i> Usage</i></summary>


```openscad
assert(equal(vector_info([1,0,0], [0,1,0])[VI_DIR], [-1,1,0]/sqrt(2)))
```

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ VI\_NORMAL<a id='v-_v_i__n_o_r_m_a_l'></a>

<code>*value* VI_NORMAL : <a href="#t-VectorInfoEnum">VectorInfoEnum</a></code>

vector_info(a, b)[VI_NORMAL] = normal unit vector of ab

<details><summary><b>Example:</b><i> Usage</i></summary>

```openscad
assert(vector_info([1,0,0], [0,2,0])[VI_NORMAL] == [2,1,0])
```

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘helpers_consts types</i><a id='ch-helpers_consts-helpers_consts_types'></a>

#### ğŸ§©VectorInfoEnum<a id='t-_vector_info_enum'></a>

<code>*type* VectorInfoEnum = number</code>

Enums to dereference [`VectorInfo`](#t-_vector_info) type.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

<hr/>

## ğŸ“˜skin<a id='file-skin'></a>

### <i>ğŸ“‘How to Import</i><a id='ch-skin-_how_to__import'></a>

    use <skin>

### <i>ğŸ“‘Purpose</i><a id='ch-skin-_purpose'></a>

The built in extrude module isn't powerful or flexible enough so this library
was made.  It creates a skin by making layers of polygons with the same
number of vertices and then skins them by putting faces between layers.

### <i>ğŸ“‘Design</i><a id='ch-skin-_design'></a>

This requires keeping track of a bunch of data, which was put into a list.
These constants are used for indexing the [skin](#t-skin) object.

### <i>ğŸ“‘Values</i><a id='ch-skin-_values'></a>

#### ğŸ’ \_SKIN\_ID<a id='v-__s_k_i_n__i_d'></a>

<code>*value* _SKIN_ID : ???</code>

Header for skin

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ \_SKIN\_PTS\_IN\_LAYER<a id='v-__s_k_i_n__p_t_s__i_n__l_a_y_e_r'></a>

<code>*value* _SKIN_PTS_IN_LAYER : ???</code>

points in layer

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ \_SKIN\_LAYERS<a id='v-__s_k_i_n__l_a_y_e_r_s'></a>

<code>*value* _SKIN_LAYERS : ???</code>

# of point layers - 1

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ \_SKIN\_PTS<a id='v-__s_k_i_n__p_t_s'></a>

<code>*value* _SKIN_PTS : ???</code>

the list of points

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ \_SKIN\_DEBUG\_AXES<a id='v-__s_k_i_n__d_e_b_u_g__a_x_e_s'></a>

<code>*value* _SKIN_DEBUG_AXES : ???</code>

debug axes

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ \_SKIN\_COMMENT<a id='v-__s_k_i_n__c_o_m_m_e_n_t'></a>

<code>*value* _SKIN_COMMENT : ???</code>

the comment if any

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ \_SKIN\_OPERATION<a id='v-__s_k_i_n__o_p_e_r_a_t_i_o_n'></a>

<code>*value* _SKIN_OPERATION : ???</code>

the operation (`[op, apply_to_next_count]`)

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ \_SKIN\_WALL\_DIAG<a id='v-__s_k_i_n__w_a_l_l__d_i_a_g'></a>

<code>*value* _SKIN_WALL_DIAG : ???</code>

wall diagonal info

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸skin\_to\_string<a id='f-skin_to_string'></a>

<code>*function* skin_to_string(obj: <a href="#t-skin">skin</a>, only\_first\_and\_last\_layers: bool, precision: number) : string</code>

Converts a skin object to a human readable string.

<details><summary>parameters</summary>

**<code>obj</code>**: <code><a href="#t-skin">skin</a></code>

This is the skin object to view.

**<code>only_first_and_last_layers</code>**: <code>bool</code> *(Default: `true`)*

Show only the first and last layers if true, otherwise all layers.

**<code>precision</code>**: <code>number</code> *(Default: `4`)*

The number of decimal places to show the layers.

</details>

<details><summary>returns</summary>

**Returns**: <code>string</code>

The string representation of the skin object.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸layer\_pt<a id='f-layer_pt'></a>

<code>*function* layer_pt(pts\_in\_layer: number, pt\_i: number, layer\_i: number) : number</code>

Computes the index of a point in a layered point array.  This is like a 2D
coordinate map, where `pt_i` is the x-axis (limited by modulo `pts_in_layer`
so that it wraps) and `layer_i` is the y-axis.

This allows to more easily visualise what points are being referenced,
relative to different layers.

Assumes that points are stored consecutively per layer, and layers are
stacked consecutively in memory.

<details><summary>parameters</summary>

**<code>pts_in_layer</code>**: <code>number</code>

Number of points in each layer.

**<code>pt_i</code>**: <code>number</code>

Index of the point on a layer (0-based).  If > pts_in_layer, then wraps
back to 0.

**<code>layer_i</code>**: <code>number</code>

Index of the layer (0-based).

</details>

<details><summary>returns</summary>

**Returns**: <code>number</code>

The linear index of the specified point.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸layer\_pts<a id='f-layer_pts'></a>

<code>*function* layer_pts(pts\_in\_layer: number, pt\_offset\_and\_layer\_list: list\[list\[number,number]]) : list\[number,...]</code>

Computes a list of layer indices for multiple points in a layered point
array.

This allows to more easily visualise what points are being referenced,
relative to different layers.

Assumes points are stored consecutively per layer, with each layer laid out
sequentially.

<details><summary>parameters</summary>

**<code>pts_in_layer</code>**: <code>number</code>

Number of points per layer.

**<code>pt_offset_and_layer_list</code>**: <code>list\[list\[number,number]]</code>

List of (point index, layer index) pairs.

</details>

<details><summary>returns</summary>

**Returns**: <code>list\[number,...]</code>

A list of linear layer_i corresponding to the given points.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸layer\_side\_faces<a id='f-layer_side_faces'></a>

<code>*function* layer_side_faces(pts\_in\_layer: number, layers: number, wall\_diagonal: list\[bool,...]) : list\[<a href="#t-Face">Face</a>]</code>

Helper to generate side wall faces between consecutive layers.

Assumes the points are arranged in a flat list, with each layer's points
stored contiguously, and layers stored in sequence. Points within each
layer must be ordered **clockwise when looking into the object**.

Each wall segment is formed from two triangles connecting corresponding
points between adjacent layers.  Each triangle is a [`Face`](#t-_face).

<details><summary>parameters</summary>

**<code>pts_in_layer</code>**: <code>number</code>

Number of points per layer.

**<code>layers</code>**: <code>number</code> *(Default: `1`)*

Number of vertical wall segments to generate (requires one more point
layer).

**<code>wall_diagonal</code>**: <code>list\[bool,...]</code> *(Default: `\[0,1]`)*

This is used to allow changing the diagonal of neighbouring square polygons
on a layer.

E.g.

- `[1]` will have all diagonals go one way.
- `[1,0]` will alternate.
- `[0,1]` will alternate the opposite way to `[1,0]`.
- `[0,0,1]` will have it go one way for 2 consecutive 4 point face, and
  then the other way, and then repeat.

</details>

<details><summary>returns</summary>

**Returns**: <code>list\[<a href="#t-Face">Face</a>]</code>

A list of triangle layer_i forming the side walls.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ \_ear\_cw<a id='v-_ear_cw'></a>

<code>*value* _ear_cw : function</code>

Given a set of points and an index, returns a face if `pts[pt_is[i..i+2]]`
are convex, or undef if concave or colinear.

This is for clockwise polygons when looking towards -z.

<details><summary>parameters</summary>

**<code>pts</code>**: <code>list\[<a href="#t-Point2D">Point2D</a>,...]</code>

A list of 2D points

**<code>pt_i0</code>**: <code>number</code>

Index into the `pts` list.

**<code>pt_i1</code>**: <code>number</code>

Index into the `pts` list.

**<code>pt_i2</code>**: <code>number</code>

Index into the `pts` list.

**<code>eps</code>**: <code>number</code> *(Default: `1e-6`)*

Biggest abs value to consider as 0.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-Face">Face</a>|undef</code>

Face if convex, or undef if concave or colinear.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ’ \_ear\_ccw<a id='v-_ear_ccw'></a>

<code>*value* _ear_ccw : function</code>

Given a set of points and an index, returns a face if `pts[pt_is[i..i+2]]`
are convex, or undef if concave or colinear.

This is for counter-clockwise polygons when looking towards -z.

<details><summary>parameters</summary>

**<code>pts</code>**: <code>list\[<a href="#t-Point2D">Point2D</a>,...]</code>

A list of 2D points

**<code>pt_i0</code>**: <code>number</code>

Index into the `pts` list.

**<code>pt_i1</code>**: <code>number</code>

Index into the `pts` list.

**<code>pt_i2</code>**: <code>number</code>

Index into the `pts` list.

**<code>eps</code>**: <code>number</code> *(Default: `1e-6`)*

Biggest abs value to consider as 0.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-Face">Face</a>|undef</code>

Face if convex, or undef if concave or colinear.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸\_pt\_in\_triangle<a id='f-_pt_in_triangle'></a>

<code>*function* _pt_in_triangle()</code>

Determines if `pt` is in triangle `(pt0, pt1, pt2)`. `_*` parameters are
cached values.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸\_any\_point\_in\_ear<a id='f-_any_point_in_ear'></a>

<code>*function* _any_point_in_ear()</code>

Checks if any point indexed by pt_is that is not `pt_i{0, 1, 2}` is inclusively
bounded by the triangle `pts[pt_is[pt_i{0, 1, 2}]]`.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸\_cap\_ears<a id='f-_cap_ears'></a>

<code>*function* _cap_ears(pts: list\[<a href="#t-Point3D">Point3D</a>,...], pt\_is: list\[number,...], create\_ear\_fn: function, \_i: number, \_faces: list\[<a href="#t-Face">Face</a>,...], \_removed\_at\_least\_one\_ear: bool) : list\[<a href="#t-Face">Face</a>,...]</code>

Caps the end of a face by making all ears into faces until none left.

Parameters starting with _ will not be set by the external caller.

<details><summary>parameters</summary>

**<code>pts</code>**: <code>list\[<a href="#t-Point3D">Point3D</a>,...]</code>

Points that `pt_is` references.

**<code>pt_is</code>**: <code>list\[number,...]</code>

Point indices to dereference `pts` with.

**<code>create_ear_fn</code>**: <code>function</code>

Callback that when given the set of point indices, return a new face or
undef if not an ear.

**<code>_i</code>**: <code>number</code> *(Default: `0`)*

Where to start traversing polygon for ear clipping.

**<code>_faces</code>**: <code>list\[<a href="#t-Face">Face</a>,...]</code> *(Default: `\[]`)*

Faces.

**<code>_removed_at_least_one_ear</code>**: <code>bool</code> *(Default: `false`)*

States if at least one ear has been removed after one complete cycle of cap
points.

</details>

<details><summary>returns</summary>

**Returns**: <code>list\[<a href="#t-Face">Face</a>,...]</code>

Faces

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸\_proj\_pts<a id='f-_proj_pts'></a>

<code>*function* _proj_pts(pts: list\[<a href="#t-Point3D">Point3D</a>,...], dim\_i: number) : list\[<a href="#t-Point2D">Point2D</a>,...]</code>

Project all points to an axis by removing `dim_i` and possibly swapping
coordinates.  This is done to simplify calculations.

<details><summary>parameters</summary>

**<code>pts</code>**: <code>list\[<a href="#t-Point3D">Point3D</a>,...]</code>

Points to have projected.

**<code>dim_i</code>**: <code>number</code>

Axis to have project along (have set to 0).  0 = x, 1 = y, 2 = z.

</details>

<details><summary>returns</summary>

**Returns**: <code>list\[<a href="#t-Point2D">Point2D</a>,...]</code>

Returns points with the specified dimension removed.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸\_proj\_to\_what\_norm<a id='f-_proj_to_what_norm'></a>

<code>*function* _proj_to_what_norm(pts: list\[<a href="#t-Point3D">Point3D</a>,...], dim\_i: number, \_n: number, \_n\_len: number, \_dim\_i: number) : list\[number,<a href="#t-Point3D">Point3D</a>]</code>

Determine which projection give the largest normal vector.

<details><summary>parameters</summary>

**<code>pts</code>**: <code>list\[<a href="#t-Point3D">Point3D</a>,...]</code>

A list of points.  Must have at least 3 points.

**<code>dim_i</code>**: <code>number</code> *(Default: `0`)*

Dimension index currently checking.

**<code>_n</code>**: <code>number</code> *(Default: `0`)*

Current best normal found so far.

**<code>_n_len</code>**: <code>number</code> *(Default: `0`)*

Length of the current best normal found so far.

**<code>_dim_i</code>**: <code>number</code> *(Default: `-1`)*

Current best projection axis so far.

</details>

<details><summary>returns</summary>

**Returns**: <code>list\[number,<a href="#t-Point3D">Point3D</a>]</code>

The best projection axis with it's corresponding best normal.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸\_cap\_layer<a id='f-_cap_layer'></a>

<code>*function* _cap_layer(pts: list\[<a href="#t-Point3D">Point3D</a>,...], pt\_is: list\[number,...]) : list\[<a href="#t-Face">Face</a>,...]</code>

Caps a layer of points.

<details><summary>parameters</summary>

**<code>pts</code>**: <code>list\[<a href="#t-Point3D">Point3D</a>,...]</code>

List of points in layer.

**<code>pt_is</code>**: <code>list\[number,...]</code>

List of indices used to dereference `pts`.

</details>

<details><summary>returns</summary>

**Returns**: <code>list\[<a href="#t-Face">Face</a>,...]</code>

List of faces.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸\_cap\_layers<a id='f-_cap_layers'></a>

<code>*function* _cap_layers(pts\_in\_layer: number, pts3d: list\[<a href="#t-Point3D">Point3D</a>,...], layers: number) : list\[<a href="#t-Face">Face</a>,...]</code>

Generates triangulated faces to cap the first and last point layers.

Assumes `pts3d` is a flat list of points arranged in contiguous layers,
each containing `pts_in_layer` points. There must be `layers + 1` total
point layers. The polygon formed by each cap must be planar and ordered
clockwise when looking from the start layer towards the next layer.  Each
layer of points are all coplanar to the other points in that layer.

This algorithm uses ear clipping to allow for non-convex polygons to be
capped.

<details><summary>parameters</summary>

**<code>pts_in_layer</code>**: <code>number</code>

Number of points in a layer.

**<code>pts3d</code>**: <code>list\[<a href="#t-Point3D">Point3D</a>,...]</code>

Points for all layers.

**<code>layers</code>**: <code>number</code>

Number of layers - 1.

</details>

<details><summary>returns</summary>

**Returns**: <code>list\[<a href="#t-Face">Face</a>,...]</code>

Generated faces.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸is\_skin<a id='f-is_skin'></a>

<code>*function* is_skin()</code>

Checks to see if object is a skin object

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸skin\_new<a id='f-skin_new'></a>

<code>*function* skin_new(pt\_count\_per\_layer: number, layers: number, pts3d: list\[<a href="#t-Point3D">Point3D</a>,...], comment: string, operation: string, wall\_diagonal: list\[bool,...], debug\_axes: list\[list\[<a href="#t-Point3D">Point3D</a>,...],...]) : <a href="#t-skin">skin</a></code>

Create a new skin object.

<details><summary>parameters</summary>

**<code>pt_count_per_layer</code>**: <code>number</code>

number of points per layer (must be â‰¥ 3)

**<code>layers</code>**: <code>number</code>

Number of wall segments (requires `layers + 1` total point layers).

**<code>pts3d</code>**: <code>list\[<a href="#t-Point3D">Point3D</a>,...]</code>

The full list of points arranged in stacked layers.

**<code>comment</code>**: <code>string</code>

Usually a string, this is just a comment for reading and debugging purposes.

**<code>operation</code>**: <code>string</code>

This is used by skin_to_polyhedron() when passing a list of skins.
If a skin has an operation attached, then that skin will have
the operation specified applied to the next element in the list which can
be an object or list of objects.

**<code>wall_diagonal</code>**: <code>list\[bool,...]</code>

This is used to allow changing the diagonal of neighbouring square polygons
on a layer.

E.g.

- `[1]` will have all diagonals go one way.
- `[1,0]` will alternate.
- `[0,1]` will alternate the opposite way to `[1,0]`.
- `[0,0,1]` will have it go one way for 2 consecutive 4 point face, and
  then the other way, and then repeat.

**<code>debug_axes</code>**: <code>list\[list\[<a href="#t-Point3D">Point3D</a>,...],...]</code>

This is a list of point groups.  When rendering, arrows will be drawn from
the first point to each succeeding point in list.  When debugging, call
skin_show_debug_axis().

> âš ï¸ WARNING:
>
> INCOMPLETE and UNTESTED.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-skin">skin</a></code>

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸skin\_extrude<a id='f-skin_extrude'></a>

<code>*function* skin_extrude(birl: number|<a href="#t-range">range</a>|list, end\_i: number|undef, comment: string, operation: string, wall\_diagonal: list\[bool,...], debug\_axes: list\[list\[<a href="#t-Point3D">Point3D</a>,...],...]) : <a href="#t-SkinExtrude">SkinExtrude</a></code>

Possible callchains:

    skin_extrude(birl, end_i, comment, operation, wall_diagonal, debug_axes) (pts_fn) : skin

Generates an extruded point list from a number range, range or list of
indices.

<details><summary>parameters</summary>

**<code>birl</code>**: <code>number|<a href="#t-range">range</a>|list</code>

- If number, start index to check
- If range, indices to check
- If list, indices to check

**<code>end_i</code>**: <code>number|undef</code>

- If birl is a number, then end index to check.  end_i
  could be less than birl if there's nothing to iterate
  over.

**<code>comment</code>**: <code>string</code>

Usually a string, this is just a comment for reading and debugging purposes.

**<code>operation</code>**: <code>string</code>

This is used by skin_to_polyhedron() when passing a list of skins.
If a skin has an operation attached, then that skin will have
the operation specified applied to the next element in the list which can
be an object or list of objects.

**<code>wall_diagonal</code>**: <code>list\[bool,...]</code>

This is used to allow changing the diagonal of neighbouring square polygons
on a layer.

E.g.

- `[1]` will have all diagonals go one way.
- `[1,0]` will alternate.
- `[0,1]` will alternate the opposite way to `[1,0]`.
- `[0,0,1]` will have it go one way for 2 consecutive 4 point face, and
  then the other way, and then repeat.

**<code>debug_axes</code>**: <code>list\[list\[<a href="#t-Point3D">Point3D</a>,...],...]</code>

This is a list of point groups.  When rendering, arrows will be drawn from
the first point to each succeeding point in list.  When debugging, call
skin_show_debug_axis().

> âš ï¸ WARNING:
>
> INCOMPLETE and UNTESTED.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-SkinExtrude">SkinExtrude</a></code>

Lambda that takes a function that returns one layer of points.

Possible callchains:

    SkinExtrude(pts_fn) : skin

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸skin\_create\_faces<a id='f-skin_create_faces'></a>

<code>*function* skin_create_faces(skin: <a href="#t-skin">skin</a>) : list\[<a href="#t-Face">Face</a>]</code>

Generates face layer_i to skin a layered structure, including:

- bottom cap (layer 0)
- top cap (layer = layers)
- side wall faces between adjacent layers

Assumes that points are stored in a flat array, with `pts_in_layer`
points per layer, and layers stored consecutively. Points within each
layer must be ordered clockwise when looking into the object.

<details><summary>parameters</summary>

**<code>skin</code>**: <code><a href="#t-skin">skin</a></code>

The skin object generating the faces from.

</details>

<details><summary>returns</summary>

**Returns**: <code>list\[<a href="#t-Face">Face</a>]</code>

A list of triangle face definitions.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸skin\_transform<a id='f-skin_transform'></a>

<code>*function* skin_transform(obj\_or\_objs: <a href="#t-skin">skin</a>, matrix\_or\_fn: <a href="#t-Matrix3x3">Matrix3x3</a>|<a href="#t-Matrix4x4">Matrix4x4</a>|function) : <a href="#t-skin">skin</a></code>

Performs a transformation on the points stored in the skin object.

<details><summary>parameters</summary>

**<code>obj_or_objs</code>**: <code><a href="#t-skin">skin</a></code>

The skin object where the points are coming from to transform.
TODO: Update doc to state `list[skin]`

**<code>matrix_or_fn</code>**: <code><a href="#t-Matrix3x3">Matrix3x3</a>|<a href="#t-Matrix4x4">Matrix4x4</a>|function</code>

The matrix or function to do the transformation with.  If the
transformation is homogenous, then will convert the points to a homogeneous
basis, perform the transformation and then remove the basis.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-skin">skin</a></code>

A new skin object with the points transformed.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§Šskin\_to\_polyhedron<a id='m-skin_to_polyhedron'></a>

<code>*module* skin_to_polyhedron(obj\_or\_objs: <a href="#t-skin">skin</a>|list\[<a href="#t-skin">skin</a>,...])</code>

Takes the skin object and make it into a polyhedron.  If obj is a list, will
assume all are skin objects and attempt to skin them all.

<details><summary>parameters</summary>

**<code>obj_or_objs</code>**: <code><a href="#t-skin">skin</a>|list\[<a href="#t-skin">skin</a>,...]</code>

The skin object or list of skin objects to make into a polyhedron.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸skin\_add\_layer\_if<a id='f-skin_add_layer_if'></a>

<code>*function* skin_add_layer_if(obj: <a href="#t-skin">skin</a>, add\_layers\_fn: function) : <a href="#t-skin">skin</a></code>

Adds a number of interpolated layers between layers based how many
add_layers_fn(i) returns.

<details><summary>parameters</summary>

**<code>obj</code>**: <code><a href="#t-skin">skin</a></code>

Object to add to.

**<code>add_layers_fn</code>**: <code>function</code>

Callback that will return the first index of a layer, expecting that the
point it refers to or its brethren on that layer to be compared to the
points on the very next layer.

It is guaranteed that there is a next layer of points to compare with.

`i` is the first index of the layer to be analyzed and will return the
number of additional layers to add between the current layer and the next.
Negative numbers are treated as 0.

E.g.

- 0 or less means add no additional layers.
- 1 means add another layer that is half way in between the current and
  next layer.
- 2 means add 2 layers, 1/3 and 2/3 between.
- etc...

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-skin">skin</a></code>

Updated skin.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸skin\_add\_point\_in\_layer<a id='f-skin_add_point_in_layer'></a>

<code>*function* skin_add_point_in_layer()</code>

TODO: Look into this. Not sure what I was attempting here.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§Šskin\_show\_debug\_axes<a id='m-skin_show_debug_axes'></a>

<code>*module* skin_show_debug_axes(obj: <a href="#t-skin">skin</a>, styles: list\[<a href="#t-DebugStyle">DebugStyle</a>])</code>

UNTESTED!
Shows the debug axes to verify where you think things should be.

<details><summary>parameters</summary>

**<code>obj</code>**: <code><a href="#t-skin">skin</a></code>

Object to show debug axes for.

**<code>styles</code>**: <code>list\[<a href="#t-DebugStyle">DebugStyle</a>]</code> *(Default: `\[\["red", 1, .1], \["green"], \["blue"]]`)*

Contains a list of styles that are reused when the number of points in a
debug group exceeds the number of styles.

If a style doesn't contain a colour, alpha or thickness (set as undef),
will go backwards to find one that does and uses that.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸interpolate<a id='f-interpolate'></a>

<code>*function* interpolate()</code>

Interpolates value between v0 and v1.

> ğŸ“Œ TO DO:
>
> This function should be ***deprecated*** and should be replaced with
> [`interpolated_values()`](#f-interpolated_values).

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸skin\_limit<a id='f-skin_limit'></a>

<code>*function* skin_limit(obj: <a href="#t-skin">skin</a>, extract\_order\_value\_fn: function, begin: number, end: number) : <a href="#t-skin">skin</a></code>

INCOMPLETE!
Truncates the beginning, end or both of the extrusion.

<details><summary>parameters</summary>

**<code>obj</code>**: <code><a href="#t-skin">skin</a></code>

Object to remove values before in points.  Value extracted from points MUST
BE monotonically nondecreasing over the points list.

**<code>extract_order_value_fn</code>**: <code>function</code>

This take in a point and returns some value.  This is to allow selection of
a particular axis or length for a given point to compare against value.

**<code>begin</code>**: <code>number</code> *(Default: `extract_order_value_fn(el(obj\[_SKIN_PTS],  0))`)*

The value to compare against the extracted value from a point.

**<code>end</code>**: <code>number</code> *(Default: `extract_order_value_fn(el(obj\[_SKIN_PTS], -1))`)*

The value to compare against the extracted value from a point.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-skin">skin</a></code>

Updated skin object with all of the points before value removed.  If
extracted value is not EXACTLY value, then will linearly interpolated to
cut off EXACTLY at value.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸skin\_verify<a id='f-skin_verify'></a>

<code>*function* skin_verify(obj: <a href="#t-skin">skin</a>, disp\_all\_pts: bool) : string</code>

For debugging, returns a string reporting the stats of a skin object.

Asserts if the object's number of points doesn't correspond to the equation:

  `(layers + 1) * pts_in_layer`

<details><summary>parameters</summary>

**<code>obj</code>**: <code><a href="#t-skin">skin</a></code>

Object to verify.

**<code>disp_all_pts</code>**: <code>bool</code> *(Default: `false`)*

- If false, only returns the first and last points in the list.
- If true, returns all points, with each layer of points on a separate line.

</details>

<details><summary>returns</summary>

**Returns**: <code>string</code>

A prettified/simplified view of points in the object.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸skin\_max\_layer\_distance\_fn<a id='f-skin_max_layer_distance_fn'></a>

<code>*function* skin_max_layer_distance_fn(obj: <a href="#t-skin">skin</a>, max\_diff: number, diff\_fn: function) : function(i: number): number</code>

EXPERIMENTAL:

Returns a function that can be used with skin_add_layer_if() to ensure that
the distance between layers don't exceed some length.

<details><summary>parameters</summary>

**<code>obj</code>**: <code><a href="#t-skin">skin</a></code>

Represents a skin object.

**<code>max_diff</code>**: <code>number</code>

Maximum distance before adding another layer to reduce the distance below
max_diff.

**<code>diff_fn</code>**: <code>function</code> *(Default: `function(p0, p1) p1.x - p0.x`)*

Callback that gives the distance between layers, where `p0` is the first
point of the current layer and `p1` is the first point of the next layer.
Will return a value that states the distance between layers.

</details>

<details><summary>returns</summary>

**Returns**: <code>function(i: number): number</code>

Function that can be used with skin_add_layer_if() and returns the number
of layers to add.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### âš™ï¸skin\_max\_pt\_distance\_fn<a id='f-skin_max_pt_distance_fn'></a>

<code>*function* skin_max_pt_distance_fn()</code>

TODO: Look into this. Not sure what I was attempting here.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

### <i>ğŸ“‘skin types</i><a id='ch-skin-skin_types'></a>

#### ğŸ§©skin<a id='t-skin'></a>

<code>*type* skin = list</code>

Represents a skin object.

<details><summary>slots</summary>
<code><b>_SKIN_PTS_IN_LAYER</b></code>: <code>number</code>

Number of points in a layer.

<code><b>_SKIN_LAYERS</b></code>: <code>number</code>

Number of layers-1.

<code><b>_SKIN_PTS</b></code>: <code>list\[<a href="#t-Point3D">Point3D</a>,...]</code>

A list of points representing the skin object.  This is a flattened list of
points in layer order.  Points are in clockwise order when looking towards
the next layer.

<code><b>_SKIN_DEBUG_AXES</b></code>: <code>...</code>

A set of points that gets transformed with the skin points.

> â„¹ï¸ NOTE:
>
> Rendering is still under development.  **Untested**.

<code><b>_SKIN_COMMENT</b></code>: <code>string</code>

A string to give meaning as to what this object represents.

<code><b>_SKIN_OPERATION</b></code>: <code>...</code>

This is to allow operations between adjacent skin objects in a list.

> â„¹ï¸ NOTE:
>
> Rendering is still under development.  **Untested**.

<code><b>_SKIN_WALL_DIAG</b></code>: <code>list\[bool,...]</code>

When skinning the side walls of the skin, there are two ways to skin a 4
point polygon.  This allows controlling that by specifying the direction.
The first polygon is rendered by what slot 0 states.  The second, by what
slot 1 states.  This continues till the list slots are exhausted, at which
point, it starts at slot 0 again.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©Face<a id='t-_face'></a>

<code>*type* Face = list</code>

<details><summary>slots</summary>
<code><b>0</b></code>: <code>number</code>

This is the first index to the point in the referenced point list.

<code><b>1</b></code>: <code>number</code>

This is the second index to the point in the referenced point list.

<code><b>2</b></code>: <code>number</code>

This is the third index to the point in the referenced point list.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©SkinExtrude<a id='t-_skin_extrude'></a>

<code>*callback* SkinExtrude(pts\_fn: function) : <a href="#t-skin">skin</a></code>

<details><summary>parameters</summary>

**<code>pts_fn</code>**: <code>function</code>

Function that returns a list of points for layer i.  It's fine to have
duplicate points in list as degenerate triangles will be filtered when
calling skin_to_polyhedron.

> â„¹ï¸ NOTE:
>
> Points **MUST** wind in clockwise order when looking into object from
> starting layer towards next layer.
>
> Non-coplanar points on a layer may result in **UB**. Especially on end caps.

</details>

<details><summary>returns</summary>

**Returns**: <code><a href="#t-skin">skin</a></code>

The skin object.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©ColourLst<a id='t-_colour_lst'></a>

<code>*type* ColourLst = list</code>

<details><summary>slots</summary>
<code><b>0</b></code>: <code>number</code>

Red value between `[0,1]`.

<code><b>1</b></code>: <code>number</code>

Green value between `[0,1]`.

<code><b>2</b></code>: <code>number</code>

Blue value between `[0,1]`.

<code><b>3</b></code>: <code>number</code> *(Default: `1.0`)*

Alpha value between `[0,1]`, where 1 means solid and 0 is transparent.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©ColourStr<a id='t-_colour_str'></a>

<code>*type* ColourStr = string</code>

Can be specified in 4 different formats:

- `"#rgb"`
- `"#rgba"`
- `"#rrggbb"`
- `"#rrggbbaa"`

Alpha value between `["0","f"]` or `["00","ff"]`, where `"f"` or `"ff"` means
solid and `"0"` or `"00"` is transparent.

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©ColourName<a id='t-_colour_name'></a>

<code>*type* ColourName = string</code>

The available color names are taken from the World Wide Web consortium's SVG
color list. A chart of the color names is as follows, (note that both
spellings of grey/gray including slategrey/slategray etc are valid):

|                        |                        |                        |
|------------------------|------------------------|------------------------|
| **Purples**            | **Reds**               | **Browns**             |
| - Lavender             | - IndianRed            | - Cornsilk             |
| - Thistle              | - LightCoral           | - BlanchedAlmond       |
| - Plum                 | - Salmon               | - Bisque               |
| - Violet               | - DarkSalmon           | - NavajoWhite          |
| - Orchid               | - LightSalmon          | - Wheat                |
| - Fuchsia              | - Red                  | - BurlyWood            |
| - Magenta              | - Crimson              | - Tan                  |
| - MediumOrchid         | - FireBrick            | - RosyBrown            |
| - MediumPurple         | - DarkRed              | - SandyBrown           |
| - BlueViolet           |                        | - Goldenrod            |
| - DarkViolet           | **Greens**             | - DarkGoldenrod        |
| - DarkOrchid           | - GreenYellow          | - Peru                 |
| - DarkMagenta          | - Chartreuse           | - Chocolate            |
| - Purple               | - LawnGreen            | - SaddleBrown          |
| - Indigo               | - Lime                 | - Sienna               |
| - DarkSlateBlue        | - LimeGreen            | - Brown                |
| - SlateBlue            | - PaleGreen            | - Maroon               |
| - MediumSlateBlue      | - LightGreen           |                        |
|                        | - MediumSpringGreen    | **Whites**             |
| **Pinks**              | - SpringGreen          | - White                |
| - Pink                 | - MediumSeaGreen       | - Snow                 |
| - LightPink            | - SeaGreen             | - Honeydew             |
| - HotPink              | - ForestGreen          | - MintCream            |
| - DeepPink             | - Green                | - Azure                |
| - MediumVioletRed      | - DarkGreen            | - AliceBlue            |
| - PaleVioletRed        | - YellowGreen          | - GhostWhite           |
|                        | - OliveDrab            | - WhiteSmoke           |
| **Blues**              | - Olive                | - Seashell             |
| - Aqua                 | - DarkOliveGreen       | - Beige                |
| - Cyan                 | - MediumAquamarine     | - OldLace              |
| - LightCyan            | - DarkSeaGreen         | - FloralWhite          |
| - PaleTurquoise        | - LightSeaGreen        | - Ivory                |
| - Aquamarine           | - DarkCyan             | - AntiqueWhite         |
| - Turquoise            | - Teal                 | - Linen                |
| - MediumTurquoise      |                        | - LavenderBlush        |
| - DarkTurquoise        | **Oranges**            | - MistyRose            |
| - CadetBlue            | - LightSalmon          |                        |
| - SteelBlue            | - Coral                | **Grays**              |
| - LightSteelBlue       | - Tomato               | - Gainsboro            |
| - PowderBlue           | - OrangeRed            | - LightGrey            |
| - LightBlue            | - DarkOrange           | - Silver               |
| - SkyBlue              | - Orange               | - DarkGray             |
| - LightSkyBlue         |                        | - Gray                 |
| - DeepSkyBlue          | **Yellows**            | - DimGray              |
| - DodgerBlue           | - Gold                 | - LightSlateGray       |
| - CornflowerBlue       | - Yellow               | - SlateGray            |
| - RoyalBlue            | - LightYellow          | - DarkSlateGray        |
| - Blue                 | - LemonChiffon         | - Black                |
| - MediumBlue           | - LightGoldenrodYellow |                        |
| - DarkBlue             | - PapayaWhip           |                        |
| - Navy                 | - Moccasin             |                        |
| - MidnightBlue         | - PeachPuff            |                        |
|                        | - PaleGoldenrod        |                        |
|                        | - Khaki                |                        |
|                        | - DarkKhaki            |                        |

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

#### ğŸ§©DebugStyle<a id='t-_debug_style'></a>

<code>*type* DebugStyle = list</code>

Style for a debug vector.

<details><summary>slots</summary>
<code><b>0</b></code>: <code><a href="#t-ColourStr">ColourStr</a>|<a href="#t-ColourLst">ColourLst</a>|<a href="#t-ColourName">ColourName</a></code>

- If a string, then the name of a colour, or the hex representation of one.
- If a number, the value of the hex value.

<code><b>1</b></code>: <code>number</code>

Alpha value between `[0, 1]`.

> ğŸ“Œ TO DO:
>
> Need to verify if undef is allowed, otherwise this will always take
> precedence, even if alpha is specified in the ColourLst or ColourStr
> style specifications.

<code><b>2</b></code>: <code>number</code>

Thickness that is passed to [`arrow()`](#m-arrow) module.

</details>

<p align="right">[<a href="#api-table-of-contents">TOC</a>]</p><hr/>

