/**
 * ## transform
 *
 * ### Purpose
 *
 * This library is for matrix math for a variety of things.
 */
use <any_all>
use <helpers>
use <param_check>

/** ### Generate Matrices for Vector Transforms */

/**
 * @typedef {list[list[number,...],...]} Matrix
 *
 * Placeholder for NxM matrix.
 */

/**
 * Transpose of a matrix.
 *
 * - Matrix (list of equal-length rows) → transposed matrix
 *
 * > NOTE:
 * >
 * > There is no need to transpose a vector to a column vector.  When OpenSCAD
 * > sees M \* V or V \* M, the vector V is automatically treated as a column or
 * > row vector as appropriate.
 *
 * @param {Matrix} A
 *   The matrix to transpose.
 *
 * @returns {Matrix}
 *   The transpose of matrix A.
 */
function transpose(A) =
  assert(is_list(A), "transpose: input must be a list")
  len(A) == 0 ? [] :
  assert(is_list(A[0]), "A must be a matrix")
  let(
    row_lens = [for (r = A) len(r)],
    nc = row_lens[0]
  )
  assert(min(row_lens) == nc && max(row_lens) == nc,
          "transpose: non-rectangular matrix")
  [ for (j = [0 : nc - 1])
    [ for (i = [0 : len(A) - 1]) A[i][j] ]
  ]
;

/**
 * @typedef {list} Point2D
 *
 * A 2D point.
 *
 * @slot {number} 0
 *   This is the dimension `0` or x dimension of the point.  Can also be accessed
 *   by property `.x`.
 * @slot {number} 1
 *   This is the dimension `1` or y dimension of the point.  Can also be accessed
 *   by property `.y`.
 */

/**
 * @typedef {list} Point3D
 *
 * A 3D point.
 *
 * @slot {number} 0
 *   This is the dimension `0` or x dimension of the point.  Can also be accessed
 *   by property `.x`.
 * @slot {number} 1
 *   This is the dimension `1` or y dimension of the point.  Can also be accessed
 *   by property `.y`.
 * @slot {number} 2
 *   This is the dimension `2` or z dimension of the point.  Can also be accessed
 *   by property `.z`.
 */

/**
 * @typedef {list} Point
 *
 * An ND point.
 *
 * @slot {number} 0
 *   This is the dimension `0` or x dimension of the point.  Can also be accessed
 *   by property `.x`.
 * @slot {number} 1
 *   This is the dimension `1` or y dimension of the point.  Can also be accessed
 *   by property `.y`.
 * @slot {number} 2
 *   This is the dimension `2` or z dimension of the point.  Can also be accessed
 *   by property `.z`.
 * @slot {number} [n]
 *   This is the dimension `n` dimension of the point.
 */

/**
 * Convert points to homogeneous coordinates.
 *
 * Each point is padded with zeros up to dimension n-1, then a trailing 1 is
 * appended.
 *
 * @param {list[Point,...]} pts
 *   List of points.  Each point must have dimension < n.
 * @param {number} n
 *   Target homogeneous dimension.  Must be greater than the dimension of every
 *   point in pts.
 *
 * @returns {list[Point,...]}
 *   List of n-dimensional points with homogeneous coordinate 1 at index n-1.
 */
function homogenise(pts, n=4) =
  let (result =
  [ for (i = [0 : len(pts) - 1]) // iterate over each point in list of points
    assert(len(pts[i]) < n, "Points must have fewer dimensions than n.")
    [ for (j = [0 : n - 1]) // iterate over each dimension in each point
      j < len(pts[i])
      ? pts[i][j]
      : j < n - 1 ? 0 : 1
    ]
  ])
  // echo("homogenise: ", result)
  result
;
// echo("test homogenise:", homogenise([[2,3,4]], 4));

/**
 * Dehomogenises a list of homogeneous points to Euclidean points.
 *
 * Each input point must have at least n+1 coordinates.  The homogeneous divisor w is the
 * last coordinate of the point (index len(pt)-1).  This function returns the first n
 * coordinates divided by w, and discards all remaining coordinates.
 *
 * This is the companion to homogenise() when homogenise() places w at the last coordinate.  A
 * typical pipeline is: homogenise points to match an M×M transform, multiply, then project
 * back to N dimensions with dehomogenise(..., N).
 *
 * Preconditions (enforced by asserts):
 *
 * - Every point pt satisfies len(pt) > n.  (There must be a last coordinate to use as w.)
 * - w != 0.  (Homogeneous projection is undefined for w == 0.)
 *
 * @param {list[Point,...]} pts
 *   List of homogeneous points.
 * @param {number} [n=3]
 *   Number of Euclidean coordinates to return per point.
 *
 * @returns {list[Point,...]}
 *   List of n-dimensional Euclidean points.
 */
function dehomogenise(pts, n=3) =
  [ for (i = [0 : len(pts) - 1]) // iterate over each point in list of points
      let (
        homogeneous =
          assert(len(pts[i]) > n, "Points must have the more dimensions than n.")
          pts[i][len(pts[i])-1]
      )
      assert(homogeneous != 0, "Homogeneous dimension can't have a value of 0.")
      [ for (j = [0 : n - 1]) // iterate over each dimension in each point
        pts[i][j] / homogeneous
      ]
  ]
;
// echo("test dehomogenise:", dehomogenise(homogenise([[2,3,4]], 4), 4));

/**
 * Embed a non-homogeneous square transform into a larger homogeneous matrix.
 *
 * Returns a **homogeneous column-vector** matrix H (n×n).  A is placed in the
 * top-left block.
 *
 * Use:
 *
 * - If H is used as a transform matrix, apply it like any other homogeneous
 *   column-vector matrix:
 *   - Single point p: treat p as homogeneous when multiplying.
 *   - Point list Ps: use transform(Ps, transpose(H)).
 *
 * @param {Matrix} A
 *   Square M×M transform matrix.
 * @param {number} n
 *   Target homogeneous dimension.  Must satisfy M < n.
 *
 * @returns {Matrix}
 *   Homogeneous matrix H (n×n) with A in the top-left block and identity
 *   elsewhere.
 */
function homogenise_transform(A, n=4) =
  let(
    row_lens = [for (r = A) len(r)],
    nc = row_lens[0]
  )
  assert(min(row_lens) == nc && max(row_lens) == nc && len(A) == nc,
          "homogenise_transform: A must be square")
  assert(nc < n, "Number of columns and rows must be less than n.")
  [ for (i = [0 : n - 1])
    i < nc
    ? [ for (j = [0 : n - 1])
      j < nc
      ? A[i][j]
      : i == j ? 1 : 0
    ]
    : [ for (j = [0 : n - 1])
      i == j ? 1 : 0
    ]
  ]
;

// ROTATION MATRIX
// --- Rotation matrices (3D) -----------------------------------------------

/**
 * @typedef {list} Vector2D
 *
 * A bound 2D vector, which starts from the origin.
 *
 * @slot {number} 0
 *   This is the dimension `0` or x dimension of the vector.  Can also be
 *   accessed by property `.x`.
 * @slot {number} 1
 *   This is the dimension `1` or y dimension of the vector.  Can also be
 *   accessed by property `.y`.
 */

/**
 * @typedef {list} Vector3D
 *
 * A bound 3D vector, which starts from the origin.
 *
 * @slot {number} 0
 *   This is the dimension `0` or x dimension of the vector.  Can also be
 *   accessed by property `.x`.
 * @slot {number} 1
 *   This is the dimension `1` or y dimension of the vector.  Can also be
 *   accessed by property `.y`.
 * @slot {number} 2
 *   This is the dimension `2` or z dimension of the vector.  Can also be
 *   accessed by property `.z`.
 */

/**
 * @typedef {list} Vector
 *
 * A bound ND vector, which starts from the origin.
 *
 * @slot {number} 0
 *   This is the dimension `0` or x dimension of the vector.  Can also be
 *   accessed by property `.x`.
 * @slot {number} 1
 *   This is the dimension `1` or y dimension of the vector.  Can also be
 *   accessed by property `.y`.
 * @slot {number} 2
 *   This is the dimension `2` or z dimension of the vector.  Can also be
 *   accessed by property `.z`.
 * @slot {number} [n]
 *   This is the dimension `n` dimension of the vector.
 */

/**
 * @typedef {list[Point2D,Point2D]} BVector2D
 *
 * A bound 2D vector, which starts from point in slot 0 and goes to point in
 * slot 1.
 *
 * @slot {Point2D} 0
 *   This is the starting point for this bound vector.
 * @slot {Point2D} 1
 *   This is the ending point for this bound vector.
 */

/**
 * @typedef {list[Point3D,Point3D]} BVector3D
 *
 * A bound 3D vector, which starts from point in slot 0 and goes to point in
 * slot 1.
 *
 * @slot {Point3D} 0
 *   This is the starting point for this bound vector.
 * @slot {Point3D} 1
 *   This is the ending point for this bound vector.
 */

/**
 * @typedef {list[Point,Point]} BVector
 *
 * A bound ND vector, which starts from point in slot 0 and goes to point in
 * slot 1.
 *
 * @slot {Point} 0
 *   This is the starting point for this bound vector.
 * @slot {Point} 1
 *   This is the ending point for this bound vector.
 */

/**
 * Rotation matrix about the X axis.
 *
 * Returns a **non-homogeneous column-vector** rotation matrix M (3×3).
 *
 * Use:
 *
 * - Single Point    p:  p' = M * p
 * - List of Points Ps:  Ps' = Ps * transpose(M)
 *
 * @param {number} a
 *   Rotation angle in degrees.
 *
 * @returns {Matrix}
 *   Column-vector rotation matrix M.
 */
function rot_x(a) =
  [
    [ 1,       0,        0 ],
    [ 0,  cos(a),  -sin(a) ],
    [ 0,  sin(a),   cos(a) ]
  ]
;

/**
 * Rotation matrix about the Y axis.
 *
 * Returns a **non-homogeneous column-vector** rotation matrix M (3×3).
 *
 * Use:
 *
 * - Single Point    p:  p' = M * p
 * - List of Points Ps:  Ps' = Ps * transpose(M)
 *
 * @param {number} a
 *   Rotation angle in degrees.
 *
 * @returns {Matrix}
 *   Column-vector rotation matrix M.
 */
function rot_y(a) =
  [
    [  cos(a), 0,  sin(a) ],
    [       0, 1,       0 ],
    [ -sin(a), 0,  cos(a) ]
  ]
;

/**
 * Rotation matrix about the Z axis.
 *
 * Returns a **non-homogeneous column-vector** rotation matrix M (3×3).
 *
 * Use:
 *
 * - Single Point    p:  p' = M * p
 * - List of Points Ps:  Ps' = Ps * transpose(M)
 *
 * @param {number} a
 *   Rotation angle in degrees.
 *
 * @returns {Matrix}
 *   Column-vector rotation matrix M.
 */
function rot_z(a) =
  [
    [  cos(a), -sin(a), 0 ],
    [  sin(a),  cos(a), 0 ],
    [       0,       0, 1 ]
  ]
;

/**
 * Checks if `o` has the shape of a vector of `dim` `number`s.
 *
 * @param {any} o
 *   Object to test.
 * @param {number} [dim=3]
 *   Number of dimensions the vector should represent.
 *
 * @returns {bool}
 *   True if has the shape of a point of `dim` `number`s.
 */
function is_point(o, dim=3) =
  is_list(o) && len(o) == dim && all(0, len(o)-1)(function(i) is_num(o[i]))
;

/**
 * Checks if `o` has the shape of a free vector of `dim` `number`s.
 *
 * @param {any} o
 *   Object to test.
 * @param {number} [dim=3]
 *   Number of dimensions the vector should represent.
 *
 * @returns {bool}
 *   True if has the shape of a free vector of `dim` `number`s.
 */
function is_vector(o, dim=3) =
  is_list(o) && len(o) == dim && all(0, len(o)-1)(function(i) is_num(o[i]))
;

/**
 * Checks if `o` has the shape of 2 bound points of `dim` `number`s.  This
 * represents the starting and ending points of a bound vector.
 *
 * @param {any} o
 *   Object to test.
 * @param {number} [dim=3]
 *   Number of dimensions the vector should represent.
 *
 * @returns {bool}
 *   True if has the shape of 2 bound points of `dim` `number`s.
 */
function is_bound_vector(o, dim=3) =
  is_list(o) && len(o) == 2 && is_point(o[0], dim) && is_point(o[1], dim)
;

/**
 * Rotation matrix about an arbitrary axis.
 *
 * Returns a **non-homogeneous column-vector** rotation matrix M (3×3) that
 * rotates around the specified vector 'axis' rooted in the origin of the
 * coordinate system.
 *
 * Use:
 *
 * - Single Point    p:  p' = M * p
 * - List of Points Ps:  Ps' = Ps * transpose(M)
 *
 * @param {number} angle
 *   Rotation angle in degrees.
 * @param {Vector3D} axis
 *   Rotation axis vector (must be non-zero).
 *
 * @returns {Matrix}
 *   Column-vector rotation matrix M.
 */
function rot_axis(angle, axis) =
  let(
    n = norm(axis)
  )
  assert(n > 0, "axis vector must be non-zero")
  let(
    ux = axis[0]/n, uy = axis[1]/n, uz = axis[2]/n,
    c = cos(angle), s = sin(angle), t = 1 - c,
    rot_matrix =
      [
        [ t*ux*ux + c,     t*ux*uy - s*uz, t*ux*uz + s*uy ],
        [ t*uy*ux + s*uz,  t*uy*uy + c,    t*uy*uz - s*ux ],
        [ t*uz*ux - s*uy,  t*uz*uy + s*ux, t*uz*uz + c    ]
      ]
  )
  rot_matrix
;

/**
 * Rotation matrix that parallels OpenSCAD's rotate() module, with the
 * additional feature that it can also take a `BVector3D` for `v`, meaning that
 * it can rotate about the point stipulated by the point in slot 0 of the
 * BVector.
 *
 * If `v` is a `Vector3D`, returns a **non-homogeneous column-vector** rotation
 * matrix M (3×3) that rotates around the specified vector 'axis' rooted in the
 * origin of the coordinate system.
 *
 * If `v` is a `BVector3D`, returns a **homogeneous column-vector** rotation
 * matrix M (4x4) that rotates around the specified vector 'axis' (`v[1]-v[0]`)
 * around point `v[0]`.
 *
 * To not have to worry about the matrix size, it's recommended that you use the
 * [`transform()`](#f-transform) API.
 *
 * Use if `p` or elements of `Ps` are homogeneous/non-homogeneous as `M` is:
 *
 * - Single Point    p:  p' = M * p
 * - List of Points Ps:  Ps' = Ps * transpose(M)
 * or if don't want to worry about having to use
 * [`homogenise()`](#f-homogenise)/[`dehomogenise()`](#f-dehomogenise), use
 * [`transform()`](#f-transform) API:
 * - Single Point    p:  `p' = transform([p], transpose(M))`
 * - List of Points Ps:  `Ps' = transform(Ps, transpose(M))`
 *
 * @param {(number|list[number,number,number])} a
 *   - If `number` and `v` is not supplied: rotate CCW around Z.
 *   - If `number` and `v` is a `Vector3D`: rotate CCW around axis defined by
 *     `v`.
 *   - If `list` `[rx,ry,rz]`: apply rotations about X then Y then Z (degrees).
 *     (v is ignored.)
 * @param {(Vector3D|BVector3D)} [v]
 *   - If `a` is a number
 *     - If `v` is a specified Vector3D, then this is the axis vector.
 *     - If `v` is a specified BVector3D, then use direction for the axis vector
 *       and `v[0]` as the rotation point.
 *     - Otherwise axis vector is Z.
 *
 * @returns {Matrix}
 *   Column-vector rotation matrix M.
 *
 *   - If `v` is a `BVector3D`, then returns a homogenised transform matrix
 *     (4x4).
 *   - If `v` is a `Vector3D`, then returns a non-homogenised transform matrix
 *     (3x3).
 */
function rotate(a, v=undef) =
  is_num(a)
  ? is_undef(v)
    ? rot_z(a)
    : is_vector(v)
      ? rot_axis(a, v)
      : is_bound_vector(v)
        ? translate(v[0]) *
          homogenise_transform(rot_axis(a, v[1]-v[0])) *
          translate(-v[0])
        : assert(false, "rotate(angle, axis): axis must be a Vector3D") undef
  : is_list(a) && len(a) == 3
      ? rot_z(a[2]) * rot_y(a[1]) * rot_x(a[0])   // Rz * Ry * Rx
      : assert(false, "rotate([rx,ry,rz]): need 3 components") undef
;

// echo(str("rotate test: ", [[1, 0, 0] ,[1, 0, 0]] * transpose(rotate([0,0,45]))));
// echo(str("rotate test: ", rotate([0,0,45]) * [1, 0, 0]));

/**
 * Translation matrix that parallels OpenSCAD's translate() module.
 *
 * Returns a **homogeneous column-vector** translation matrix T (4×4).
 *
 * Use:
 *
 * - Single 3D point `p`: `p` must be as homogeneous (`[x,y,z,1]`) when multiplying.
 * - Point list `Ps` (3D): use `transform(Ps, transpose(T))`.
 *
 * @param {list[number]} v
 *   Translation vector.
 *
 * @returns {Matrix}
 *   Homogeneous column-vector translation matrix T.
 */
function translate(v) =
  [
    [ 1, 0, 0, v[0] ],
    [ 0, 1, 0, v[1] ],
    [ 0, 0, 1, v[2] ],
    [ 0, 0, 0,    1 ]
  ]
;

/**
 * Scale matrix that parallels OpenSCAD's scale() module.
 *
 * Returns a **non-homogeneous column-vector** scaling matrix S (3×3).
 *
 * Use:
 *
 * - Single point p (3-vector):  p' = S * p
 * - Point list Ps:              Ps' = Ps * transpose(S)
 *
 * @param {list[number]} v
 *   Per-axis scale factors.
 *
 * @returns {Matrix}
 *   Column-vector scaling matrix S.
 */
function scale(v) =
  [
    [ v[0],    0,    0 ],
    [    0, v[1],    0 ],
    [    0,    0, v[2] ]
  ]
;
// echo(str("translate test 1: ", translate([1.5, 2.5, 3.5]) * [1,1,1,1]));
// echo(str("translate test 2: ", homogenise([[1,1,1]], 4) * transpose(translate([1.5, 2.5, 3.5]))));

/**
 * Transform a list of points using either a matrix or a point-mapping function.
 *
 * Points in pts are treated as **row vectors** (each point is a 1×d row).
 *
 * - If `matrix_or_fn` is a `Matrix`, and since all matrices generated by this
 *   library are column-vector matrices `M`, you must pass `transpose(M)` here.
 *
 * - If matrix_or_fn is a homogeneous matrix (e.g.  4×4 for 3D points), this
 *   function homogenises pts, multiplies, then dehomogenises back to the
 *   original point dimension.
 *
 * @param {list[Point]} pts
 *   List of points (rows).  All points must have the same dimension.
 * @param {(Matrix|function(pt: Point): Point)} matrix_or_fn
 *   Either:
 *
 *   - a matrix in row-vector orientation (typically `transpose(M)`), or
 *   - a function that maps a single point to a transformed point.
 *
 * @returns {list[Point]}
 *   Transformed points.
 */
function transform(pts, matrix_or_fn) =
  is_function(matrix_or_fn)
  ? [ for (pt = pts) matrix_or_fn(pt) ]
  : len(pts[0]) < len(matrix_or_fn)
    ? dehomogenise(homogenise(pts, len(matrix_or_fn)) * matrix_or_fn, len(pts[0]))
    : // echo(len(pts[0]), len(matrix_or_fn), type_structure(pts), type_structure(matrix_or_fn))
      pts * matrix_or_fn
;

/**
 * > TTA:
 * >
 * > Going to change this.  I think I want it like:
 * >     reorient(vector_space_1, vector_space_2, scale_to_vectors)
 * > Where vector_space_* is a start point, followed by 1-3 end points and
 * > scale_to_vectors could be bool or list[bool,...] indicating if to scale all
 * > or just some.
 *
 * Returns a homogeneous column-vector transform matrix T (4×4) that maps one
 * line segment to another.
 *
 * Use:
 *
 * - Single 3D point `p`: `p` must be as homogeneous (`[x,y,z,1]`) when multiplying.
 * - Point list `Ps` (3D): use `transform(Ps, transpose(T))`.
 *
 * @param {(list[Point3D,Point3D]|list[Point3D,Point3D,Point3D]|list[Point3D,Point3D,Point3D,Point3D])} start_line_seg
 *   The source line segment: `[P0, P1]`.
 * @param {(list[Point3D,Point3D]|list[Point3D,Point3D,Point3D]|list[Point3D,Point3D,Point3D,Point3D])} end_line_seg
 *   The target line segment: `[Q0, Q1]`.
 * @param {bool} [scale_to_vectors=false]
 *   Only affects the 2-point overload.  If true, also apply uniform scaling by
 *   `|Q1-Q0|/|P1-P0|`.
 *
 * @returns {Matrix}
 *   Homogeneous column-vector transform matrix T.
 *
 *   - if start/end line_seg consist of 2 points, then
 *     - Rigid reorientation.  If scale_to_vectors is true, also apply uniform
 *       scaling.
 *   - if start/end line_seg consist of 3 points, then
 *     - Reorientation that maps one 2D basis (plus translation) to another.
 *   - otherwise start/end line_seg consist of 4 points
 *     - Reorientation that maps one 3D basis (plus translation) to another.
 */
function _reorient(start_line_seg, end_line_seg, scale_to_vectors = false) =
  let(nA = len(start_line_seg), nB = len(end_line_seg))
  assert((nA == 2 || nA == 3 || nA == 4) && nA == nB,
         "reorient: both inputs must have length 2, 3, or 4, and be the same length.")
  // ---------- 2-point overload: align direction + uniform scale ----------
  (nA == 2)
  ? (
      let(
        P0 = start_line_seg[0],  P1 = start_line_seg[1],
        Q0 = end_line_seg[0],    Q1 = end_line_seg[1],
        v  = P1 - P0,            w  = Q1 - Q0,
        lv = norm(v),            lw = norm(w)
      )
      assert(lv > 0 && lw > 0, "reorient(2pt): segment lengths must be > 0")
      let(
        uhat   = v / lv,
        what   = w / lw,
        axis   = cross(uhat, what),
        axn    = norm(axis),
        d_raw  = uhat * what,
        c      = clamp(d_raw, -1, 1),
        thetaD = acos(c),  // degrees
        R3 =
          (axn < 1e-12)
          ? (c > 0
             ? identity(3)
             : let(tmp = (abs(uhat[0]) < 0.9) ? [1,0,0] : [0,1,0],
                   n2  = cross(uhat, tmp), n2n = n2 / norm(n2))
               rot_axis(180, n2n))
          : rot_axis(thetaD, axis / axn),
        s   = lw / lv,
        L3  = scale_to_vectors ? R3 * scale([s, s, s]) : R3,
        T1  = translate(-P0),
        T2  = translate(Q0)
      )
      T2 * homogenise_transform(L3) * T1
    )
  // ---------- 3-point overload: planar frame map ----------
  : (nA == 3)
    ? (
        let(
          P0 = start_line_seg[0],  P1 = start_line_seg[1],  P2 = start_line_seg[2],
          Q0 = end_line_seg[0],    Q1 = end_line_seg[1],    Q2 = end_line_seg[2],
          v1 = P1 - P0,            v2 = P2 - P0,
          w1 = Q1 - Q0,            w2 = Q2 - Q0
        )
        assert(norm(v1) > 0 && norm(v2) > 0, "reorient(3pt): start axes must be non-zero")
        assert(norm(w1) > 0 && norm(w2) > 0, "reorient(3pt): end axes must be non-zero")
        let(
          nS = cross(v1, v2), nSn = norm(nS),
          nE = cross(w1, w2), nEn = norm(nE)
        )
        assert(nSn > 1e-12, "reorient(3pt): start points are collinear")
        assert(nEn > 1e-12, "reorient(3pt): end points are collinear")
        let(
          BS = [
            [ v1[0],  v2[0],  nS[0]/nSn ],
            [ v1[1],  v2[1],  nS[1]/nSn ],
            [ v1[2],  v2[2],  nS[2]/nSn ]
          ],
          BE = [
            [ w1[0],  w2[0],  nE[0]/nEn ],
            [ w1[1],  w2[1],  nE[1]/nEn ],
            [ w1[2],  w2[2],  nE[2]/nEn ]
          ],
          L3 = BE * invert(BS),
          T1 = translate(-P0),
          T2 = translate(Q0)
        )
        T2 * homogenise_transform(L3) * T1
      )
    // ---------- 4-point overload: full 3D ("cubic") frame map ----------
    : (
        let(
          P0 = start_line_seg[0],  P1 = start_line_seg[1],
          P2 = start_line_seg[2],  P3 = start_line_seg[3],
          Q0 = end_line_seg[0],    Q1 = end_line_seg[1],
          Q2 = end_line_seg[2],    Q3 = end_line_seg[3],
          v1 = P1 - P0,            v2 = P2 - P0,            v3 = P3 - P0,
          w1 = Q1 - Q0,            w2 = Q2 - Q0,            w3 = Q3 - Q0,
          lv1 = norm(v1),          lv2 = norm(v2),          lv3 = norm(v3),
          lw1 = norm(w1),          lw2 = norm(w2),          lw3 = norm(w3)
        )
        assert(lv1 > 0 && lv2 > 0 && lv3 > 0, "reorient(4pt): start axes must be non-zero")
        assert(lw1 > 0 && lw2 > 0 && lw3 > 0, "reorient(4pt): end axes must be non-zero")
        let(
          detS = v1 * cross(v2, v3),
          detE = w1 * cross(w2, w3)
        )
        assert(abs(detS) > 1e-12 * lv1 * lv2 * lv3, "reorient(4pt): start frame is singular")
        assert(abs(detE) > 1e-12 * lw1 * lw2 * lw3, "reorient(4pt): end frame is singular")
        let(
          BS = [
            [ v1[0],  v2[0],  v3[0] ],
            [ v1[1],  v2[1],  v3[1] ],
            [ v1[2],  v2[2],  v3[2] ]
          ],
          BE = [
            [ w1[0],  w2[0],  w3[0] ],
            [ w1[1],  w2[1],  w3[1] ],
            [ w1[2],  w2[2],  w3[2] ]
          ],
          L3 = BE * invert(BS),  // sends v1→w1, v2→w2, v3→w3
          T1 = translate(-P0),
          T2 = translate(Q0)
        )
        T2 * homogenise_transform(L3) * T1
      )
;

////////////////////////////////////////////////////////////////////////////////
// INVERT MATRIX

/** ### Matrix Math */
/**
 * Invert a square matrix using Gauss-Jordan elimination with partial pivoting.
 *
 * @param {Matrix} A
 *   Non-empty square numeric matrix (list of equal-length lists).
 * @param {number} [eps=1e-12]
 *   Pivot tolerance.  Must be > 0.
 *
 * @returns {Matrix}
 *   The inverse matrix `A⁻¹`.
 *
 *   Assertion failure if `A` is not a valid square numeric matrix or if any
 *   pivot has `|pivot| < eps`.
 *
 *   Example
 *
 *       invert([[4,7],[2,6]])  // -> [[0.6,-0.7],[-0.2,0.4]]
 */
function invert(A, eps = 1e-12) =
  assert(_is_square_matrix(A), "invert: A must be a non-empty square matrix")
  assert(_all_numeric(A), "invert: all entries in A must be numeric")
  let(
    n   = len(A),
    aug = augment(A, identity(n))    // [A | I]
  )
  let(
    raug = row_reduction(aug, 0, n, eps)  // reduce to [I | A⁻¹]
  )
  _right_half(raug, n);

/**
 * Performs Gauss-Jordan row reduction with partial pivoting on an augmented
 * matrix.
 *
 * @param {Matrix} aug
 *   Augmented matrix of shape `n×(2n)`, typically `[A | I]`.
 * @param {number} k
 *   Current column index (0-based).  External callers pass 0.
 * @param {number} n
 *   Matrix order.  Must equal the row count of aug.
 * @param {number} eps
 *   Pivot tolerance.  Must be > 0.
 *
 * @returns {Matrix}
 *   The reduced augmented matrix.  For a non-singular A this is `[I | A⁻¹]`.
 *
 *   Assertion failure if `|pivot| < eps` at any step.
 */
function row_reduction(aug, k, n, eps) =
  (k >= n) ? aug
  : let(
      r     = _argmax_abs_col(aug, k, k),
      aug1  = (r == k) ? aug : _swap_rows(aug, k, r),
      piv   = aug1[k][k]
    )
    assert(abs(piv) >= eps,
           str("invert: singular/ill-conditioned at column ", k, " (|pivot| < eps)"))
    let(
      // Normalise pivot row to make pivot = 1
      rowk  = [for (j = [0 : 2*n - 1]) aug1[k][j] / piv],
      aug2  = [for (i = [0 : n - 1]) (i == k) ? rowk : aug1[i]],
      // Eliminate column k in all other rows
      aug3  = [for (i = [0 : n - 1])
                (i == k) ? aug2[i]
                         : let(f = aug2[i][k])
                           [for (j = [0 : 2*n - 1]) aug2[i][j] - f * rowk[j]]
              ]
    )
    row_reduction(aug3, k + 1, n, eps);

// --- Helpers ---

/**
 * Creates an n×n identity matrix.
 *
 * @param {number} n
 *   Matrix order.  Must be > 0.
 *
 * @returns {Matrix}
 *   The identity matrix of order n.
 */
function identity(n) =
  let ( _ = verify_vpos(n) )
  [for (i = [0 : n - 1]) [for (j = [0 : n - 1]) (i == j) ? 1 : 0]];

/**
 * Horizontally concatenates two matrices with the same row count.
 *
 * @param {Matrix} A
 *   Left matrix with r rows.
 * @param {Matrix} B
 *   Right matrix with r rows.
 *
 * @returns {Matrix}
 *   The augmented matrix `[A | B]`.
 *
 *   Assertion failure if A and B do not have the same non-zero row count.
 */
function augment(A, B) =
  assert(len(A) == len(B) && len(A) > 0,
         "augment: A and B must have same row count and be non-empty")
  [for (i = [0 : len(A) - 1]) concat(A[i], B[i])];

/**
 * Extracts the right half (columns `n..2n-1`) of an `n × (2n)` augmented matrix.
 *
 * @param {Matrix} aug
 *   Augmented matrix of shape n×(2n).
 * @param {number} n
 *   Left block width and row count.
 *
 * @returns {Matrix}
 *   The right n×n block.
 */
function _right_half(aug, n) =
  [for (i = [0 : n - 1]) [for (j = [n : 2*n - 1]) aug[i][j]]];

/**
 * Returns a copy of matrix M with rows i and j swapped.
 *
 * @param {Matrix} M
 *   Input matrix.
 * @param {number} i
 *   First row index (0-based).
 * @param {number} j
 *   Second row index (0-based).
 *
 * @returns {Matrix}
 *   Matrix with rows i and j exchanged.
 */
function _swap_rows(M, i, j) =
  [for (r = [0 : len(M) - 1]) (r == i) ? M[j] : (r == j) ? M[i] : M[r]];

/**
 * Finds the row index `r ∈ [start..n-1]` that maximises `|aug[r][col]|`.
 * Ties resolve to the first occurrence.
 *
 * @param {Matrix} aug
 *   Matrix to scan.
 * @param {number} col
 *   Column index to examine.
 * @param {number} start
 *   First row index to consider (inclusive).
 *
 * @returns {number}
 *   Row index of the maximal absolute entry in the given column slice.
 */
function _argmax_abs_col(aug, col, start) =
  let(
    n    = len(aug),
    mags = [for (r = [start : n - 1]) abs(aug[r][col])],
    mval = max(mags),
    idx0 = search(mval, mags)[0]
  ) start + idx0;

/**
 * Tests whether M is a rectangular list-of-lists with consistent row length.
 *
 * @param {any} M
 *   Candidate matrix.
 *
 * @returns {bool}
 *   true if M is a non-empty list of rows with equal positive length.
 */
function _is_rect_matrix(M) =
  is_list(M) && (len(M) > 0) && is_list(M[0]) &&
  (let(c = len(M[0]))
     (c > 0) &&
     (min([for (row = M) (is_list(row) && len(row) == c) ? 1 : 0]) == 1));

/**
 * Tests whether M is a square matrix (rectangular and rows == columns).
 *
 * @param {any} M
 *   Candidate matrix.
 *
 * @returns {bool}
 *   true if M is rectangular and `len(M) == len(M[0])`.
 */
function _is_square_matrix(M) =
  _is_rect_matrix(M) && (len(M) == len(M[0]));

/**
 * Tests whether all entries of M are numeric.
 *
 * @param {any} M
 *   Candidate matrix.
 *
 * @returns {bool}
 *   true if every element in every row is numeric.
 */
function _all_numeric(M) =
  (min([for (row = M) min([for (x = row) is_num(x) ? 1 : 0])]) == 1);

