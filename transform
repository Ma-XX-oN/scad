/**
 * ## transform
 *
 * ### How to Import
 *
 *     use <transform>
 *
 * ### Purpose
 *
 * This library is for matrix math for a variety of things.
 */
use <any_all>
use <helpers>
use <param_check>

/** ### Generate Matrices for Vector Transforms */

/**
 * @typedef {list[list[number,...],...]} Matrix
 *
 * Placeholder for NxM matrix.
 */

/**
 * @typedef {list[number,number,number]} Row3
 *
 * A row of 3 numbers used in a Matrix3x3 type.
 */
 
/**
 * @typedef {list[number,number,number,number]} Row4
 *
 * A row of 4 numbers used in a Matrix4x4 type.
 */
 
/**
 * @typedef {list[Row3,Row3,Row3]} Matrix3x3
 *
 * A 3×3 non-homogeneous transformation matrix used for rotations and scaling
 * in 3D space.  Operates on 3-element vectors/points directly.
 */

/**
 * @typedef {list[Row4,Row4,Row4,Row4]} Matrix4x4
 *
 * A 4×4 homogeneous transformation matrix used for translations, rotations
 * about arbitrary points, and combined transformations in 3D space.  Operates
 * on homogeneous 4-element vectors `[x,y,z,1]`.
 */

/**
 * Transpose of a matrix.
 *
 * - Matrix (list of equal-length rows) → transposed matrix
 *
 * > NOTE:
 * >
 * > There is no need to transpose a vector to a column vector.  When OpenSCAD
 * > sees `M * V` or `V * M`, the vector `V` is automatically treated as a
 * > column or
 * > row vector as appropriate.
 *
 * @param {Matrix} A
 *   The matrix to transpose.
 *
 * @returns {Matrix}
 *   The transpose of matrix A.
 */
function transpose(A) =
  assert(is_list(A), "transpose: input must be a list")
  len(A) == 0 ? [] :
  assert(is_list(A[0]), "A must be a matrix")
  let(
    row_lens = [for (r = A) len(r)],
    nc = row_lens[0]
  )
  assert(min(row_lens) == nc && max(row_lens) == nc,
          "transpose: non-rectangular matrix")
  [ for (j = [0 : nc - 1])
    [ for (i = [0 : len(A) - 1]) A[i][j] ]
  ]
;

/**
 * @typedef {list} Point2D
 *
 * A 2D point.
 *
 * @slot {number} 0
 *   This is the dimension `0` or x dimension of the point.  Can also be accessed
 *   by property `.x`.
 * @slot {number} 1
 *   This is the dimension `1` or y dimension of the point.  Can also be accessed
 *   by property `.y`.
 */

/**
 * @typedef {list} Point3D
 *
 * A 3D point.
 *
 * @slot {number} 0
 *   This is the dimension `0` or x dimension of the point.  Can also be accessed
 *   by property `.x`.
 * @slot {number} 1
 *   This is the dimension `1` or y dimension of the point.  Can also be accessed
 *   by property `.y`.
 * @slot {number} 2
 *   This is the dimension `2` or z dimension of the point.  Can also be accessed
 *   by property `.z`.
 */

/**
 * @typedef {list} Point
 *
 * An ND point.
 *
 * @slot {number} 0
 *   This is the dimension `0` or x dimension of the point.  Can also be accessed
 *   by property `.x`.
 * @slot {number} 1
 *   This is the dimension `1` or y dimension of the point.  Can also be accessed
 *   by property `.y`.
 * @slot {number} 2
 *   This is the dimension `2` or z dimension of the point.  Can also be accessed
 *   by property `.z`.
 * @slot {number} [n]
 *   This is the dimension `n` dimension of the point.
 */

/**
 * Convert points to homogeneous coordinates.
 *
 * Each point is padded with zeros up to dimension n-1, then a trailing 1 is
 * appended.
 *
 * @param {list[Point,...]} pts
 *   List of points.  Each point must have dimension < n.
 * @param {number} n
 *   Target homogeneous dimension.  Must be greater than the dimension of every
 *   point in pts.
 *
 * @returns {list[Point,...]}
 *   List of n-dimensional points with homogeneous coordinate 1 at index n-1.
 */
function homogenise(pts, n=4) =
  let (result =
  [ for (i = [0 : len(pts) - 1]) // iterate over each point in list of points
    assert(len(pts[i]) < n, "Points must have fewer dimensions than n.")
    [ for (j = [0 : n - 1]) // iterate over each dimension in each point
      j < len(pts[i])
      ? pts[i][j]
      : j < n - 1 ? 0 : 1
    ]
  ])
  // echo("homogenise: ", result)
  result
;
// echo("test homogenise:", homogenise([[2,3,4]], 4));

/**
 * Dehomogenises a list of homogeneous points to Euclidean points.
 *
 * Each input point must have at least n+1 coordinates.  The homogeneous divisor w is the
 * last coordinate of the point (index len(pt)-1).  This function returns the first n
 * coordinates divided by w, and discards all remaining coordinates.
 *
 * This is the companion to homogenise() when homogenise() places w at the last coordinate.  A
 * typical pipeline is: homogenise points to match an M×M transform, multiply, then project
 * back to N dimensions with dehomogenise(..., N).
 *
 * Preconditions (enforced by asserts):
 *
 * - Every point pt satisfies len(pt) > n.  (There must be a last coordinate to use as w.)
 * - w != 0.  (Homogeneous projection is undefined for w == 0.)
 *
 * @param {list[Point,...]} pts
 *   List of homogeneous points.
 * @param {number} [n=3]
 *   Number of Euclidean coordinates to return per point.
 *
 * @returns {list[Point,...]}
 *   List of n-dimensional Euclidean points.
 */
function dehomogenise(pts, n=3) =
  [ for (i = [0 : len(pts) - 1]) // iterate over each point in list of points
      let (
        homogeneous =
          assert(len(pts[i]) > n, "Points must have the more dimensions than n.")
          pts[i][len(pts[i])-1]
      )
      assert(homogeneous != 0, "Homogeneous dimension can't have a value of 0.")
      [ for (j = [0 : n - 1]) // iterate over each dimension in each point
        pts[i][j] / homogeneous
      ]
  ]
;
// echo("test dehomogenise:", dehomogenise(homogenise([[2,3,4]], 4), 4));

/**
 * Embed a non-homogeneous square transform into a larger homogeneous matrix.
 *
 * Returns a **homogeneous column-vector** matrix H (n×n).  A is placed in the
 * top-left block.
 *
 * Use:
 *
 * - If H is used as a transform matrix, apply it like any other homogeneous
 *   column-vector matrix:
 *   - Single point p: treat p as homogeneous when multiplying.
 *   - Point list Ps: use transform(Ps, transpose(H)).
 *
 * @param {Matrix} A
 *   Square M×M transform matrix.
 * @param {number} n
 *   Target homogeneous dimension.  Must satisfy M < n.
 *
 * @returns {Matrix}
 *   Homogeneous matrix H (n×n) with A in the top-left block and identity
 *   elsewhere.
 */
function homogenise_transform(A, n=4) =
  let(
    row_lens = [for (r = A) len(r)],
    nc = row_lens[0]
  )
  assert(min(row_lens) == nc && max(row_lens) == nc && len(A) == nc,
          "homogenise_transform: A must be square")
  assert(nc < n, "Number of columns and rows must be less than n.")
  [ for (i = [0 : n - 1])
    i < nc
    ? [ for (j = [0 : n - 1])
      j < nc
      ? A[i][j]
      : i == j ? 1 : 0
    ]
    : [ for (j = [0 : n - 1])
      i == j ? 1 : 0
    ]
  ]
;

// ROTATION MATRIX
// --- Rotation matrices (3D) -----------------------------------------------

/**
 * @typedef {list} Vector2D
 *
 * A bound 2D vector, which starts from the origin.
 *
 * @slot {number} 0
 *   This is the dimension `0` or x dimension of the vector.  Can also be
 *   accessed by property `.x`.
 * @slot {number} 1
 *   This is the dimension `1` or y dimension of the vector.  Can also be
 *   accessed by property `.y`.
 */

/**
 * @typedef {list} Vector3D
 *
 * A bound 3D vector, which starts from the origin.
 *
 * @slot {number} 0
 *   This is the dimension `0` or x dimension of the vector.  Can also be
 *   accessed by property `.x`.
 * @slot {number} 1
 *   This is the dimension `1` or y dimension of the vector.  Can also be
 *   accessed by property `.y`.
 * @slot {number} 2
 *   This is the dimension `2` or z dimension of the vector.  Can also be
 *   accessed by property `.z`.
 */

/**
 * @typedef {list} Vector
 *
 * A bound ND vector, which starts from the origin.
 *
 * @slot {number} 0
 *   This is the dimension `0` or x dimension of the vector.  Can also be
 *   accessed by property `.x`.
 * @slot {number} 1
 *   This is the dimension `1` or y dimension of the vector.  Can also be
 *   accessed by property `.y`.
 * @slot {number} 2
 *   This is the dimension `2` or z dimension of the vector.  Can also be
 *   accessed by property `.z`.
 * @slot {number} [n]
 *   This is the dimension `n` dimension of the vector.
 */

/**
 * @typedef {list[Point2D,Point2D]} BVector2D
 *
 * A bound 2D vector, which starts from point in slot 0 and goes to point in
 * slot 1.
 *
 * @slot {Point2D} 0
 *   This is the starting point for this bound vector.
 * @slot {Point2D} 1
 *   This is the ending point for this bound vector.
 */

/**
 * @typedef {list[Point3D,Point3D]} BVector3D
 *
 * A bound 3D vector, which starts from point in slot 0 and goes to point in
 * slot 1.
 *
 * @slot {Point3D} 0
 *   This is the starting point for this bound vector.
 * @slot {Point3D} 1
 *   This is the ending point for this bound vector.
 */

/**
 * @typedef {list[Point,Point]} BVector
 *
 * A bound ND vector, which starts from point in slot 0 and goes to point in
 * slot 1.
 *
 * @slot {Point} 0
 *   This is the starting point for this bound vector.
 * @slot {Point} 1
 *   This is the ending point for this bound vector.
 */

/**
 * Rotation matrix about the X axis.
 *
 * Returns a **non-homogeneous column-vector** rotation matrix M (3×3).
 *
 * Use:
 *
 * - Single Point    p:  p' = M * p
 * - List of Points Ps:  Ps' = Ps * transpose(M)
 *
 * @param {number} a
 *   Rotation angle in degrees.
 *
 * @returns {Matrix3x3}
 *   Column-vector rotation matrix M.
 */
function rot_x(a) =
  [
    [ 1,       0,        0 ],
    [ 0,  cos(a),  -sin(a) ],
    [ 0,  sin(a),   cos(a) ]
  ]
;

/**
 * Rotation matrix about the Y axis.
 *
 * Returns a **non-homogeneous column-vector** rotation matrix M (3×3).
 *
 * Use:
 *
 * - Single Point    p:  p' = M * p
 * - List of Points Ps:  Ps' = Ps * transpose(M)
 *
 * @param {number} a
 *   Rotation angle in degrees.
 *
 * @returns {Matrix3x3}
 *   Column-vector rotation matrix M.
 */
function rot_y(a) =
  [
    [  cos(a), 0,  sin(a) ],
    [       0, 1,       0 ],
    [ -sin(a), 0,  cos(a) ]
  ]
;

/**
 * Rotation matrix about the Z axis.
 *
 * Returns a **non-homogeneous column-vector** rotation matrix M (3×3).
 *
 * Use:
 *
 * - Single Point    p:  p' = M * p
 * - List of Points Ps:  Ps' = Ps * transpose(M)
 *
 * @param {number} a
 *   Rotation angle in degrees.
 *
 * @returns {Matrix3x3}
 *   Column-vector rotation matrix M.
 */
function rot_z(a) =
  [
    [  cos(a), -sin(a), 0 ],
    [  sin(a),  cos(a), 0 ],
    [       0,       0, 1 ]
  ]
;

/**
 * Checks if `o` has the shape of a vector of `dim` `number`s.
 *
 * @param {any} o
 *   Object to test.
 * @param {number} [dim=3]
 *   Number of dimensions the vector should represent.
 *
 * @returns {bool}
 *   True if has the shape of a point of `dim` `number`s.
 */
function is_point(o, dim=3) =
  is_list(o) && len(o) == dim && all(0, len(o)-1)(function(i) is_num(o[i]))
;

/**
 * Checks if `o` has the shape of a free vector of `dim` `number`s.
 *
 * @param {any} o
 *   Object to test.
 * @param {number} [dim=3]
 *   Number of dimensions the vector should represent.
 *
 * @returns {bool}
 *   True if has the shape of a free vector of `dim` `number`s.
 */
function is_vector(o, dim=3) =
  is_list(o) && len(o) == dim && all(0, len(o)-1)(function(i) is_num(o[i]))
;

/**
 * Checks if `o` has the shape of 2 bound points of `dim` `number`s.  This
 * represents the starting and ending points of a bound vector.
 *
 * @param {any} o
 *   Object to test.
 * @param {number} [dim=3]
 *   Number of dimensions the vector should represent.
 *
 * @returns {bool}
 *   True if has the shape of 2 bound points of `dim` `number`s.
 */
function is_bound_vector(o, dim=3) =
  is_list(o) && len(o) == 2 && is_point(o[0], dim) && is_point(o[1], dim)
;

/**
 * Rotation matrix about an arbitrary axis.
 *
 * Returns a **non-homogeneous column-vector** rotation matrix M (3×3) that
 * rotates around the specified vector 'axis' rooted in the origin of the
 * coordinate system.
 *
 * Use:
 *
 * - Single Point    p:  p' = M * p
 * - List of Points Ps:  Ps' = Ps * transpose(M)
 *
 * @param {number} angle
 *   Rotation angle in degrees.
 * @param {Vector3D} axis
 *   Rotation axis vector (must be non-zero).
 *
 * @returns {Matrix3x3}
 *   Column-vector rotation matrix M.
 */
function rot_axis(angle, axis) =
  let(
    n = norm(axis)
  )
  assert(n > 0, "axis vector must be non-zero")
  let(
    ux = axis[0]/n, uy = axis[1]/n, uz = axis[2]/n,
    c = cos(angle), s = sin(angle), t = 1 - c,
    rot_matrix =
      [
        [ t*ux*ux + c,     t*ux*uy - s*uz, t*ux*uz + s*uy ],
        [ t*uy*ux + s*uz,  t*uy*uy + c,    t*uy*uz - s*ux ],
        [ t*uz*ux - s*uy,  t*uz*uy + s*ux, t*uz*uz + c    ]
      ]
  )
  rot_matrix
;

/**
 * Rotation matrix that parallels OpenSCAD's rotate() module, with the
 * additional feature that it can also take a `BVector3D` for `v`, meaning that
 * it can rotate about the point stipulated by the point in slot 0 of the
 * BVector.
 *
 * If `v` is a `Vector3D`, returns a **non-homogeneous column-vector** rotation
 * matrix M (3×3) that rotates around the specified vector 'axis' rooted in the
 * origin of the coordinate system.
 *
 * If `v` is a `BVector3D`, returns a **homogeneous column-vector** rotation
 * matrix M (4x4) that rotates around the specified vector 'axis' (`v[1]-v[0]`)
 * around point `v[0]`.
 *
 * To not have to worry about the matrix size, it's recommended that you use the
 * [`transform()`](#f-transform) API.
 *
 * Use if `p` or elements of `Ps` are homogeneous/non-homogeneous as `M` is:
 *
 * - Single Point    p:  p' = M * p
 * - List of Points Ps:  Ps' = Ps * transpose(M)
 * or if don't want to worry about having to use
 * [`homogenise()`](#f-homogenise)/[`dehomogenise()`](#f-dehomogenise), use
 * [`transform()`](#f-transform) API:
 * - Single Point    p:  `p' = transform([p], transpose(M))`
 * - List of Points Ps:  `Ps' = transform(Ps, transpose(M))`
 *
 * @param {(number|list[number,number,number])} a
 *   - If `number` and `v` is not supplied: rotate CCW around Z.
 *   - If `number` and `v` is a `Vector3D`: rotate CCW around axis defined by
 *     `v`.
 *   - If `list` `[rx,ry,rz]`: apply rotations about X then Y then Z (degrees).
 *     (v is ignored.)
 * @param {(Vector3D|BVector3D)} [v]
 *   - If `a` is a number
 *     - If `v` is a specified Vector3D, then this is the axis vector.
 *     - If `v` is a specified BVector3D, then use direction for the axis vector
 *       and `v[0]` as the rotation point.
 *     - Otherwise axis vector is Z.
 *
 * @returns {(Matrix3x3|Matrix4x4)}
 *   Column-vector rotation matrix M.
 *
 *   - If `v` is a `BVector3D`, then returns a homogenised transform matrix
 *     (4x4).
 *   - If `v` is a `Vector3D`, then returns a non-homogenised transform matrix
 *     (3x3).
 */
function rotate(a, v=undef) =
  is_num(a)
  ? is_undef(v)
    ? rot_z(a)
    : is_vector(v)
      ? rot_axis(a, v)
      : is_bound_vector(v)
        ? translate(v[0]) *
          homogenise_transform(rot_axis(a, v[1]-v[0])) *
          translate(-v[0])
        : assert(false, "rotate(angle, axis): axis must be a Vector3D") undef
  : is_list(a) && len(a) == 3
      ? rot_z(a[2]) * rot_y(a[1]) * rot_x(a[0])   // Rz * Ry * Rx
      : assert(false, "rotate([rx,ry,rz]): need 3 components") undef
;

// echo(str("rotate test: ", [[1, 0, 0] ,[1, 0, 0]] * transpose(rotate([0,0,45]))));
// echo(str("rotate test: ", rotate([0,0,45]) * [1, 0, 0]));

/**
 * Translation matrix that parallels OpenSCAD's translate() module.
 *
 * Returns a **homogeneous column-vector** translation matrix T (4×4).
 *
 * Use:
 *
 * - Single 3D point `p`: `p` must be as homogeneous (`[x,y,z,1]`) when multiplying.
 * - Point list `Ps` (3D): use `transform(Ps, transpose(T))`.
 *
 * @param {list[number]} v
 *   Translation vector.
 *
 * @returns {Matrix4x4}
 *   Homogeneous column-vector translation matrix T.
 */
function translate(v) =
  [
    [ 1, 0, 0, v[0] ],
    [ 0, 1, 0, v[1] ],
    [ 0, 0, 1, v[2] ],
    [ 0, 0, 0,    1 ]
  ]
;

/**
 * Scale matrix that parallels OpenSCAD's scale() module.
 *
 * Returns a **non-homogeneous column-vector** scaling matrix S (3×3).
 *
 * Use:
 *
 * - Single point p (3-vector):  p' = S * p
 * - Point list Ps:              Ps' = Ps * transpose(S)
 *
 * @param {list[number]} v
 *   Per-axis scale factors.
 *
 * @returns {Matrix3x3}
 *   Column-vector scaling matrix S.
 */
function scale(v) =
  [
    [ v[0],    0,    0 ],
    [    0, v[1],    0 ],
    [    0,    0, v[2] ]
  ]
;
// echo(str("translate test 1: ", translate([1.5, 2.5, 3.5]) * [1,1,1,1]));
// echo(str("translate test 2: ", homogenise([[1,1,1]], 4) * transpose(translate([1.5, 2.5, 3.5]))));

/**
 * Transform a list of points using either a matrix or a point-mapping function.
 *
 * Points in pts are treated as **row vectors** (each point is a 1×d row).
 *
 * - If `matrix_or_fn` is a `Matrix`, and since all matrices generated by this
 *   library are column-vector matrices `M`, you must pass `transpose(M)` here.
 *
 * - If matrix_or_fn is a homogeneous matrix (e.g.  4×4 for 3D points), this
 *   function homogenises pts, multiplies, then dehomogenises back to the
 *   original point dimension.
 *
 * @param {list[Point]} pts
 *   List of points (rows).  All points must have the same dimension.
 * @param {(Matrix3x3|Matrix4x4|function(pt: Point): Point)} matrix_or_fn
 *   Either:
 *
 *   - a matrix in row-vector orientation (typically `transpose(M)`), or
 *   - a function that maps a single point to a transformed point.
 *
 * @returns {list[Point]}
 *   Transformed points.
 */
function transform(pts, matrix_or_fn) =
  is_function(matrix_or_fn)
  ? [ for (pt = pts) matrix_or_fn(pt) ]
  : len(pts[0]) < len(matrix_or_fn)
    ? dehomogenise(homogenise(pts, len(matrix_or_fn)) * matrix_or_fn, len(pts[0]))
    : // echo(len(pts[0]), len(matrix_or_fn), type_structure(pts), type_structure(matrix_or_fn))
      pts * matrix_or_fn
;

/**
 * @typedef {list[Point3D, Point3D]} AxisFrameRef
 *
 * Frame reference defined by an origin and a single axis endpoint:
 *
 *     [origin, end0]
 *
 * Note: roll about the axis is under-determined by this reference alone.
 */

/**
 * @typedef {list[Point3D, Point3D, Point3D]} PlanarFrameRef
 *
 * Frame reference defined by an origin and two axis endpoints:
 *
 *     [origin, end0, end1]
 *
 * The third axis is implied by the right-hand normal `cross(end0-origin,
 * end1-origin)`.
 */

/**
 * @typedef {list[Point3D, Point3D, Point3D, Point3D]} SpatialFrameRef
 *
 * Frame reference defined by an origin and three axis endpoints:
 *
 *     [origin, end0, end1, end2]
 *
 * This defines a full 3D frame (must be non-singular).
 */

/**
 * @typedef {(AxisFrameRef|PlanarFrameRef|SpatialFrameRef)} FrameRef
 *   Any supported frame reference shape.
 */

/**
 * @callchain frame_transform(src_axis_ref,  dst_axis_ref,  axis_scales) : Matrix4x4
 * @callchain frame_transform(src_plane_ref, dst_plane_ref, axis_scales) : Matrix4x4
 * @callchain frame_transform(src_frame_ref, dst_frame_ref, axis_scales) : Matrix4x4
 *
 * Returns a homogeneous transform matrix T (4×4) that maps one reference frame
 * to another (move + orientation, with optional scaling).
 *
 * Each reference frame is given as a "vector space" list:
 *
 *   `[origin, end0, ..., endN]` where `N ∈ {0,1,2}`.  (So length is 2-4.)
 *
 * The axis directions are defined by:
 *
 *   `v_i = end_i - origin`   (for i = 0..N)
 *
 * Axis order is the endpoint order:
 *
 *     end0 -> axis 0 (x),  end1 -> axis 1 (y),  end2 -> axis 2 (z).
 *
 * Mapping contract:
 *   - The origin maps exactly: `T * [src_origin,1] = [dst_origin,1]`
 *     (in homogeneous coordinates, i.e. the 3D point with a 1 appended).
 *   - Axis directions are reoriented so axis i in space 1 aligns to axis i in
 *     space 2.
 *   - If scaling is enabled (see axis_scales), axis magnitudes are adjusted per
 *     the selected rule.
 *
 * Overloads (by input length):
 *   - 2-point ([`AxisFrameRef`](#t-AxisFrameRef)):  aligns a single axis
 *     direction (end0-origin). Roll about that axis is not defined by the
 *     inputs.  When the directions are opposite (180°), a deterministic
 *     perpendicular axis is chosen to define the rotation.
 *
 *     > NOTE:
 *     >
 *     > Scaling is uniform (same factor in x/y/z); axis_scales controls that
 *     > single uniform factor.
 *
 *   - 3-point ([`PlanarFrameRef`](#t-PlanarFrameRef)):  aligns two axes in a
 *     plane.  The third axis is derived as the right-hand normal:
 *     `cross(axis0, axis1)`.  The normal axis is not scaled.
 *   - 4-point ([`SpatialFrameRef`](#t-SpatialFrameRef)):  aligns a full 3D
 *     frame (three axes).  The three axis vectors must be linearly independent
 *     (i.e. not coplanar).
 *
 * axis_scales controls scaling along the defined axes:
 *   - false: reorient only (no scaling).
 *   - true:  per-axis ratio scaling:  `s_i = |dst_axis_i| / |src_axis_i|`.
 *   - number: scale each defined axis by that factor.
 *   - `list[(bool|number), ...]`: per-axis control in endpoint order.
 *
 * > NOTE:
 * >
 * > This returns a matrix intended for column-vector style application, i.e.
 * > vertices `v=[x,y,z,1]` are transformed as `m*v`.  The 4th row is
 * > `[0,0,0,1]`.
 *
 * @param {(AxisFrameRef|PlanarFrameRef|SpatialFrameRef)} src_ref
 * @param {(AxisFrameRef|PlanarFrameRef|SpatialFrameRef)} dst_ref
 * @param {(bool|number|list[(bool|number),...])} [axis_scales=false]
 *
 * @returns {Matrix4x4}
 *   Homogeneous 4×4 transform matrix, mapping `src_ref` -> `dst_ref`.
 */
function frame_transform(src_ref, dst_ref, axis_scales = false) =
  let(
    nA = len(src_ref),
    nB = len(dst_ref),
    axis_cnt = nA - 1,

    ctrls =
      is_list(axis_scales)
      ? axis_scales
      : [for (i = [0:axis_cnt - 1]) axis_scales],

    bad_ctrls = [for (c = ctrls) if (!(is_bool(c) || is_num(c))) 1],

    EPS = 1e-12
  )
  assert(
    (nA == 2 || nA == 3 || nA == 4) && nA == nB,
    "reorient: inputs must have length 2, 3, or 4, and match."
  )
  assert(
    len(ctrls) == axis_cnt,
    "reorient: axis_scales list length must be len(vs)-1."
  )
  assert(
    len(bad_ctrls) == 0,
    "reorient: axis_scales entries must be bool or number."
  )

  // ---------- 2-point overload: align direction + optional uniform scale ----------
  (nA == 2)
  ? (
      let(
        P0 = src_ref[0],  P1 = src_ref[1],
        Q0 = dst_ref[0],  Q1 = dst_ref[1],
        v  = P1 - P0,            w  = Q1 - Q0,
        lv = norm(v),            lw = norm(w)
      )
      assert(lv > 0 && lw > 0, "reorient(2pt): axis vectors must be non-zero.")
      let(
        u_hat = v / lv,
        w_hat = w / lw,

        rot_axis_vec  = cross(u_hat, w_hat),
        rot_axis_norm = norm(rot_axis_vec),

        dot_raw = u_hat * w_hat,
        c = clamp(dot_raw, -1, 1),

        theta_deg = acos(c),  // degrees

        R3 =
          (rot_axis_norm < EPS)
          ? (
              (c > 0)
              ? identity(3)
              : let(
                  ref_axis =
                    (abs(u_hat[0]) < 0.9) ? [1, 0, 0] : [0, 1, 0],
                  ortho_axis = cross(u_hat, ref_axis),
                  ortho_unit = ortho_axis / norm(ortho_axis)
                )
                rot_axis(180, ortho_unit)
            )
          : rot_axis(theta_deg, rot_axis_vec / rot_axis_norm),

        s =
          (ctrls[0] == true)
          ? assert(
              lv > 0 && lw > 0,
              "reorient(2pt): |v| and |w| must be > 0 for ratio scaling."
            )
            lw / lv
          : (ctrls[0] == false)
            ? 1
            : ctrls[0],

        L3 = (s == 1) ? R3 : R3 * scale([s, s, s]),
        T1 = translate(-P0),
        T2 = translate(Q0)
      )
      T2 * homogenise_transform(L3) * T1
    )

  // ---------- 3-point overload: planar frame map + per-axis scaling ----------
  : (nA == 3)
    ? (
        let(
          P0 = src_ref[0],  P1 = src_ref[1],
          P2 = src_ref[2],
          Q0 = dst_ref[0],  Q1 = dst_ref[1],
          Q2 = dst_ref[2],

          v1 = P1 - P0,            v2 = P2 - P0,
          w1 = Q1 - Q0,            w2 = Q2 - Q0,

          lv1 = norm(v1),          lv2 = norm(v2),
          lw1 = norm(w1),          lw2 = norm(w2)
        )
        assert(
          lv1 > 0 && lv2 > 0,
          "reorient(3pt): start axes must be non-zero."
        )
        assert(
          lw1 > 0 && lw2 > 0,
          "reorient(3pt): end axes must be non-zero."
        )
        let(
          v1_hat = v1 / lv1,
          v2_hat = v2 / lv2,
          w1_hat = w1 / lw1,
          w2_hat = w2 / lw2,

          nS = cross(v1_hat, v2_hat),  nSn = norm(nS),
          nE = cross(w1_hat, w2_hat),  nEn = norm(nE)
        )
        assert(nSn > EPS, "reorient(3pt): start points are collinear.")
        assert(nEn > EPS, "reorient(3pt): end points are collinear.")
        let(
          s1 =
            (ctrls[0] == true)
            ? assert(
                lv1 > 0,
                "reorient(3pt): |v1| must be > 0 for ratio scaling."
              )
              lw1 / lv1
            : (ctrls[0] == false)
              ? 1
              : ctrls[0],

          s2 =
            (ctrls[1] == true)
            ? assert(
                lv2 > 0,
                "reorient(3pt): |v2| must be > 0 for ratio scaling."
              )
              lw2 / lv2
            : (ctrls[1] == false)
              ? 1
              : ctrls[1],

          BS = [
            [ v1_hat[0],  v2_hat[0],  nS[0] / nSn ],
            [ v1_hat[1],  v2_hat[1],  nS[1] / nSn ],
            [ v1_hat[2],  v2_hat[2],  nS[2] / nSn ]
          ],
          BE = [
            [ w1_hat[0],  w2_hat[0],  nE[0] / nEn ],
            [ w1_hat[1],  w2_hat[1],  nE[1] / nEn ],
            [ w1_hat[2],  w2_hat[2],  nE[2] / nEn ]
          ],
          S = [
            [ s1, 0,  0 ],
            [ 0,  s2, 0 ],
            [ 0,  0,  1 ]
          ],

          L3 = BE * S * invert(BS),
          T1 = translate(-P0),
          T2 = translate(Q0)
        )
        T2 * homogenise_transform(L3) * T1
      )

    // ---------- 4-point overload: full 3D frame map + per-axis scaling ----------
    : (
        let(
          P0 = src_ref[0],  P1 = src_ref[1],
          P2 = src_ref[2],  P3 = src_ref[3],
          Q0 = dst_ref[0],  Q1 = dst_ref[1],
          Q2 = dst_ref[2],  Q3 = dst_ref[3],

          v1 = P1 - P0,            v2 = P2 - P0,            v3 = P3 - P0,
          w1 = Q1 - Q0,            w2 = Q2 - Q0,            w3 = Q3 - Q0,

          lv1 = norm(v1),          lv2 = norm(v2),          lv3 = norm(v3),
          lw1 = norm(w1),          lw2 = norm(w2),          lw3 = norm(w3)
        )
        assert(
          lv1 > 0 && lv2 > 0 && lv3 > 0,
          "reorient(4pt): start axes must be non-zero."
        )
        assert(
          lw1 > 0 && lw2 > 0 && lw3 > 0,
          "reorient(4pt): end axes must be non-zero."
        )
        let(
          detS = v1 * cross(v2, v3),
          detE = w1 * cross(w2, w3)
        )
        assert(
          abs(detS) > EPS * lv1 * lv2 * lv3,
          "reorient(4pt): start frame is singular."
        )
        assert(
          abs(detE) > EPS * lw1 * lw2 * lw3,
          "reorient(4pt): end frame is singular."
        )
        let(
          v1_hat = v1 / lv1,
          v2_hat = v2 / lv2,
          v3_hat = v3 / lv3,
          w1_hat = w1 / lw1,
          w2_hat = w2 / lw2,
          w3_hat = w3 / lw3,

          s1 =
            (ctrls[0] == true)
            ? assert(
                lv1 > 0,
                "reorient(4pt): |v1| must be > 0 for ratio scaling."
              )
              lw1 / lv1
            : (ctrls[0] == false)
              ? 1
              : ctrls[0],

          s2 =
            (ctrls[1] == true)
            ? assert(
                lv2 > 0,
                "reorient(4pt): |v2| must be > 0 for ratio scaling."
              )
              lw2 / lv2
            : (ctrls[1] == false)
              ? 1
              : ctrls[1],

          s3 =
            (ctrls[2] == true)
            ? assert(
                lv3 > 0,
                "reorient(4pt): |v3| must be > 0 for ratio scaling."
              )
              lw3 / lv3
            : (ctrls[2] == false)
              ? 1
              : ctrls[2],

          BS = [
            [ v1_hat[0],  v2_hat[0],  v3_hat[0] ],
            [ v1_hat[1],  v2_hat[1],  v3_hat[1] ],
            [ v1_hat[2],  v2_hat[2],  v3_hat[2] ]
          ],
          BE = [
            [ w1_hat[0],  w2_hat[0],  w3_hat[0] ],
            [ w1_hat[1],  w2_hat[1],  w3_hat[1] ],
            [ w1_hat[2],  w2_hat[2],  w3_hat[2] ]
          ],
          S = [
            [ s1, 0,  0 ],
            [ 0,  s2, 0 ],
            [ 0,  0,  s3 ]
          ],

          L3 = BE * S * invert(BS),
          T1 = translate(-P0),
          T2 = translate(Q0)
        )
        T2 * homogenise_transform(L3) * T1
      )
;

////////////////////////////////////////////////////////////////////////////////
// INVERT MATRIX

/** ### Matrix Math */
/**
 * Invert a square matrix using Gauss-Jordan elimination with partial pivoting.
 *
 * @param {Matrix} A
 *   Non-empty square numeric matrix (list of equal-length lists).
 * @param {number} [eps=1e-12]
 *   Pivot tolerance.  Must be > 0.
 *
 * @returns {Matrix}
 *   The inverse matrix `A⁻¹`.
 *
 *   Assertion failure if `A` is not a valid square numeric matrix or if any
 *   pivot has `|pivot| < eps`.
 *
 *   Example
 *
 *       invert([[4,7],[2,6]])  // -> [[0.6,-0.7],[-0.2,0.4]]
 */
function invert(A, eps = 1e-12) =
  assert(_is_square_matrix(A), "invert: A must be a non-empty square matrix")
  assert(_all_numeric(A), "invert: all entries in A must be numeric")
  let(
    n   = len(A),
    aug = augment(A, identity(n))    // [A | I]
  )
  let(
    raug = row_reduction(aug, 0, n, eps)  // reduce to [I | A⁻¹]
  )
  _right_half(raug, n);

/**
 * Performs Gauss-Jordan row reduction with partial pivoting on an augmented
 * matrix.
 *
 * @param {Matrix} aug
 *   Augmented matrix of shape `n×(2n)`, typically `[A | I]`.
 * @param {number} k
 *   Current column index (0-based).  External callers pass 0.
 * @param {number} n
 *   Matrix order.  Must equal the row count of aug.
 * @param {number} eps
 *   Pivot tolerance.  Must be > 0.
 *
 * @returns {Matrix}
 *   The reduced augmented matrix.  For a non-singular A this is `[I | A⁻¹]`.
 *
 *   Assertion failure if `|pivot| < eps` at any step.
 */
function row_reduction(aug, k, n, eps) =
  (k >= n) ? aug
  : let(
      r     = _argmax_abs_col(aug, k, k),
      aug1  = (r == k) ? aug : _swap_rows(aug, k, r),
      piv   = aug1[k][k]
    )
    assert(abs(piv) >= eps,
           str("invert: singular/ill-conditioned at column ", k, " (|pivot| < eps)"))
    let(
      // Normalise pivot row to make pivot = 1
      rowk  = [for (j = [0 : 2*n - 1]) aug1[k][j] / piv],
      aug2  = [for (i = [0 : n - 1]) (i == k) ? rowk : aug1[i]],
      // Eliminate column k in all other rows
      aug3  = [for (i = [0 : n - 1])
                (i == k) ? aug2[i]
                         : let(f = aug2[i][k])
                           [for (j = [0 : 2*n - 1]) aug2[i][j] - f * rowk[j]]
              ]
    )
    row_reduction(aug3, k + 1, n, eps);

// --- Helpers ---

/**
 * Creates an n×n identity matrix.
 *
 * @param {number} n
 *   Matrix order.  Must be > 0.
 *
 * @returns {Matrix}
 *   The identity matrix of order n.
 */
function identity(n) =
  let ( _ = verify_vpos(n) )
  [for (i = [0 : n - 1]) [for (j = [0 : n - 1]) (i == j) ? 1 : 0]];

/**
 * Horizontally concatenates two matrices with the same row count.
 *
 * @param {Matrix} A
 *   Left matrix with r rows.
 * @param {Matrix} B
 *   Right matrix with r rows.
 *
 * @returns {Matrix}
 *   The augmented matrix `[A | B]`.
 *
 *   Assertion failure if A and B do not have the same non-zero row count.
 */
function augment(A, B) =
  assert(len(A) == len(B) && len(A) > 0,
         "augment: A and B must have same row count and be non-empty")
  [for (i = [0 : len(A) - 1]) concat(A[i], B[i])];

/**
 * Extracts the right half (columns `n..2n-1`) of an `n × (2n)` augmented matrix.
 *
 * @param {Matrix} aug
 *   Augmented matrix of shape n×(2n).
 * @param {number} n
 *   Left block width and row count.
 *
 * @returns {Matrix}
 *   The right n×n block.
 */
function _right_half(aug, n) =
  [for (i = [0 : n - 1]) [for (j = [n : 2*n - 1]) aug[i][j]]];

/**
 * Returns a copy of matrix M with rows i and j swapped.
 *
 * @param {Matrix} M
 *   Input matrix.
 * @param {number} i
 *   First row index (0-based).
 * @param {number} j
 *   Second row index (0-based).
 *
 * @returns {Matrix}
 *   Matrix with rows i and j exchanged.
 */
function _swap_rows(M, i, j) =
  [for (r = [0 : len(M) - 1]) (r == i) ? M[j] : (r == j) ? M[i] : M[r]];

/**
 * Finds the row index `r ∈ [start..n-1]` that maximises `|aug[r][col]|`.
 * Ties resolve to the first occurrence.
 *
 * @param {Matrix} aug
 *   Matrix to scan.
 * @param {number} col
 *   Column index to examine.
 * @param {number} start
 *   First row index to consider (inclusive).
 *
 * @returns {number}
 *   Row index of the maximal absolute entry in the given column slice.
 */
function _argmax_abs_col(aug, col, start) =
  let(
    n    = len(aug),
    mags = [for (r = [start : n - 1]) abs(aug[r][col])],
    mval = max(mags),
    idx0 = search(mval, mags)[0]
  ) start + idx0;

/**
 * Tests whether M is a rectangular list-of-lists with consistent row length.
 *
 * @param {any} M
 *   Candidate matrix.
 *
 * @returns {bool}
 *   true if M is a non-empty list of rows with equal positive length.
 */
function _is_rect_matrix(M) =
  is_list(M) && (len(M) > 0) && is_list(M[0]) &&
  (let(c = len(M[0]))
     (c > 0) &&
     (min([for (row = M) (is_list(row) && len(row) == c) ? 1 : 0]) == 1));

/**
 * Tests whether M is a square matrix (rectangular and rows == columns).
 *
 * @param {any} M
 *   Candidate matrix.
 *
 * @returns {bool}
 *   true if M is rectangular and `len(M) == len(M[0])`.
 */
function _is_square_matrix(M) =
  _is_rect_matrix(M) && (len(M) == len(M[0]));

/**
 * Tests whether all entries of M are numeric.
 *
 * @param {any} M
 *   Candidate matrix.
 *
 * @returns {bool}
 *   true if every element in every row is numeric.
 */
function _all_numeric(M) =
  (min([for (row = M) min([for (x = row) is_num(x) ? 1 : 0])]) == 1);

